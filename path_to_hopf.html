<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Living Mathematical Universe ‚Äî Path to Hopf Fibration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Hover Tooltip */
        .hover-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 10px 14px;
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -130%);
            transition: opacity 0.15s ease;
            z-index: 150;
            white-space: nowrap;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8);
        }

        .hover-label .category-tag {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: block;
            margin-bottom: 3px;
            opacity: 0.7;
        }
        
        .hover-label .status-indicator {
            font-size: 0.7rem;
            margin-top: 4px;
            opacity: 0.6;
        }

        #tooltip-canvas {
            display: block;
            margin-top: 8px;
            width: 160px;
            height: 80px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
            opacity: 0.9;
        }
        
        /* Allow tooltip to expand for the visualization */
        .hover-label {
            white-space: normal;
            min-width: 160px;
        }
        
        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 24px;
            left: 24px;
            z-index: 100;
            pointer-events: none;
        }
        
        .title-overlay h1 {
            font-size: 2.2rem;
            font-weight: 200;
            letter-spacing: -0.02em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff 0%, #10b981 50%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .title-overlay p {
            color: #555;
            font-size: 0.8rem;
            max-width: 280px;
            line-height: 1.5;
        }
        
        .title-overlay .shader-tag {
            display: inline-block;
            padding: 4px 10px;
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.65rem;
            color: #10b981;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            padding: 14px 20px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #666;
            font-weight: 600;
        }
        
        .control-group select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            min-width: 180px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .control-group select:hover {
            border-color: rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.08);
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
        }
        
        /* Legend */
        .legend {
            position: fixed;
            bottom: 24px;
            left: 24px;
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            pointer-events: none;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }
        
        .legend-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #555;
        }
        
        /* Navigation & Playback */
        .nav-controls {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
        }

        .play-pause-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .play-pause-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Volume Control */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .volume-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .volume-btn:hover {
            color: #fff;
        }
        
        .volume-btn.active {
            color: #10b981;
        }
        
        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .nav-help {
            text-align: right;
            pointer-events: none;
        }
        
        .nav-help p {
            font-size: 0.65rem;
            color: #444;
            margin-bottom: 3px;
        }
        
        /* Timeline Display */
        .timeline-display {
            position: fixed;
            top: 140px;
            left: 24px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
            backdrop-filter: blur(20px);
            padding: 14px 18px;
            border-radius: 12px;
            border: 1px solid rgba(16, 185, 129, 0.2);
            pointer-events: none;
        }
        
        .timeline-display .label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #666;
            margin-bottom: 4px;
        }
        
        .timeline-display .time {
            font-size: 1.5rem;
            font-weight: 300;
            background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .timeline-display .subjects {
            font-size: 0.7rem;
            color: #555;
            margin-top: 4px;
        }
        
        /* Goal Display */
        .goal-display {
            position: fixed;
            top: 230px;
            left: 24px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            pointer-events: none;
            max-width: 220px;
        }
        
        .goal-display .goal-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #666;
            margin-bottom: 6px;
        }
        
        .goal-display .goal-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .goal-display .goal-desc {
            font-size: 0.7rem;
            color: #888;
            line-height: 1.4;
        }
        
        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 380px;
            background: rgba(8, 8, 12, 0.97);
            backdrop-filter: blur(30px);
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto;
            padding: 28px;
        }
        
        .info-panel.open {
            transform: translateX(0);
        }
        
        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }
        
        .info-panel-category {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 4px 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: inline-block;
        }
        
        .info-panel-title {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: -0.02em;
        }
        
        .info-panel-close {
            background: none;
            border: none;
            color: #555;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .info-panel-close:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
        }
        
        .info-panel-phase {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #555;
            font-size: 0.75rem;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            margin-bottom: 20px;
        }
        
        .info-panel-section {
            margin-bottom: 24px;
        }
        
        .info-panel-section-title {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #555;
            margin-bottom: 10px;
        }
        
        .info-panel-topics {
            list-style: none;
        }
        
        .info-panel-topics li {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            color: #bbb;
            font-size: 0.85rem;
            margin-bottom: 6px;
            line-height: 1.4;
        }
        
        .info-panel-topics li::before {
            content: '‚Üí';
            color: #444;
            flex-shrink: 0;
        }
        
        .info-panel-book {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 10px 14px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: all 0.2s;
        }
        
        .info-panel-book:hover {
            border-color: rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .info-panel-book-title {
            font-weight: 500;
            color: #ddd;
            font-size: 0.85rem;
        }
        
        .info-panel-book-note {
            font-size: 0.7rem;
            color: #666;
            margin-top: 2px;
        }
        
        .info-panel-prereqs {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .info-panel-prereq {
            font-size: 0.7rem;
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            color: #777;
        }
        
        .info-panel-relevance {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            border: 1px solid rgba(16, 185, 129, 0.25);
            padding: 14px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .info-panel-relevance-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #10b981;
            margin-bottom: 6px;
        }
        
        .info-panel-relevance-text {
            font-size: 0.8rem;
            color: #059669;
            line-height: 1.5;
        }
        
        /* Lineage highlight hint */
        .info-panel-lineage {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.25);
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
        }
        
        .info-panel-lineage-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .info-panel-lineage-text {
            font-size: 0.75rem;
            color: #60a5fa;
            line-height: 1.4;
        }
        
        /* Status badges */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 500;
        }
        
        .status-badge.required {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .status-badge.on-path {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .status-badge.completed {
            background: rgba(100, 116, 139, 0.2);
            color: #94a3b8;
            border: 1px solid rgba(100, 116, 139, 0.3);
        }
        
        /* --- NEW: Sidebar Visuals with Carousel --- */
        .viz-container {
            width: 100%;
            height: 140px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        #mini-viz-canvas {
            width: 100%;
            height: calc(100% - 24px);
            display: block;
        }

        .viz-nav-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .viz-nav-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            padding: 0;
        }

        .viz-nav-dot:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.2);
        }

        .viz-nav-dot.active {
            background: var(--viz-color, #10b981);
            box-shadow: 0 0 8px var(--viz-color, #10b981);
        }

        .viz-label {
            position: absolute;
            top: 6px;
            left: 10px; /* FIXED: Moved from right:8px to left:10px to avoid overlap with canvas text */
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255, 255, 255, 0.5); /* Increased contrast slightly */
            pointer-events: none;
            background: rgba(0,0,0,0.3); /* Added backdrop for better readability */
            padding: 2px 6px;
            border-radius: 4px;
        }

        .equation-display {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.1rem;
            text-align: center;
            color: #fff;
            padding: 12px;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.05) 50%, rgba(255,255,255,0) 100%);
            margin-bottom: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .intuition-box {
            background: rgba(16, 185, 129, 0.05);
            border-left: 2px solid #10b981;
            padding: 12px 16px;
            margin-bottom: 24px;
            border-radius: 0 8px 8px 0;
        }

        .intuition-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #10b981;
            margin-bottom: 4px;
            font-weight: 700;
        }

        .intuition-text {
            font-size: 0.85rem;
            color: #d1fae5;
            line-height: 1.5;
            font-weight: 300;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .controls-panel {
                top: auto;
                bottom: 100px;
                left: 16px;
                right: 16px;
                transform: none;
                flex-direction: column;
            }
            
            .control-group select {
                min-width: auto;
                width: 100%;
            }
            
            .info-panel {
                width: 100%;
            }
            
            .title-overlay h1 {
                font-size: 1.4rem;
            }
            
            .legend, .goal-display {
                display: none;
            }
        }
        
        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s;
        }
        
        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-top-color: #10b981;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        
        .loading-text {
            color: #444;
            font-size: 0.8rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p class="loading-text">Initializing the Living Mathematical Universe...</p>
        </div>
    </div>

    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Hover Tooltip -->
    <div class="hover-label" id="hover-tooltip">
        <span class="category-tag" id="tooltip-category">Category</span>
        <span class="node-name" id="tooltip-name">Node Name</span>
        <div class="status-indicator" id="tooltip-status"></div>
        <canvas id="tooltip-canvas" width="160" height="80"></canvas>
    </div>
    
    <!-- Title Overlay -->
    <div class="title-overlay">
        <h1>The Living Universe</h1>
        <p>Navigate from foundations to the Hopf fibration‚Äîrendered in real-time GLSL.</p>
        <div class="shader-tag">‚ö° GPU Shaders Active</div>
    </div>
    
    <!-- Controls -->
    <div class="controls-panel">
        <div class="control-group">
            <label>Starting Point</label>
            <select id="start-select">
                <option value="high-school">üéí High School Student</option>
                <option value="undergrad-physics" selected>‚öõÔ∏è Undergraduate Physics</option>
                <option value="undergrad-math">üìê Undergraduate Math</option>
                <option value="grad-physics">üî¨ Graduate Physics</option>
                <option value="grad-math">‚àû Graduate Math</option>
            </select>
        </div>
        <div class="control-group">
            <label>Learning Goal</label>
            <select id="goal-select">
                <option value="hopf-basic">üîµ Hopf Basics</option>
                <option value="hopf-construction">üåÄ Hopf Construction</option>
                <option value="hopf-deep" selected>üíé Deep Understanding</option>
                <option value="physics-app">‚öõÔ∏è Physics Applications</option>
            </select>
        </div>
    </div>
    
    <!-- Timeline Display -->
    <div class="timeline-display" id="timeline-display">
        <div class="label">Your Journey</div>
        <div class="time" id="timeline-time">4 years</div>
        <div class="subjects" id="timeline-subjects">22 subjects</div>
    </div>
    
    <!-- Goal Display -->
    <div class="goal-display" id="goal-display">
        <div class="goal-label">Destination</div>
        <div class="goal-name" id="goal-name">Deep Understanding</div>
        <div class="goal-desc" id="goal-desc">Full mastery of S¬π ‚Üí S¬≥ ‚Üí S¬≤</div>
    </div>
    
    <!-- Legend -->
    <div class="legend" id="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background: #3b82f6; color: #3b82f6;"></div>
            <span class="legend-label">Analysis</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #a855f7; color: #a855f7;"></div>
            <span class="legend-label">Algebra</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #10b981; color: #10b981;"></div>
            <span class="legend-label">Topology</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #f97316; color: #f97316;"></div>
            <span class="legend-label">Geometry</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ef4444; color: #ef4444;"></div>
            <span class="legend-label">Physics</span>
        </div>
    </div>
    
    <!-- Navigation Controls -->
    <div class="nav-controls">
        <div class="volume-control" id="volume-control">
            <button class="volume-btn" id="volume-btn" title="Toggle Sound">
                <svg id="icon-volume-on" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
                <svg id="icon-volume-off" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="display:none;">
                    <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
                </svg>
            </button>
            <input type="range" id="volume-slider" min="0" max="100" value="30" class="volume-slider" title="Volume">
        </div>
        <button class="play-pause-btn" id="play-pause-btn" title="Toggle Auto-Rotation">
            <svg id="icon-pause" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="4" width="4" height="16" rx="1" />
                <rect x="14" y="4" width="4" height="16" rx="1" />
            </svg>
            <svg id="icon-play" width="22" height="22" viewBox="0 0 24 24" fill="currentColor" style="display:none;">
                <path d="M6 4l14 8-14 8V4z" />
            </svg>
        </button>
        <div class="nav-help">
            <p>Drag to orbit ‚Ä¢ Scroll to zoom</p>
            <p>Click nodes to explore lineage</p>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-panel-header">
            <div>
                <div class="info-panel-category" id="panel-category">Category</div>
                <h2 class="info-panel-title" id="panel-title">Subject Name</h2>
            </div>
            <button class="info-panel-close" id="panel-close">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <div class="info-panel-phase" id="panel-phase">Phase Name</div>

        <div class="equation-display" id="panel-equation"></div>
        
        <div class="viz-container">
            <canvas id="mini-viz-canvas"></canvas>
            <span class="viz-label" id="viz-label">Primary</span>
            <div class="viz-nav-container" id="viz-nav">
                <button class="viz-nav-dot active" data-index="0" title="Primary"></button>
                <button class="viz-nav-dot" data-index="1" title="Dynamics"></button>
                <button class="viz-nav-dot" data-index="2" title="Phase Space"></button>
                <button class="viz-nav-dot" data-index="3" title="Structure"></button>
                <button class="viz-nav-dot" data-index="4" title="Application"></button>
            </div>
        </div>

        <div class="intuition-box" id="panel-intuition-box">
            <div class="intuition-label">Intuition</div>
            <div class="intuition-text" id="panel-intuition"></div>
        </div>

        <div class="info-panel-section">
            <div class="info-panel-section-title">Core Topics</div>
            <ul class="info-panel-topics" id="panel-topics"></ul>
        </div>
        
        <div class="info-panel-section">
            <div class="info-panel-section-title">üìö Recommended Texts</div>
            <div id="panel-books"></div>
        </div>
        
        <div class="info-panel-section" id="panel-prereqs-section">
            <div class="info-panel-section-title">Prerequisites</div>
            <div class="info-panel-prereqs" id="panel-prereqs"></div>
        </div>
        
        <div class="info-panel-lineage" id="panel-lineage">
            <div class="info-panel-lineage-title">üìç Learning Path</div>
            <div class="info-panel-lineage-text" id="panel-lineage-text"></div>
        </div>
        
        <div class="info-panel-relevance" id="panel-relevance">
            <div class="info-panel-relevance-title">üéØ Path to Hopf Fibration</div>
            <div class="info-panel-relevance-text" id="panel-relevance-text"></div>
        </div>
    </div>

    <!-- Import Maps for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        
        // =====================================================
        // PARAMETRIC GEOMETRY HELPER (Manual Implementation)
        // =====================================================
        function createParametricGeometry(func, slices, stacks) {
            try {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                const uvs = [];
                
                const target = new THREE.Vector3();
                
                // Generate vertices
                for (let i = 0; i <= stacks; i++) {
                    const v = i / stacks;
                    for (let j = 0; j <= slices; j++) {
                        const u = j / slices;
                        func(u, v, target);
                        
                        // Check for invalid values and clamp
                        const x = isFinite(target.x) ? target.x : 0;
                        const y = isFinite(target.y) ? target.y : 0;
                        const z = isFinite(target.z) ? target.z : 0;
                        
                        vertices.push(x, y, z);
                        uvs.push(u, v);
                    }
                }
                
                // Generate indices
                for (let i = 0; i < stacks; i++) {
                    for (let j = 0; j < slices; j++) {
                        const a = i * (slices + 1) + j;
                        const b = a + slices + 1;
                        const c = a + 1;
                        const d = b + 1;
                        
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
                
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.computeVertexNormals();
                geometry.computeBoundingSphere();
                
                return geometry;
            } catch (e) {
                console.warn('Parametric geometry creation failed, using fallback sphere:', e);
                return new THREE.SphereGeometry(0.28, 24, 24);
            }
        }

        // =====================================================
        // DATA
        // =====================================================
        
        const CATEGORY_COLORS = {
            analysis: 0x3b82f6,
            algebra: 0xa855f7,
            topology: 0x10b981,
            geometry: 0xf97316,
            physics: 0xef4444,
            foundations: 0x64748b
        };
        
        const CATEGORY_HEX = {
            analysis: '#3b82f6',
            algebra: '#a855f7',
            topology: '#10b981',
            geometry: '#f97316',
            physics: '#ef4444',
            foundations: '#64748b'
        };

        const curriculumData = {
            phases: [
                {
                    id: 'phase0', name: 'Phase 0: Prerequisites', level: 0,
                    subjects: [
                        { id: 'calculus', name: 'Calculus I-III', category: 'analysis', duration: '(review)',
                          equation: '‚à´ f(x) dx = F(b) - F(a)', 
                          intuition: 'The study of continuous change. How accumulation (integrals) and slopes (derivatives) are two sides of the same coin.',
                          topics: ['Derivatives & Integrals', 'Multivariable Calculus', 'Vector Calculus', 'Parametric Curves'],
                          books: [{ title: 'Calculus', author: 'Stewart', note: 'Standard' }, { title: 'Calculus', author: 'Spivak', note: 'Rigorous' }],
                          prerequisites: [], hopfRelevance: 'Parametric curves are essential for understanding S¬π and paths on spheres' },
                        { id: 'linear-algebra-basic', name: 'Linear Algebra', category: 'algebra', duration: '(review)',
                          equation: 'T(u + v) = T(u) + T(v)',
                          intuition: 'The language of flat spaces. It allows us to stretch, rotate, and transform space using matrices.',
                          topics: ['Vector Spaces', 'Linear Maps', 'Eigenvalues', 'Complex Vectors'],
                          books: [{ title: 'Linear Algebra Done Right', author: 'Axler', note: 'Essential!' }],
                          prerequisites: [], hopfRelevance: 'C¬≤ is where S¬≥ lives; complex vector spaces are crucial' },
                        { id: 'complex-numbers', name: 'Complex Analysis', category: 'analysis', duration: '1 month',
                          equation: 'e^{iœÄ} + 1 = 0',
                          intuition: 'Numbers with a 2D geometry. Rotation becomes multiplication, linking algebra to geometry perfectly.',
                          topics: ['Complex Arithmetic', 'Polar Form', 'Unit Circle S¬π', 'Complex Exponential'],
                          books: [{ title: 'Visual Complex Analysis', author: 'Needham', note: 'Beautiful' }],
                          prerequisites: ['calculus'], hopfRelevance: 'S¬π = unit complex numbers; the fiber of the Hopf fibration' },
                        { id: 'proofs', name: 'Proofs & Logic', category: 'foundations', duration: '1 month',
                          equation: 'P ‚üπ Q',
                          intuition: 'The grammar of mathematics. It ensures that what we build is true and stands on solid ground.',
                          topics: ['Set Theory', 'Logic', 'Proof Techniques', 'Functions'],
                          books: [{ title: 'Book of Proof', author: 'Hammack', note: 'Free online' }],
                          prerequisites: [], hopfRelevance: 'Rigorous proofs needed to verify Hopf properties' }
                    ]
                },
                {
                    id: 'phase1', name: 'Phase 1: Foundations', level: 1,
                    subjects: [
                        { id: 'real-analysis', name: 'Real Analysis', category: 'analysis', duration: '3-4 months',
                          equation: '‚àÄŒµ > 0, ‚àÉŒ¥ > 0',
                          intuition: 'Calculus under a microscope. It handles the weird edge cases of infinity and continuity.',
                          topics: ['Metric Spaces', 'Compactness', 'Continuity', 'Connectedness'],
                          books: [{ title: 'Understanding Analysis', author: 'Abbott', note: 'Start here' }],
                          prerequisites: ['calculus', 'proofs'], hopfRelevance: 'Compactness of S¬≥ and S¬≤ is essential' },
                        { id: 'point-set-topology', name: 'Point-Set Topology', category: 'topology', duration: '2-3 months',
                          equation: 'U ‚à© V ‚àà œÑ',
                          intuition: 'Geometry without distance. We care only about connection, closeness, and what happens when we stretch things.',
                          topics: ['Topological Spaces', 'Compactness', 'Quotient Spaces'],
                          books: [{ title: 'Topology', author: 'Munkres', note: 'Part I' }],
                          prerequisites: ['real-analysis'], hopfRelevance: 'Quotient topology: S¬≤ = S¬≥/S¬π' },
                        { id: 'abstract-algebra', name: 'Abstract Algebra', category: 'algebra', duration: '4-5 months',
                          equation: 'G / Ker(œÜ) ‚âÖ Im(œÜ)',
                          intuition: 'The study of symmetry itself. Groups describe how objects can move while staying the same.',
                          topics: ['Groups', 'Group Actions', 'Quotient Groups'],
                          books: [{ title: 'Abstract Algebra', author: 'Dummit & Foote', note: 'Comprehensive' }],
                          prerequisites: ['linear-algebra-basic', 'proofs'], hopfRelevance: 'U(1) = S¬π acts on S¬≥' },
                        { id: 'smooth-manifolds', name: 'Smooth Manifolds', category: 'geometry', duration: '4-5 months',
                          equation: 'M locally ‚âÖ ‚Ñù‚Åø',
                          intuition: 'Shapes that look flat if you zoom in enough (like Earth), allowing us to do calculus on curved surfaces.',
                          topics: ['Charts & Atlases', 'Tangent Spaces', 'Smooth Maps', 'Spheres S‚Åø'],
                          books: [{ title: 'Introduction to Smooth Manifolds', author: 'Lee', note: 'Standard' }],
                          prerequisites: ['real-analysis', 'point-set-topology'], hopfRelevance: 'S¬π, S¬≤, S¬≥ are smooth manifolds' }
                    ]
                },
                {
                    id: 'phase2', name: 'Phase 2: Geometry & Topology', level: 2,
                    subjects: [
                        { id: 'algebraic-topology', name: 'Algebraic Topology', category: 'topology', duration: '4-5 months',
                          equation: 'œÄ‚ÇÅ(S¬π) ‚âÖ ‚Ñ§',
                          intuition: 'Counting holes in spaces using algebra. We turn geometric problems into group theory problems.',
                          topics: ['Fundamental Group', 'Homology', 'Higher Homotopy œÄ‚Çô', 'Long Exact Sequence'],
                          books: [{ title: 'Algebraic Topology', author: 'Hatcher', note: 'Free!' }],
                          prerequisites: ['point-set-topology', 'abstract-algebra'], hopfRelevance: 'œÄ‚ÇÉ(S¬≤) = ‚Ñ§ generated by Hopf!' },
                        { id: 'lie-groups', name: 'Lie Groups', category: 'algebra', duration: '3-4 months',
                          equation: 'exp: ùî§ ‚Üí G',
                          intuition: 'Continuous symmetry made precise. These groups smoothly rotate, scale, and transform space.',
                          topics: ['Matrix Lie Groups', 'U(1), SU(2), SO(3)', 'Homogeneous Spaces'],
                          books: [{ title: 'Lie Groups', author: 'Hall', note: 'Perfect' }],
                          prerequisites: ['abstract-algebra', 'smooth-manifolds'], hopfRelevance: 'S¬≥ = SU(2); Hopf = SU(2)/U(1)' },
                        { id: 'fiber-bundles', name: 'Fiber Bundles', category: 'geometry', duration: '4-5 months',
                          equation: 'F ‚Üí E ‚Üí B',
                          intuition: 'A space built by attaching fibers to every point of a base. Like how hair (fibers) grows from a scalp (base).',
                          topics: ['Vector Bundles', 'Principal Bundles', 'The Hopf Bundle'],
                          books: [{ title: 'Topology, Geometry, Gauge Fields', author: 'Naber', note: 'Explicit Hopf' }],
                          prerequisites: ['smooth-manifolds', 'lie-groups', 'algebraic-topology'], hopfRelevance: 'THE Hopf = principal U(1)-bundle' },
                        { id: 'riemannian-geometry', name: 'Riemannian Geometry', category: 'geometry', duration: '3-4 months',
                          equation: 'ds¬≤ = g·µ¢‚±ºdx‚Å±dx ≤',
                          intuition: 'How to measure distances and angles on curved surfaces. The geometry of General Relativity.',
                          topics: ['Metrics', 'Connections', 'Curvature', 'Geodesics'],
                          books: [{ title: 'Riemannian Manifolds', author: 'Lee', note: 'Continuation' }],
                          prerequisites: ['smooth-manifolds'], hopfRelevance: 'Round metric on S¬≥' }
                    ]
                },
                {
                    id: 'phase3', name: 'Phase 3: Deep Structure', level: 3,
                    subjects: [
                        { id: 'connections', name: 'Connections & Curvature', category: 'geometry', duration: '3 months',
                          equation: 'Œ© = dœâ + œâ ‚àß œâ',
                          intuition: 'How to parallel transport vectors along curves. The mathematical heart of gauge theory.',
                          topics: ['Ehresmann Connections', 'Curvature 2-form', 'Holonomy'],
                          books: [{ title: 'Geometry, Topology and Physics', author: 'Nakahara', note: 'Bridge' }],
                          prerequisites: ['fiber-bundles', 'riemannian-geometry'], hopfRelevance: 'Hopf has natural connection' },
                        { id: 'characteristic-classes', name: 'Characteristic Classes', category: 'topology', duration: '3 months',
                          equation: 'c‚ÇÅ(Hopf) = 1',
                          intuition: 'Topological fingerprints of bundles. They detect when a bundle is truly twisted.',
                          topics: ['Chern Classes', 'Classifying Spaces', 'c‚ÇÅ(Hopf) = 1'],
                          books: [{ title: 'Characteristic Classes', author: 'Milnor & Stasheff', note: 'Classic' }],
                          prerequisites: ['fiber-bundles', 'algebraic-topology'], hopfRelevance: 'c‚ÇÅ classifies U(1) bundles' },
                        { id: 'complex-geometry', name: 'Complex Projective Space', category: 'geometry', duration: '2-3 months',
                          equation: '‚ÑÇP¬π = S¬≤',
                          intuition: 'The space of all complex lines through the origin. S¬≤ is secretly a complex manifold.',
                          topics: ['CP‚Åø Construction', 'CP¬π = S¬≤', 'Tautological Bundle'],
                          books: [{ title: 'Complex Geometry', author: 'Huybrechts', note: 'Modern' }],
                          prerequisites: ['smooth-manifolds', 'algebraic-topology'], hopfRelevance: 'S¬≤ = CP¬π; Hopf = S¬≥ ‚Üí CP¬π' },
                        { id: 'quaternions', name: 'Quaternions', category: 'algebra', duration: '2 months',
                          equation: 'i¬≤ = j¬≤ = k¬≤ = ijk = -1',
                          intuition: '4D numbers that encode 3D rotations. The key to understanding S¬≥ geometrically.',
                          topics: ['Quaternion Algebra', 'Unit Quaternions = S¬≥', 'Rotations'],
                          books: [{ title: 'Visualizing Quaternions', author: 'Hanson', note: 'Visual' }],
                          prerequisites: ['lie-groups'], hopfRelevance: 'S¬≥ = unit quaternions' }
                    ]
                },
                {
                    id: 'phase4', name: 'Phase 4: Hopf Mastery', level: 4,
                    subjects: [
                        { id: 'hopf-fibration', name: 'The Hopf Fibration', category: 'topology', duration: '3-4 months',
                          equation: 'S¬π ‚Ü™ S¬≥ ‚Üí S¬≤',
                          intuition: 'The non-trivial way to wrap circles around a sphere. It connects 1D, 2D, and 3D spheres in a beautiful knot.',
                          topics: ['Multiple Constructions', 'Linking Numbers', 'Villarceau Circles', 'Stereographic Projection'],
                          books: [{ title: 'Topology and Geometry', author: 'Bredon', note: 'Good Hopf section' }],
                          prerequisites: ['fiber-bundles', 'characteristic-classes', 'quaternions'], hopfRelevance: 'THE GOAL: S¬π ‚Üí S¬≥ ‚Üí S¬≤' },
                        { id: 'applications', name: 'Physics Applications', category: 'physics', duration: '3 months',
                          equation: 'A = (1-cosŒ∏)dœÜ',
                          intuition: 'Where abstract geometry meets the real world: magnetic monopoles, quantum phases, and gauge fields.',
                          topics: ['Dirac Monopole', 'Berry Phase', 'Bloch Sphere', 'Gauge Theory'],
                          books: [{ title: 'Geometry, Topology and Physics', author: 'Nakahara', note: 'Applications' }],
                          prerequisites: ['hopf-fibration', 'connections'], hopfRelevance: 'Hopf = Dirac monopole bundle' },
                        { id: 'generalizations', name: 'Higher Hopf Fibrations', category: 'topology', duration: '2-3 months',
                          equation: 'S‚Å∑ ‚Üí S¬π‚Åµ ‚Üí S‚Å∏',
                          intuition: 'Only four division algebras exist (‚Ñù, ‚ÑÇ, ‚Ñç, ùïÜ), and each gives us a unique Hopf fibration.',
                          topics: ['S¬≥‚ÜíS‚Å∑‚ÜíS‚Å¥', 'S‚Å∑‚ÜíS¬π‚Åµ‚ÜíS‚Å∏', 'Division Algebras', 'Bott Periodicity'],
                          books: [{ title: 'Topology and Geometry', author: 'Bredon', note: 'Advanced' }],
                          prerequisites: ['hopf-fibration'], hopfRelevance: 'Only 4 Hopf fibrations exist' }
                    ]
                }
            ]
        };

        const startingConditions = {
            'high-school': { skipSubjects: [] },
            'undergrad-physics': { skipSubjects: ['calculus', 'linear-algebra-basic', 'proofs'] },
            'undergrad-math': { skipSubjects: ['calculus', 'linear-algebra-basic', 'proofs', 'real-analysis', 'abstract-algebra', 'point-set-topology'] },
            'grad-physics': { skipSubjects: ['calculus', 'linear-algebra-basic', 'proofs', 'complex-numbers', 'real-analysis'] },
            'grad-math': { skipSubjects: ['calculus', 'linear-algebra-basic', 'proofs', 'real-analysis', 'abstract-algebra', 'point-set-topology', 'smooth-manifolds', 'algebraic-topology'] }
        };

        const goals = {
            'hopf-basic': { targetPhase: 2, requiredSubjects: ['fiber-bundles', 'algebraic-topology'], description: 'Understand what Hopf is and why œÄ‚ÇÉ(S¬≤) = ‚Ñ§' },
            'hopf-construction': { targetPhase: 3, requiredSubjects: ['hopf-fibration', 'quaternions', 'complex-geometry'], description: 'Build the Hopf map from quaternions' },
            'hopf-deep': { targetPhase: 4, requiredSubjects: ['hopf-fibration', 'characteristic-classes', 'generalizations'], description: 'Full mastery including higher Hopf fibrations' },
            'physics-app': { targetPhase: 4, requiredSubjects: ['applications', 'connections'], description: 'Dirac monopole, Berry phase, gauge theory' }
        };

        // =====================================================
        // HOPF FIBRATION SHADERS
        // =====================================================
        
        const hopfVertexShader = `
            uniform float time;
            attribute float fiberIndex;
            attribute float tOffset;
            varying vec3 vColor;
            varying float vAlpha;
            
            vec3 palette(float t) {
                // Balanced brightness palette
                vec3 a = vec3(0.4, 0.4, 0.45);
                vec3 b = vec3(0.4, 0.4, 0.45);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263, 0.416, 0.557);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                float eta = fiberIndex * 3.14159;
                float xi1 = tOffset + time * 0.3;
                float xi2 = fiberIndex * 25.0;
                
                vec4 p = vec4(
                    cos(xi1 + xi2) * sin(eta),
                    sin(xi1 + xi2) * sin(eta),
                    cos(xi2) * cos(eta),
                    sin(xi2) * cos(eta)
                );

                // 4D rotation
                float rot = time * 0.15;
                float c1 = cos(rot);
                float s1 = sin(rot);
                vec4 pRot = vec4(
                    p.x * c1 - p.w * s1,
                    p.y,
                    p.z,
                    p.x * s1 + p.w * c1
                );

                // Stereographic projection
                float scale = 1.0 / (1.0 - pRot.w + 0.01);
                vec3 pos = pRot.xyz * scale * 1.8;

                vColor = palette(fiberIndex + time * 0.05);
                // Increased alpha range for better visibility
                vAlpha = 0.45 + 0.35 * sin(tOffset * 3.0 + time);
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = max(2.5, 10.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const hopfFragmentShader = `
            uniform float globalOpacity;
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;
                float alpha = (1.0 - smoothstep(0.1, 0.5, r)) * vAlpha * globalOpacity;
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        // =====================================================
        // LIVING SURFACE SHADERS (Animated energy nodes)
        // =====================================================
        
        const livingSurfaceVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldNormal;
            uniform float time;
            
            // Simplex noise function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) { 
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute(permute(permute( 
                          i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0)) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0) * 2.0 + 1.0;
                vec4 s1 = floor(b1) * 2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                
                // Displace vertex slightly based on noise for "breathing" effect
                float pulse = snoise(position * 2.0 + time * 0.5) * 0.03;
                vec3 newPos = position + normal * pulse;
                
                vPosition = newPos;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;

        const livingSurfaceFragmentShader = `
            uniform float time;
            uniform vec3 color;
            uniform float opacity;
            uniform float complexity;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldNormal;

            float random(in vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }

            float noise(in vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            float fbm(in vec2 st) {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 5; i++) {
                    value += amplitude * noise(st);
                    st *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            void main() {
                // Domain warping
                vec2 q = vec2(0.0);
                q.x = fbm(vUv * complexity + 0.00 * time);
                q.y = fbm(vUv * complexity + vec2(1.0));

                vec2 r = vec2(0.0);
                r.x = fbm(vUv * complexity + 1.0 * q + vec2(1.7, 9.2) + 0.15 * time);
                r.y = fbm(vUv * complexity + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time);

                float f = fbm(vUv * complexity + r);

                // --- VISIBILITY FIX START ---
                
                // 1. Darker base color to create contrast
                vec3 darkColor = color * 0.05; 
                
                // 2. Reduce the max brightness of the light parts (was 1.2)
                vec3 lightColor = color * 0.8; 
                
                // 3. Sharpen the pattern (contrast curve)
                f = smoothstep(0.1, 0.9, f);

                vec3 viewDir = normalize(cameraPosition - vPosition);
                float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 3.0);
                
                vec3 finalColor = mix(darkColor, lightColor, f);
                
                // 4. Reduce the pulse intensity (was 0.8)
                float energyPulse = abs(sin(time * 0.5 + f * 3.0));
                finalColor += color * f * f * 0.4 * energyPulse;
                
                // Keep fresnel strong for the "edge" definition
                finalColor += color * fresnel * 1.0;
                
                // --- VISIBILITY FIX END ---

                gl_FragColor = vec4(finalColor, opacity);
            }
        `;

        // =====================================================
        // NEURAL FLOW SHADERS (for animated connections)
        // =====================================================
        
        const flowVertexShader = `
            attribute float percent;
            uniform float time;
            uniform float baseOpacity;
            varying float vOpacity;
            
            void main() {
                // Create a moving wave that loops along the line
                float flow = fract(percent - time * 0.5);
                
                // Sharpen the wave to create a "pulse" packet
                float pulse = smoothstep(0.0, 0.1, flow) * (1.0 - smoothstep(0.1, 0.4, flow));
                
                // Base opacity + pulse brightness
                vOpacity = baseOpacity + pulse * 0.8;
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const flowFragmentShader = `
            uniform vec3 color;
            varying float vOpacity;
            
            void main() {
                gl_FragColor = vec4(color, vOpacity);
            }
        `;

        // =====================================================
        // NEBULA SHADERS (atmospheric background)
        // =====================================================
        
        const cloudVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const cloudFragmentShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;

            // Improved noise function for more organic look
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f); // Smoothstep
                
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 5; i++) {
                    value += amplitude * noise(p);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            void main() {
                vec2 uv = vUv;
                
                // Create swirling motion
                float n1 = fbm(uv * 3.0 + vec2(time * 0.02, time * 0.01));
                float n2 = fbm(uv * 2.0 - vec2(time * 0.015, time * 0.025));
                float n3 = fbm(uv * 4.0 + vec2(n1, n2) * 0.5);
                
                // Combine noise layers - use additive instead of multiplicative for brighter result
                float fog = (n1 + n2 + n3) / 3.0;
                fog = pow(fog, 1.2); // Softer contrast
                
                // Category-inspired colors - brighter for visibility
                vec3 analysisColor = vec3(0.08, 0.15, 0.35);   // Deep blue
                vec3 algebraColor = vec3(0.25, 0.08, 0.35);    // Purple
                vec3 topologyColor = vec3(0.03, 0.25, 0.18);   // Teal green
                vec3 geometryColor = vec3(0.3, 0.15, 0.05);    // Orange tint
                
                // Blend colors based on position and noise
                vec3 color1 = mix(analysisColor, algebraColor, n1);
                vec3 color2 = mix(topologyColor, geometryColor, n2);
                vec3 finalColor = mix(color1, color2, n3);
                
                // Add some bright spots (distant stars/energy)
                float sparkle = pow(noise(uv * 50.0 + time * 0.1), 8.0) * 0.4;
                finalColor += vec3(sparkle);
                
                // Softer vignette - keep more visible at edges
                float dist = distance(uv, vec2(0.5));
                float vignette = 1.0 - smoothstep(0.3, 0.8, dist);
                
                // Higher base alpha for visibility
                float alpha = fog * vignette * 0.5 + 0.05;
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // =====================================================
        // CINEMATIC LENS SHADER (Grain + Chromatic Aberration)
        // =====================================================
        
        const cinematicVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const cinematicFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform float time;
            varying vec2 vUv;

            // Random noise for film grain
            float random(vec2 p) {
                return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv;
                
                // 1. Chromatic Aberration (RGB Split)
                // Distance from center determines strength
                float dist = distance(uv, vec2(0.5));
                float offset = dist * 0.002; // Subtle split

                float r = texture2D(tDiffuse, uv + vec2(offset, 0.0)).r;
                float g = texture2D(tDiffuse, uv).g;
                float b = texture2D(tDiffuse, uv - vec2(offset, 0.0)).b;
                
                vec3 color = vec3(r, g, b);

                // 2. Film Grain - prevents gradient banding
                float noise = random(uv + mod(time, 10.0));
                color += (noise - 0.5) * 0.03; // Subtle grain

                // 3. Softer Vignette - preserve nebula visibility
                float vignette = 1.0 - smoothstep(0.5, 1.5, dist);
                color *= mix(0.92, 1.0, vignette);

                // 4. Slight contrast boost
                color = pow(color, vec3(1.03));

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // =====================================================
        // GLOBALS
        // =====================================================
        
        let scene, camera, renderer, controls, composer;
        let nodes = [];
        let connections = [];
        let nodeMap = new Map();
        let raycaster, mouse;
        let selectedNode = null;
        let hoveredNode = null;
        let highlightedNodes = new Set();
        let skippedNodes = new Set();
        let requiredNodes = new Set();
        let ancestorNodes = new Set();
        let ancestorConnections = new Set();
        
        let isPaused = false;
        let currentStart = 'undergrad-physics';
        let currentGoal = 'hopf-deep';
        
        let targetScales = new Map();
        let targetOpacities = new Map();
        
        // Camera fly-to
        let cameraTargetPosition = null;
        let cameraTargetLookAt = null;
        
        // Hopf visualization
        let hopfPoints = null;
        let hopfMaterial = null;
        
        // Floating symbols
        let floatingSymbols = [];
        let flowMaterials = []; // Track all flow materials for animation
        let livingMaterials = []; // Track living surface shader materials
        let nebulaMaterial = null; // Track nebula for animation
        let cinematicPass = null; // Track cinematic post-processing
        let bokehPass = null; // Depth of field
        let bloomPass = null; // Bloom effect (for resize handling)
        
        // Audio system
        let audioContext = null;
        let audioInitialized = false;
        let ambientOscillators = [];
        let ambientGain = null;
        let masterVolume = 0.3; // 0 to 1
        let isMuted = false;
        let effectsGain = null; // Separate gain for click/hover sounds
        
        // Category-specific audio characteristics
        const CATEGORY_AUDIO = {
            analysis: { type: 'sine', baseFreq: 220, chord: [1, 1.25, 1.5] },      // Smooth sine waves
            algebra: { type: 'square', baseFreq: 185, chord: [1, 1.2, 1.44] },     // Discrete square waves
            topology: { type: 'triangle', baseFreq: 165, chord: [1, 1.33, 1.67] }, // Shifting triangle
            geometry: { type: 'sine', baseFreq: 196, chord: [1, 1.26, 1.5] },      // Harmonious
            physics: { type: 'sawtooth', baseFreq: 147, chord: [1, 1.5, 2] },      // Rich harmonics
            foundations: { type: 'sine', baseFreq: 131, chord: [1, 1.19, 1.5] }    // Deep foundation
        };
        
        // Symbol definitions per node category/id
        const SYMBOL_DATA = {
            'calculus': ['‚à´', 'dx', '‚àÇ', '‚àû', 'lim'],
            'linear-algebra-basic': ['Œª', '‚äó', '‚àà', 'det', '‚Üí'],
            'complex-numbers': ['i', 'e^iŒ∏', '‚ÑÇ', 'zÃÑ', '|z|'],
            'proofs': ['‚àÄ', '‚àÉ', '‚áí', '‚àß', 'QED'],
            'real-analysis': ['Œµ', 'Œ¥', '‚àë', '‚àè', '‚Üí'],
            'point-set-topology': ['œÑ', '‚à™', '‚à©', '‚àÖ', '‚äÇ'],
            'abstract-algebra': ['‚äï', '√ó', 'ker', 'im', '‚âÖ'],
            'smooth-manifolds': ['‚àá', 'T*M', 'œâ', '‚àß', 'd'],
            'algebraic-topology': ['œÄ‚ÇÅ', 'H*', '‚âÉ', '‚àÇ', 'œá'],
            'lie-groups': ['ùî§', 'exp', 'Ad', 'SU', 'SO'],
            'fiber-bundles': ['E', 'œÄ', 'F', '√ó', '‚Üì'],
            'riemannian-geometry': ['g', 'Œì', 'R', '‚àá', 'Œ∫'],
            'connections': ['A', 'F', 'œâ', 'Œ©', '‚à•'],
            'characteristic-classes': ['c‚ÇÅ', 'ch', 'p', 'e', 'w'],
            'complex-geometry': ['CP', '‚Ñô', 'O(1)', 'Œ©', '‚àÇÃÑ'],
            'quaternions': ['‚Ñç', 'i', 'j', 'k', 'qÃÑ'],
            'hopf-fibration': ['S¬π', 'S¬≥', 'S¬≤', 'œÄ‚ÇÉ', 'Œ∑'],
            'applications': ['œà', '‚Ñè', '‚ü® ‚ü©', '√Ç', 'U(1)'],
            'generalizations': ['S‚Å∑', 'S¬π‚Åµ', 'ùïÜ', '‚ÑÇa', '‚Ñça']
        };
        
        // Category-specific geometries
        const CATEGORY_GEOMETRIES = {
            analysis: 'sphere',      // Smooth, continuous
            algebra: 'octahedron',   // Crystalline, discrete
            topology: 'torus',       // Elastic, deformable
            geometry: 'icosahedron', // Complex polyhedron
            physics: 'atom',         // Orbital structure
            foundations: 'cube'      // Building blocks
        };

        // =====================================================
        // INIT
        // =====================================================
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.025);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(14, 6, 16);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);
            
            // Post-processing with Bloom
            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,  // strength
                0.4,  // radius
                0.85  // threshold
            );
            bloomPass.threshold = 0.3;  // Fix: Raised threshold to prevent label washout and mid-tone glare
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.4;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            // Depth of Field (Bokeh) - subtle effect that intensifies when focused on a node
            bokehPass = new BokehPass(scene, camera, {
                focus: 20.0,
                aperture: 0.00003,
                maxblur: 0.005
            });
            bokehPass.enabled = false; // Start disabled, enable on node selection
            composer.addPass(bokehPass);
            
            // Cinematic lens effect (grain + chromatic aberration)
            cinematicPass = new ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: null },
                        time: { value: 0 }
                    },
                    vertexShader: cinematicVertexShader,
                    fragmentShader: cinematicFragmentShader
                })
            );
            composer.addPass(cinematicPass);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.2;
            controls.maxDistance = 40;
            controls.minDistance = 6;
            controls.maxPolarAngle = Math.PI * 0.85;
            
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.3; // Fix: Allow clicking point clouds
            mouse = new THREE.Vector2();
            
            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            const pointLight1 = new THREE.PointLight(0xffffff, 0.6, 100);
            pointLight1.position.set(10, 20, 10);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0x10b981, 0.3, 100);
            pointLight2.position.set(-10, -10, -10);
            scene.add(pointLight2);
            
            createStars();
            createNebula();
            createCentralAxis();
            createPhaseRings();
            createNodesAndConnections();
            createHopfVisualization();
            updatePathHighlighting();
            
            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            document.getElementById('start-select').addEventListener('change', (e) => {
                currentStart = e.target.value;
                updatePathHighlighting();
                updateTimeline();
                updateGoalDisplay();
            });
            
            document.getElementById('goal-select').addEventListener('change', (e) => {
                currentGoal = e.target.value;
                updatePathHighlighting();
                updateTimeline();
                updateGoalDisplay();
            });
            
            document.getElementById('panel-close').addEventListener('click', closeInfoPanel);
            document.getElementById('play-pause-btn').addEventListener('click', togglePause);
            
            // Volume controls
            document.getElementById('volume-slider').addEventListener('input', (e) => {
                initAudio(); // Initialize audio on first interaction
                setVolume(e.target.value / 100);
            });
            
            document.getElementById('volume-btn').addEventListener('click', () => {
                initAudio(); // Initialize audio on first interaction
                toggleMute();
            });
            
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
            
            updateTimeline();
            updateGoalDisplay();
            animate();
        }

        function togglePause() {
            isPaused = !isPaused;
            if (!selectedNode) controls.autoRotate = !isPaused;
            
            document.getElementById('icon-pause').style.display = isPaused ? 'none' : 'block';
            document.getElementById('icon-play').style.display = isPaused ? 'block' : 'none';
        }

        // =====================================================
        // GENERATIVE AUDIO SYSTEM
        // =====================================================
        
        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master gain for ambient sounds
                ambientGain = audioContext.createGain();
                ambientGain.gain.value = 0;
                ambientGain.connect(audioContext.destination);
                
                // Separate gain for effects (clicks/hovers)
                effectsGain = audioContext.createGain();
                effectsGain.gain.value = masterVolume;
                effectsGain.connect(audioContext.destination);
                
                // Create ambient drone oscillators
                const droneFreqs = [55, 82.5, 110]; // A1, E2, A2 - deep space drone
                droneFreqs.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.value = 0.08 - i * 0.02; // Decreasing volume for higher freqs
                    
                    // Add subtle LFO modulation for organic feel
                    const lfo = audioContext.createOscillator();
                    const lfoGain = audioContext.createGain();
                    lfo.type = 'sine';
                    lfo.frequency.value = 0.1 + i * 0.05; // Slow modulation
                    lfoGain.gain.value = 2; // Subtle pitch variation
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    
                    osc.connect(gain);
                    gain.connect(ambientGain);
                    
                    osc.start();
                    lfo.start();
                    
                    ambientOscillators.push({ osc, gain, lfo });
                });
                
                // Fade in ambient using masterVolume
                ambientGain.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 3);
                
                audioInitialized = true;
                updateVolumeUI();
            } catch (e) {
                console.log('Audio not supported:', e);
            }
        }
        
        function setVolume(value) {
            masterVolume = value;
            if (ambientGain) {
                ambientGain.gain.setTargetAtTime(isMuted ? 0 : masterVolume, audioContext.currentTime, 0.1);
            }
            if (effectsGain) {
                effectsGain.gain.setTargetAtTime(isMuted ? 0 : masterVolume, audioContext.currentTime, 0.1);
            }
            updateVolumeUI();
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            if (ambientGain) {
                ambientGain.gain.setTargetAtTime(isMuted ? 0 : masterVolume, audioContext.currentTime, 0.1);
            }
            if (effectsGain) {
                effectsGain.gain.setTargetAtTime(isMuted ? 0 : masterVolume, audioContext.currentTime, 0.1);
            }
            updateVolumeUI();
        }
        
        function updateVolumeUI() {
            const volumeBtn = document.getElementById('volume-btn');
            const iconOn = document.getElementById('icon-volume-on');
            const iconOff = document.getElementById('icon-volume-off');
            
            if (isMuted || masterVolume === 0) {
                iconOn.style.display = 'none';
                iconOff.style.display = 'block';
                volumeBtn.classList.remove('active');
            } else {
                iconOn.style.display = 'block';
                iconOff.style.display = 'none';
                volumeBtn.classList.add('active');
            }
        }
        
        function playNodeSound(category) {
            if (!audioInitialized || !audioContext || isMuted) return;
            
            const audioConfig = CATEGORY_AUDIO[category] || CATEGORY_AUDIO.foundations;
            
            // Create a chord of oscillators
            audioConfig.chord.forEach((multiplier, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = audioConfig.type;
                osc.frequency.value = audioConfig.baseFreq * multiplier;
                
                // Warm low-pass filter
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;
                
                // ADSR-like envelope
                const now = audioContext.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15 - i * 0.03, now + 0.05); // Attack
                gain.gain.exponentialRampToValueAtTime(0.08, now + 0.2); // Decay
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5); // Release
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(effectsGain); // Route through effects gain for volume control
                
                osc.start(now);
                osc.stop(now + 1.5);
            });
        }
        
        function playHoverSound(category) {
            if (!audioInitialized || !audioContext || isMuted) return;
            
            const audioConfig = CATEGORY_AUDIO[category] || CATEGORY_AUDIO.foundations;
            
            // Subtle high-pitched ping
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = audioConfig.baseFreq * 4; // Higher octave
            
            const now = audioContext.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.03, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            osc.connect(gain);
            gain.connect(effectsGain); // Route through effects gain for volume control
            
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            for (let i = 0; i < 3000; i++) {
                starsVertices.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.5 });
            scene.add(new THREE.Points(starsGeometry, starsMaterial));
        }

        function createNebula() {
            // Create a large sphere surrounding the scene with animated nebula shader
            const sphereGeo = new THREE.SphereGeometry(55, 64, 64);
            
            nebulaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: cloudVertexShader,
                fragmentShader: cloudFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide // Render inside of sphere
            });

            const nebulaSphere = new THREE.Mesh(sphereGeo, nebulaMaterial);
            nebulaSphere.userData = { isNebula: true };
            
            // Add a second, smaller nebula layer for depth
            const innerSphereGeo = new THREE.SphereGeometry(35, 48, 48);
            const innerNebulaMaterial = nebulaMaterial.clone();
            innerNebulaMaterial.uniforms = { time: { value: 0 } }; // Independent time
            
            const innerNebula = new THREE.Mesh(innerSphereGeo, innerNebulaMaterial);
            innerNebula.userData = { isNebula: true, isInnerNebula: true };
            
            scene.add(nebulaSphere);
            scene.add(innerNebula);
        }

        function createCentralAxis() {
            const geometry = new THREE.CylinderGeometry(0.01, 0.01, 28, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.03 });
            const axis = new THREE.Mesh(geometry, material);
            axis.position.y = 4;
            scene.add(axis);
        }

        function createPhaseRings() {
            curriculumData.phases.forEach((phase, i) => {
                const y = (i * 3.5) - 6;
                const ringGeometry = new THREE.RingGeometry(5.5, 5.55, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.02, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = y;
                scene.add(ring);
            });
        }

        function createNodesAndConnections() {
            const radius = 4.5;
            const verticalGap = 3.5;
            
            // Create nodes
            curriculumData.phases.forEach((phase, phaseIdx) => {
                const subjects = phase.subjects;
                const anglePerNode = (Math.PI * 2) / Math.max(subjects.length, 3);
                
                subjects.forEach((subject, subIdx) => {
                    const angle = subIdx * anglePerNode + (phaseIdx * 0.5);
                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    const y = (phaseIdx * verticalGap) - 6;
                    
                    const nodeData = {
                        ...subject,
                        phaseName: phase.name,
                        phaseLevel: phase.level,
                        position: new THREE.Vector3(x, y, z),
                        baseY: y
                    };
                    
                    // Skip creating mesh for hopf-fibration (will use shader)
                    if (subject.id === 'hopf-fibration') {
                        nodeMap.set(subject.id, { mesh: null, data: nodeData, isHopfNode: true });
                        return;
                    }
                    
                    // Create category-specific geometry
                    const geometry = createCategoryGeometry(subject.category);
                    
                    // Reduce brightness for specific nodes that appear too bright
                    const brightNodes = ['characteristic-classes', 'generalizations'];
                    const isBrightNode = brightNodes.includes(subject.id);
                    
                    // Determine shader complexity based on category
                    let complexityVal = 3.0;
                    if (subject.category === 'analysis') complexityVal = 2.0;   // Flowing, smooth
                    if (subject.category === 'algebra') complexityVal = 6.0;    // Dense, crystalline
                    if (subject.category === 'topology') complexityVal = 1.5;   // Smooth, stretchy
                    if (subject.category === 'geometry') complexityVal = 4.0;   // Balanced
                    if (subject.category === 'physics') complexityVal = 3.5;    // Dynamic
                    if (subject.category === 'foundations') complexityVal = 2.5; // Stable
                    
                    // Living Surface Shader Material - animated energy effect
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color: { value: new THREE.Color(CATEGORY_COLORS[subject.category]) },
                            opacity: { value: isBrightNode ? 0.75 : 0.85 },
                            complexity: { value: complexityVal }
                        },
                        vertexShader: livingSurfaceVertexShader,
                        fragmentShader: livingSurfaceFragmentShader,
                        transparent: true,
                        // CHANGED: Use NormalBlending to prevent "whiteout"
                        blending: THREE.NormalBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });
                    
                    // Track material for animation updates
                    livingMaterials.push(material);
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    mesh.userData = nodeData;
                    mesh.userData.isLivingNode = true; // Mark for special opacity handling
                    
                    // Wireframe Shell - holographic technical effect
                    const wireGeo = new THREE.WireframeGeometry(geometry);
                    const wireMat = new THREE.LineBasicMaterial({
                        color: CATEGORY_COLORS[subject.category],
                        transparent: true,
                        opacity: isBrightNode ? 0.3 : 0.2,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    const wireframe = new THREE.LineSegments(wireGeo, wireMat);
                    // Scale up slightly so it floats outside the solid mesh
                    const wireScale = subject.category === 'physics' ? 1.5 : 1.2;
                    wireframe.scale.setScalar(wireScale);
                    wireframe.userData = { isWireframeShell: true };
                    mesh.add(wireframe);
                    
                    // Add orbital rings for physics nodes
                    if (subject.category === 'physics') {
                        addOrbitalRings(mesh, CATEGORY_COLORS[subject.category]);
                    }
                    
                    // Glow
                    const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: CATEGORY_COLORS[subject.category],
                        transparent: true,
                        opacity: isBrightNode ? 0.04 : 0.08,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    mesh.add(new THREE.Mesh(glowGeometry, glowMaterial));
                    
                    scene.add(mesh);
                    nodes.push(mesh);
                    nodeMap.set(subject.id, { mesh, data: nodeData });
                    targetScales.set(mesh, 1.0);
                    targetOpacities.set(mesh, 1.0);
                    
                    // Create floating symbols for this node
                    createFloatingSymbols(subject.id, new THREE.Vector3(x, y, z));
                });
            });
            
            // Create curved connections with neural flow
            nodeMap.forEach((nodeInfo, nodeId) => {
                const prereqs = nodeInfo.data.prerequisites || [];
                prereqs.forEach(prereqId => {
                    if (nodeMap.has(prereqId)) {
                        const startInfo = nodeMap.get(prereqId);
                        const endInfo = nodeInfo;
                        
                        const startPos = startInfo.data.position;
                        const endPos = endInfo.data.position;
                        
                        // Create curved path with control point
                        const midPoint = new THREE.Vector3(
                            (startPos.x + endPos.x) / 2 + (Math.random() - 0.5) * 1.5,
                            (startPos.y + endPos.y) / 2,
                            (startPos.z + endPos.z) / 2 + (Math.random() - 0.5) * 1.5
                        );
                        
                        const curve = new THREE.CatmullRomCurve3([startPos, midPoint, endPos]);
                        const points = curve.getPoints(40); // Higher resolution for smooth flow
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        
                        // Add percent attribute for flow animation
                        const percents = new Float32Array(points.length);
                        for (let i = 0; i < points.length; i++) {
                            percents[i] = i / (points.length - 1);
                        }
                        lineGeometry.setAttribute('percent', new THREE.BufferAttribute(percents, 1));
                        
                        // Neural flow shader material
                        const flowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                time: { value: 0 },
                                color: { value: new THREE.Color(CATEGORY_COLORS[endInfo.data.category]) },
                                baseOpacity: { value: 0.08 }
                            },
                            vertexShader: flowVertexShader,
                            fragmentShader: flowFragmentShader,
                            transparent: true,
                            depthWrite: false,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const line = new THREE.Line(lineGeometry, flowMaterial);
                        line.userData = { from: prereqId, to: nodeId };
                        scene.add(line);
                        connections.push(line);
                        flowMaterials.push(flowMaterial); // Track for animation
                    }
                });
            });
        }
        
        // Create geometry based on category
        // =====================================================
        // MATH SURFACES ENGINE (Parametric Geometry)
        // =====================================================

        function createCategoryGeometry(category) {
            try {
                switch(category) {
                    case 'topology':
                    case 'algebraic-topology':
                        // THE KLEIN BOTTLE
                        // A non-orientable surface (manifold).
                        return createParametricGeometry((u, v, target) => {
                            u *= Math.PI;
                            v *= 2 * Math.PI;
                            u = u * 2;
                            
                            let x, y, z;
                            if (u < Math.PI) {
                                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
                                z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                            } else {
                                x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
                                z = -8 * Math.sin(u);
                            }
                            y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
                            
                            // Scale down to fit node size (approx 0.3 radius)
                            const scale = 0.035;
                            target.set(x * scale, y * scale, z * scale);
                        }, 50, 50);

                    case 'analysis':
                    case 'complex-numbers':
                        // SEASHELL / HELICOID-INSPIRED SURFACE
                        // Represents spiraling complexity in analysis
                        return createParametricGeometry((u, v, target) => {
                            u = u * 4 * Math.PI; // 0 to 4pi
                            v = v * Math.PI;     // 0 to pi
                            
                            const a = 0.2;
                            const b = 0.8;
                            const c = 0.08;
                            
                            const x = (a + b * Math.cos(v)) * Math.cos(u);
                            const y = (a + b * Math.cos(v)) * Math.sin(u);
                            const z = c * u + b * Math.sin(v);
                            
                            const scale = 0.1;
                            // Center the spiral
                            target.set(x * scale, (z - 0.5) * scale, y * scale); 
                        }, 60, 30);

                    case 'algebra':
                    case 'lie-groups':
                        // ROMAN SURFACE (Steiner Surface)
                        // A realization of the Real Projective Plane.
                        return createParametricGeometry((u, v, target) => {
                            u *= Math.PI; 
                            v *= Math.PI;
                            
                            const r = 0.5;
                            const x = r * Math.sin(2 * u) * Math.cos(v) * Math.cos(v);
                            const y = r * Math.sin(u) * Math.sin(2 * v);
                            const z = r * Math.cos(2 * u) * Math.cos(v) * Math.cos(v);
                            
                            const scale = 0.8;
                            target.set(x * scale, y * scale, z * scale);
                        }, 40, 40);

                    case 'physics':
                    case 'applications':
                        // ORBITAL MANIFOLD (Modified Torus Knot)
                        // Represents phase space trajectories and string loops.
                        return new THREE.TorusKnotGeometry(0.18, 0.05, 100, 16, 2, 3);

                    case 'geometry':
                    case 'smooth-manifolds':
                        // MOBIUS STRIP
                        // Classic non-orientable surface for geometry
                        return createParametricGeometry((u, v, target) => {
                            u = u * 2 * Math.PI;
                            v = v * 2 - 1; // -1 to 1
                            
                            const x = (1 + 0.5 * v * Math.cos(u / 2)) * Math.cos(u);
                            const y = (1 + 0.5 * v * Math.cos(u / 2)) * Math.sin(u);
                            const z = 0.5 * v * Math.sin(u / 2);
                            
                            const scale = 0.25;
                            target.set(x * scale, z * scale, y * scale);
                        }, 50, 10);
                        
                    case 'foundations':
                        // SPHERE (Simple but fundamental)
                        return new THREE.SphereGeometry(0.28, 32, 32);

                    default:
                        // TREFOIL KNOT - using built-in TorusKnotGeometry for reliability
                        return new THREE.TorusKnotGeometry(0.15, 0.05, 80, 16, 2, 3);
                }
            } catch (e) {
                console.warn('Category geometry creation failed for', category, ':', e);
                // Fallback to simple icosahedron
                return new THREE.IcosahedronGeometry(0.3, 1);
            }
        }
        
        // Add orbital rings for physics nodes
        function addOrbitalRings(mesh, color) {
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            // Create 3 orbital rings at different angles
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.35, 0.015, 8, 32),
                    ringMaterial.clone()
                );
                ring.rotation.x = Math.PI / 2 + (i * Math.PI / 3);
                ring.rotation.y = i * Math.PI / 4;
                ring.userData.isOrbitalRing = true;
                ring.userData.orbitSpeed = 0.5 + i * 0.3;
                ring.userData.orbitAxis = i;
                mesh.add(ring);
            }
        }
        
        // Create floating mathematical symbols around a node
        function createFloatingSymbols(nodeId, position) {
            const symbols = SYMBOL_DATA[nodeId];
            if (!symbols) return;
            
            // Only create 2-3 symbols per node to avoid clutter
            const symbolCount = Math.min(3, symbols.length);
            
            for (let i = 0; i < symbolCount; i++) {
                const symbol = symbols[i];
                const sprite = createTextSprite(symbol, nodeId);
                
                // Position in a small cloud around the node
                const angle = (i / symbolCount) * Math.PI * 2 + Math.random() * 0.5;
                const dist = 0.8 + Math.random() * 0.5;
                const height = (Math.random() - 0.5) * 0.8;
                
                sprite.position.set(
                    position.x + Math.cos(angle) * dist,
                    position.y + height,
                    position.z + Math.sin(angle) * dist
                );
                
                sprite.userData = {
                    basePosition: sprite.position.clone(),
                    driftOffset: Math.random() * Math.PI * 2,
                    driftSpeed: 0.3 + Math.random() * 0.3,
                    fadeOffset: Math.random() * Math.PI * 2,
                    parentNodeId: nodeId
                };
                
                scene.add(sprite);
                floatingSymbols.push(sprite);
            }
        }
        
        // Create a text sprite that billboards to face camera
        function createTextSprite(text, nodeId) {
            const canvas = document.createElement('canvas');
            const size = 128;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Get category color for this node
            const nodeInfo = nodeMap.get(nodeId);
            const category = nodeInfo ? nodeInfo.data.category : 'topology';
            const color = CATEGORY_HEX[category] || '#10b981';
            
            // Draw text
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, size, size);
            
            ctx.font = 'bold 48px "Times New Roman", serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.fillText(text, size/2, size/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.4, 0.4, 1);
            
            return sprite;
        }

        function createHopfVisualization() {
            // Create the living Hopf fibration at the hopf-fibration node position
            const hopfNodeInfo = nodeMap.get('hopf-fibration');
            if (!hopfNodeInfo) return;
            
            const PARTICLE_COUNT = 12000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const fiberIndices = new Float32Array(PARTICLE_COUNT);
            const tOffsets = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const fiberId = Math.floor(i / 40);
                const fiberNorm = fiberId / 300;
                const t = (i % 40) / 40 * Math.PI * 2;
                
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                fiberIndices[i] = fiberNorm;
                tOffsets[i] = t;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('fiberIndex', new THREE.BufferAttribute(fiberIndices, 1));
            geometry.setAttribute('tOffset', new THREE.BufferAttribute(tOffsets, 1));

            hopfMaterial = new THREE.ShaderMaterial({
                vertexShader: hopfVertexShader,
                fragmentShader: hopfFragmentShader,
                uniforms: { 
                    time: { value: 0 },
                    globalOpacity: { value: 1.0 } // Fix: Add global opacity uniform
                },
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            hopfPoints = new THREE.Points(geometry, hopfMaterial);
            hopfPoints.scale.setScalar(0.35);
            hopfPoints.position.copy(hopfNodeInfo.data.position);
            hopfPoints.userData = { ...hopfNodeInfo.data, isHopfNode: true }; // Fix: Mark as Hopf node
            scene.add(hopfPoints);
            
            // Store reference
            hopfNodeInfo.mesh = hopfPoints;
            hopfNodeInfo.isShaderNode = true;
            nodes.push(hopfPoints);
            targetScales.set(hopfPoints, 0.35);
            targetOpacities.set(hopfPoints, 1.0);
        }

        // =====================================================
        // ANCESTOR / LINEAGE FUNCTIONS
        // =====================================================
        
        function getAncestors(nodeId, visited = new Set()) {
            if (visited.has(nodeId)) return visited;
            visited.add(nodeId);
            
            const nodeInfo = nodeMap.get(nodeId);
            if (!nodeInfo) return visited;
            
            const prereqs = nodeInfo.data.prerequisites || [];
            prereqs.forEach(prereqId => {
                getAncestors(prereqId, visited);
            });
            
            return visited;
        }
        
        function getLineagePath(nodeId) {
            const ancestors = getAncestors(nodeId);
            const nodeInfo = nodeMap.get(nodeId);
            if (!nodeInfo) return [];
            
            // Build ordered path
            const phases = [];
            curriculumData.phases.forEach(phase => {
                phase.subjects.forEach(subject => {
                    if (ancestors.has(subject.id)) {
                        phases.push(subject.name);
                    }
                });
            });
            
            return phases;
        }

        // =====================================================
        // PATH HIGHLIGHTING
        // =====================================================
        
        function updatePathHighlighting() {
            const startConfig = startingConditions[currentStart];
            const goalConfig = goals[currentGoal];
            
            skippedNodes = new Set(startConfig.skipSubjects);
            requiredNodes = new Set(goalConfig.requiredSubjects);
            highlightedNodes = new Set();
            
            curriculumData.phases.forEach(phase => {
                if (phase.level <= goalConfig.targetPhase) {
                    phase.subjects.forEach(subject => {
                        if (!skippedNodes.has(subject.id)) {
                            highlightedNodes.add(subject.id);
                        }
                    });
                }
            });
            
            // Update visuals
            nodes.forEach(nodeMesh => {
                const nodeId = nodeMesh.userData.id;
                const isSkipped = skippedNodes.has(nodeId);
                const isRequired = requiredNodes.has(nodeId);
                const isHighlighted = highlightedNodes.has(nodeId);
                const isHopf = nodeId === 'hopf-fibration';
                const isLiving = nodeMesh.userData.isLivingNode;
                
                let baseScale = isHopf ? 0.35 : 1.0;
                
                if (isSkipped) {
                    // Only set emissiveIntensity for non-shader materials
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 0.02;
                    }
                    targetScales.set(nodeMesh, baseScale * 0.5);
                    targetOpacities.set(nodeMesh, 0.3);
                } else if (isRequired) {
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 2.0;
                    }
                    targetScales.set(nodeMesh, baseScale * 1.4);
                    targetOpacities.set(nodeMesh, 1.0);
                } else if (isHighlighted) {
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 0.5;
                    }
                    targetScales.set(nodeMesh, baseScale);
                    targetOpacities.set(nodeMesh, 1.0);
                } else {
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 0.1;
                    }
                    targetScales.set(nodeMesh, baseScale * 0.7);
                    targetOpacities.set(nodeMesh, 0.5);
                }
            });
            
            connections.forEach(line => {
                const fromOk = highlightedNodes.has(line.userData.from) && !skippedNodes.has(line.userData.from);
                const toOk = highlightedNodes.has(line.userData.to) && !skippedNodes.has(line.userData.to);
                const opacity = (fromOk && toOk) ? 0.15 : 0.02;
                // Support both shader materials and basic materials
                if (line.material.uniforms && line.material.uniforms.baseOpacity) {
                    line.material.uniforms.baseOpacity.value = opacity;
                } else {
                    line.material.opacity = opacity;
                }
            });
        }
        
        function highlightLineage(nodeId) {
            ancestorNodes = getAncestors(nodeId);
            
            // Dim all, then highlight lineage
            nodes.forEach(nodeMesh => {
                const id = nodeMesh.userData.id;
                const isInLineage = ancestorNodes.has(id);
                const isHopf = id === 'hopf-fibration';
                const isLiving = nodeMesh.userData.isLivingNode;
                
                if (isInLineage) {
                    targetOpacities.set(nodeMesh, 1.0);
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 1.2;
                    }
                } else {
                    targetOpacities.set(nodeMesh, 0.15);
                    if (!isHopf && !isLiving && nodeMesh.material && nodeMesh.material.emissiveIntensity !== undefined) {
                        nodeMesh.material.emissiveIntensity = 0.05;
                    }
                }
            });
            
            // Highlight lineage connections
            connections.forEach(line => {
                const fromIn = ancestorNodes.has(line.userData.from);
                const toIn = ancestorNodes.has(line.userData.to);
                const opacity = (fromIn && toIn) ? 0.5 : 0.02;
                // Support both shader materials and basic materials
                if (line.material.uniforms && line.material.uniforms.baseOpacity) {
                    line.material.uniforms.baseOpacity.value = opacity;
                } else {
                    line.material.opacity = opacity;
                }
            });
        }
        
        function clearLineageHighlight() {
            ancestorNodes.clear();
            updatePathHighlighting();
        }

        // =====================================================
        // TIMELINE & GOAL
        // =====================================================
        
        function updateTimeline() {
            const startConfig = startingConditions[currentStart];
            const goalConfig = goals[currentGoal];
            const skipped = new Set(startConfig.skipSubjects);
            
            let totalMonths = 0;
            let subjectCount = 0;
            
            curriculumData.phases.forEach(phase => {
                if (phase.level <= goalConfig.targetPhase) {
                    phase.subjects.forEach(subject => {
                        if (!skipped.has(subject.id)) {
                            const duration = subject.duration || '3 months';
                            const months = parseInt(duration.match(/\d+/)?.[0]) || 3;
                            totalMonths += months;
                            subjectCount++;
                        }
                    });
                }
            });
            
            const years = Math.floor(totalMonths / 12);
            const months = totalMonths % 12;
            let timeStr = years > 0 ? `${years}y` : '';
            if (years > 0 && months > 0) timeStr += ' ';
            if (months > 0) timeStr += `${months}mo`;
            if (totalMonths === 0) timeStr = 'Ready!';
            
            document.getElementById('timeline-time').textContent = timeStr;
            document.getElementById('timeline-subjects').textContent = `${subjectCount} subjects`;
        }
        
        function updateGoalDisplay() {
            const goalConfig = goals[currentGoal];
            const goalNames = {
                'hopf-basic': 'Hopf Basics',
                'hopf-construction': 'Hopf Construction',
                'hopf-deep': 'Deep Understanding',
                'physics-app': 'Physics Applications'
            };
            document.getElementById('goal-name').textContent = goalNames[currentGoal];
            document.getElementById('goal-desc').textContent = goalConfig.description;
        }

        // =====================================================
        // INTERACTION
        // =====================================================
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update bloom pass resolution to maintain visual quality
            if (bloomPass) {
                bloomPass.resolution.set(window.innerWidth, window.innerHeight);
            }
        }

        // Helper to find the actual node (handles clicking on nested children like glow meshes)
        function getActualNode(object) {
            let current = object;
            while (current) {
                if (current.userData && current.userData.id) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes, true); // true = recursive to hit children
            
            const tooltip = document.getElementById('hover-tooltip');
            
            // Find the valid node from intersection
            let target = null;
            if (intersects.length > 0) {
                target = getActualNode(intersects[0].object);
            }

            if (hoveredNode && (!target || target !== hoveredNode)) {
                tooltip.style.opacity = 0;
                hoveredNode = null;
                renderer.domElement.style.cursor = 'default';
                stopTooltipViz();
            }
            
            if (target) {
                if (hoveredNode !== target) {
                    hoveredNode = target;
                    
                    // Play subtle hover sound
                    if (audioInitialized) {
                        playHoverSound(hoveredNode.userData.category);
                    }
                    
                    document.getElementById('tooltip-name').textContent = hoveredNode.userData.name;
                    const catEl = document.getElementById('tooltip-category');
                    catEl.textContent = hoveredNode.userData.category;
                    catEl.style.color = CATEGORY_HEX[hoveredNode.userData.category];
                    
                    const status = skippedNodes.has(hoveredNode.userData.id) ? '‚úì Done' :
                                   requiredNodes.has(hoveredNode.userData.id) ? '‚òÖ Key' :
                                   highlightedNodes.has(hoveredNode.userData.id) ? '‚óè Path' : '';
                    document.getElementById('tooltip-status').textContent = status;
                    
                    tooltip.style.opacity = 1;
                    renderer.domElement.style.cursor = 'pointer';
                    
                    startTooltipViz(hoveredNode.userData.category, hoveredNode.userData.id);
                }
                
                // Position tooltip using World Position for accuracy with children
                const vector = new THREE.Vector3();
                hoveredNode.getWorldPosition(vector);
                vector.project(camera);
                tooltip.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                tooltip.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            }
        }

        function onMouseClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes, true);
            
            if (intersects.length > 0) {
                const target = getActualNode(intersects[0].object);
                if (target) {
                    selectNode(target);
                }
            }
        }

        function selectNode(nodeMesh) {
            if (selectedNode && selectedNode !== nodeMesh) {
                clearLineageHighlight();
            }
            
            selectedNode = nodeMesh;
            controls.autoRotate = false;
            
            // Initialize audio on first interaction (browser requirement)
            initAudio();
            
            // Play category-specific sound
            playNodeSound(selectedNode.userData.category);
            
            // Highlight lineage
            highlightLineage(selectedNode.userData.id);
            
            // Camera fly-to
            // Fix: Use World Position to handle nested objects correctly
            const nodePos = new THREE.Vector3();
            selectedNode.getWorldPosition(nodePos);
            
            const direction = camera.position.clone().sub(nodePos).normalize();
            cameraTargetPosition = nodePos.clone().add(direction.multiplyScalar(10));
            cameraTargetPosition.y += 2;
            cameraTargetLookAt = nodePos.clone();
            
            // Enable and configure depth of field
            if (bokehPass) {
                bokehPass.enabled = true;
                // Calculate focus distance to selected node
                const focusDist = camera.position.distanceTo(nodePos);
                bokehPass.uniforms['focus'].value = focusDist;
                bokehPass.uniforms['aperture'].value = 0.00008;
                bokehPass.uniforms['maxblur'].value = 0.008;
            }
            
            showInfoPanel(selectedNode.userData);
        }

        function showInfoPanel(data) {
            const panel = document.getElementById('info-panel');
            const color = CATEGORY_HEX[data.category];
            
            document.getElementById('panel-category').textContent = data.category;
            document.getElementById('panel-category').style.backgroundColor = color + '22';
            document.getElementById('panel-category').style.color = color;
            
            const status = skippedNodes.has(data.id) ? '<span class="status-badge completed">‚úì Done</span>' :
                           requiredNodes.has(data.id) ? '<span class="status-badge required">‚òÖ Key</span>' :
                           highlightedNodes.has(data.id) ? '<span class="status-badge on-path">‚óè Path</span>' : '';
            document.getElementById('panel-title').innerHTML = data.name + status;
            
            // Phase info
            document.getElementById('panel-phase').innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                </svg>
                <span>${data.phaseName} ‚Ä¢ ${data.duration || '3-4 months'}</span>
            `;

            // NEW: Equation and Intuition
            const equationEl = document.getElementById('panel-equation');
            if (data.equation) {
                equationEl.style.display = 'block';
                equationEl.textContent = data.equation;
                equationEl.style.color = color;
                equationEl.style.textShadow = `0 0 15px ${color}`;
            } else {
                equationEl.style.display = 'none';
            }

            const intuitionEl = document.getElementById('panel-intuition');
            const intuitionBox = document.getElementById('panel-intuition-box');
            if (data.intuition) {
                intuitionBox.style.display = 'block';
                intuitionBox.style.borderColor = color;
                intuitionBox.style.backgroundColor = color + '11'; // 11 = very transparent hex
                document.querySelector('.intuition-label').style.color = color;
                intuitionEl.textContent = data.intuition;
            } else {
                intuitionBox.style.display = 'none';
            }
            
            // NEW: Start Sidebar Animation
            startMiniViz(data.category, data.id);

            // Existing List Logic
            document.getElementById('panel-topics').innerHTML = data.topics.map(t => `<li>${t}</li>`).join('');
            
            document.getElementById('panel-books').innerHTML = data.books.map(b => `
                <div class="info-panel-book">
                    <div class="info-panel-book-title">${typeof b === 'string' ? b : b.title}</div>
                    ${typeof b === 'object' && b.author ? `<div class="info-panel-book-note">by ${b.author}${b.note ? ' ‚Äî ' + b.note : ''}</div>` : ''}
                </div>
            `).join('');
            
            const prereqsSection = document.getElementById('panel-prereqs-section');
            if (data.prerequisites && data.prerequisites.length > 0) {
                prereqsSection.style.display = 'block';
                document.getElementById('panel-prereqs').innerHTML = data.prerequisites.map(p => `<span class="info-panel-prereq">${p}</span>`).join('');
            } else {
                prereqsSection.style.display = 'none';
            }
            
            const lineage = getLineagePath(data.id);
            document.getElementById('panel-lineage-text').textContent = lineage.join(' ‚Üí ');
            
            if (data.hopfRelevance) {
                document.getElementById('panel-relevance').style.display = 'block';
                document.getElementById('panel-relevance-text').textContent = data.hopfRelevance;
            } else {
                document.getElementById('panel-relevance').style.display = 'none';
            }
            
            panel.classList.add('open');
        }

        function closeInfoPanel() {
            document.getElementById('info-panel').classList.remove('open');
            
            // NEW: Stop sidebar animation and carousel timer
            if (miniVizRequestId) {
                cancelAnimationFrame(miniVizRequestId);
                miniVizRequestId = null;
            }
            if (vizAutoTimer) {
                clearInterval(vizAutoTimer);
                vizAutoTimer = null;
            }

            if (!isPaused) controls.autoRotate = true;
            
            // Disable depth of field when no node selected
            if (bokehPass) {
                bokehPass.enabled = false;
            }
            
            clearLineageHighlight();
            cameraTargetPosition = null;
            cameraTargetLookAt = null;
            selectedNode = null;
        }

        // =====================================================
        // SIDEBAR VISUALIZATION ENGINE (Multi-View Carousel)
        // =====================================================

        let miniVizRequestId = null;
        let miniVizCanvas = null;
        let miniVizCtx = null;
        let currentVizIndex = 0;
        let vizAutoTimer = null;
        let currentCategory = null;
        let currentNodeId = null;
        let vizGeneration = 0; // Generation counter to prevent stale renders
        
        // Visualization labels for each mode
        const VIZ_LABELS = ['Primary', 'Dynamics', 'Phase Space', 'Structure', 'Application'];
        
        // Node-specific visualization titles (PhD-level descriptions)
        const VIZ_TITLES = {
            // GEOMETRY
            'smooth-manifolds': ['Coordinate Charts', 'Tangent Bundle', 'Diffeomorphism', 'Orientability', 'Partition of Unity'],
            'riemannian-geometry': ['Metric Tensor', 'Geodesics', 'Parallel Transport', 'Curvature', 'Christoffel Symbols'],
            'fiber-bundles': ['Bundle Structure', 'M√∂bius Strip', 'Section', 'Local Triviality', 'Structure Group'],
            'connections': ['Covariant Derivative', 'Holonomy', 'Curvature 2-form', 'Horizontal Lift', 'Gauge Potential'],
            'complex-geometry': ['Riemann Sphere', 'M√∂bius Transform', 'Fubini-Study Metric', 'Tautological Bundle', 'Divisors'],

            // TOPOLOGY
            'point-set-topology': ['Open Sets', 'Continuity', 'Hausdorff Separation', 'Compactness', 'Connectedness'],
            'algebraic-topology': ['Fundamental Group œÄ‚ÇÅ', 'Homotopy', 'Simplicial Complex', 'Chain Complex', 'Cup Product'],
            'characteristic-classes': ['Hairy Ball Theorem', 'Chern Class', 'Stiefel-Whitney', 'Pontryagin Class', 'Euler Class'],
            'hopf-fibration': ['Villarceau Circles', 'S¬≥ ‚Üí S¬≤ Projection', 'Linking Number', 'Stereographic Proj', 'Torus Decomposition'],
            'generalizations': ['The Octonions', 'S¬π‚Åµ ‚Üí S‚Å∏ Fibration', 'Bott Periodicity', 'Exotic Spheres', 'Adams H-Spaces'],

            // ANALYSIS
            'calculus': ['Tangent Derivative', 'Riemann Integration', 'Squeeze Theorem', 'Taylor Series', 'Fundamental Theorem'],
            'complex-numbers': ['Argand Plane', 'Euler\'s Formula', 'Roots of Unity', 'Riemann Sphere', 'Holomorphic Functions'],
            'real-analysis': ['Epsilon-Delta', 'Cauchy Sequence', 'Bolzano-Weierstrass', 'Dedekind Cut', 'Lebesgue Measure'],

            // ALGEBRA
            'linear-algebra-basic': ['Vector Space', 'Eigenvalues', 'Determinant', 'Transformation', 'Dual Space'],
            'abstract-algebra': ['Permutation Cycles', 'Ring Operations', 'Homomorphism', 'Kernel Collapse', 'Coset Layers'],
            'lie-groups': ['Continuous Symmetry', 'Lie Algebra', 'Exponential Map', 'Commutator', 'SO(3) Rotation'],
            'quaternions': ['4D Hypersphere', 'Non-Commutativity', 'Sandwich Product', 'Pauli Matrices', 'Gimbal Lock'],

            // PHYSICS
            'applications': ['Dirac String', 'Berry Phase', 'Aharonov-Bohm', 'Bloch Sphere', 'Yang-Mills Gauge'],
            
            // FOUNDATIONS
            'proofs': ['Implication Chain', 'Truth Table', 'Induction', 'Quantifiers', 'Set Theory']
        };
        
        function initMiniViz() {
            miniVizCanvas = document.getElementById('mini-viz-canvas');
            // Support high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const rect = miniVizCanvas.getBoundingClientRect();
            miniVizCanvas.width = rect.width * dpr;
            miniVizCanvas.height = rect.height * dpr;
            miniVizCtx = miniVizCanvas.getContext('2d');
            miniVizCtx.scale(dpr, dpr);
            return { width: rect.width, height: rect.height };
        }
        
        // Setup carousel navigation
        function setupVizCarousel(category, nodeId) {
            const nav = document.getElementById('viz-nav');
            if (!nav) return;
            
            const dots = nav.querySelectorAll('.viz-nav-dot');
            const color = CATEGORY_HEX[category] || '#10b981';
            const label = document.getElementById('viz-label');
            const expectedGeneration = vizGeneration; // Capture current generation for this setup
            
            // Set CSS variable for dot color
            nav.style.setProperty('--viz-color', color);
            
            // Retrieve specific titles for this node, or fall back to generic labels
            const nodeTitles = VIZ_TITLES[nodeId] || VIZ_LABELS;
            
            // Update UI to match the current global state immediately
            dots.forEach((d, j) => d.classList.toggle('active', j === currentVizIndex));
            if (label) label.textContent = nodeTitles[currentVizIndex] || VIZ_LABELS[currentVizIndex];

            // Clear any existing timer to prevent "ghost" switching
            if (vizAutoTimer) {
                clearInterval(vizAutoTimer);
                vizAutoTimer = null;
            }
            
            // Helper to update carousel UI
            const updateCarouselUI = (index) => {
                const freshNav = document.getElementById('viz-nav');
                if (freshNav) {
                    freshNav.querySelectorAll('.viz-nav-dot').forEach((d, j) => d.classList.toggle('active', j === index));
                }
                const freshLabel = document.getElementById('viz-label');
                // Use the specific title from our dictionary
                if (freshLabel) freshLabel.textContent = nodeTitles[index] || VIZ_LABELS[index];
            };
            
            // Helper to start auto-cycle timer with proper closure
            const startAutoTimer = () => {
                // Defensive: clear any existing timer before starting a new one
                if (vizAutoTimer) {
                    clearInterval(vizAutoTimer);
                    vizAutoTimer = null;
                }
                
                const timerGeneration = vizGeneration; // Capture generation at timer start
                const timerId = setInterval(() => {
                    // Check if this timer is still valid
                    if (timerGeneration !== vizGeneration) {
                        clearInterval(timerId);
                        if (vizAutoTimer === timerId) vizAutoTimer = null;
                        return;
                    }
                    currentVizIndex = (currentVizIndex + 1) % 5; // Cycle through 5 modes (0-4)
                    updateCarouselUI(currentVizIndex);
                }, 8000);
                vizAutoTimer = timerId;
                return timerId;
            };
            
            // Create new click handlers for each dot
            dots.forEach((dot, i) => {
                // Replace the onclick handler (this removes any previous handler)
                dot.onclick = () => {
                    // Check generation at click time (not setup time) to handle rapid clicks
                    if (expectedGeneration !== vizGeneration) return;
                    
                    // Update global state
                    currentVizIndex = i;
                    
                    // Update UI immediately
                    updateCarouselUI(i);
                    
                    // Reset auto-timer on manual interaction
                    if (vizAutoTimer) {
                        clearInterval(vizAutoTimer);
                        vizAutoTimer = null;
                    }
                    startAutoTimer();
                };
            });
            
            // Start the auto-cycle timer
            startAutoTimer();
        }

        function startMiniViz(category, nodeId) {
            // 1. CLEANUP: Stop any running loops immediately
            if (miniVizRequestId) cancelAnimationFrame(miniVizRequestId);
            if (vizAutoTimer) clearInterval(vizAutoTimer);
            
            // 2. INCREMENT GENERATION to invalidate any stale loops
            vizGeneration++;
            const myGeneration = vizGeneration;
            
            // 3. RESET STATE: Ensure we start fresh for the new node
            currentVizIndex = 0;
            currentCategory = category;
            currentNodeId = nodeId;
            
            // 4. SETUP: Re-bind navigation and timers with node-specific titles
            setupVizCarousel(category, nodeId);
            
            const { width, height } = initMiniViz();
            const cx = width / 2;
            const cy = height / 2;
            const startTime = performance.now();

            // ============================================================
            // SHARED STATE (For simulations that need history/momentum)
            // ============================================================
            const state = {
                t: 0,
                history: [],
                particles: [],
                lorenz: { x: 0.1, y: 0, z: 0 },
                // Double Pendulum state
                p1: { r: 40, m: 10, a: Math.PI/2, v: 0 },
                p2: { r: 40, m: 10, a: Math.PI/2, v: 0 },
                pendulumTrail: [],
                // Schrodinger state
                wavepacket: { x: 0, k: 2, sigma: 15 },
                // Hamiltonian state
                hamiltonian: [],
                // Fiber bundle state
                fiberPoints: [],
                // Lorenz attractor state
                lorenzTrail: [],
                // Wave equation state
                wavePoints: [],
                // Ricci flow state
                ricciMetric: 1.0,
                // Gauge field state
                gaugePhase: []
            };
            
            // Initialize particles for various modes
            for(let i=0; i<50; i++) {
                state.particles.push({
                    angle: Math.random() * Math.PI * 2, 
                    r: Math.random() * 30,
                    speed: (Math.random() - 0.5) * 0.1,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            // Initialize Hamiltonian orbits
            for(let i=0; i<8; i++) {
                state.hamiltonian.push({
                    q: (i/8) * Math.PI * 2,
                    p: 0.3 + Math.random() * 0.4,
                    energy: 0.5 + i * 0.1
                });
            }
            
            // Initialize fiber bundle points
            for(let i=0; i<20; i++) {
                state.fiberPoints.push({
                    baseAngle: (i/20) * Math.PI * 2,
                    fiberPhase: Math.random() * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.03
                });
            }
            
            // Initialize Lorenz attractor trail
            state.lorenz = { x: 1, y: 1, z: 1 };
            
            // Initialize gauge field phases
            for(let i=0; i<12; i++) {
                state.gaugePhase.push({
                    angle: (i/12) * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                });
            }

            // ============================================================
            // PHD-GRADE RENDER ENGINES (5 Modes per Category)
            // Mode 0: Primary - The signature visualization
            // Mode 1: Dynamics - Time evolution / flow
            // Mode 2: Phase Space - State space representation
            // Mode 3: Structure - Algebraic/geometric structure
            // Mode 4: Application - Physical/practical application
            // ============================================================

            // ============================================================
            // NODE-SPECIFIC ENGINES (Unique 5-mode sets per Node ID)
            // This ensures each node has its own unique carousel animations
            // ============================================================
            const NODE_SPECIFIC_ENGINES = {

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // GEOMETRY NODES (Orange Theme: #f97316) - 5 nodes √ó 5 modes = 25 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 1. SMOOTH MANIFOLDS - HIGHLY DYNAMIC
                'smooth-manifolds': (ctx, time, mode) => {
                    ctx.strokeStyle = '#f97316'; ctx.fillStyle = '#f97316';
                    
                    // Mode 0: Coordinate Charts (Breathing Overlap with Particle Transition)
                    if (mode === 0) {
                        // Two charts breathing in and out
                        const r1 = 24 + Math.sin(time * 1.5) * 4;
                        const r2 = 24 + Math.sin(time * 1.5 + Math.PI) * 4;
                        
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#f97316';
                        ctx.beginPath(); ctx.arc(cx - 16, cy, r1, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#a855f7';
                        ctx.beginPath(); ctx.arc(cx + 16, cy, r2, 0, Math.PI*2); ctx.fill();
                        
                        // Overlap region highlight
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill();
                        
                        // Active particle transition between charts
                        const cycleTime = 2.5;
                        const t = (time % cycleTime) / cycleTime;
                        const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2) / 2;
                        
                        const particleX = cx - 16 + ease * 32;
                        const particleY = cy - Math.sin(ease * Math.PI) * 15;
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); 
                        ctx.arc(particleX, particleY, 4, 0, Math.PI*2); 
                        ctx.fill();
                        
                        // Trail effect
                        ctx.globalAlpha = 0.3;
                        for(let i = 1; i < 6; i++) {
                            const trailT = Math.max(0, t - i * 0.05);
                            const trailEase = trailT < 0.5 ? 2*trailT*trailT : 1 - Math.pow(-2*trailT + 2, 2) / 2;
                            const tx = cx - 16 + trailEase * 32;
                            const ty = cy - Math.sin(trailEase * Math.PI) * 15;
                            ctx.beginPath();
                            ctx.arc(tx, ty, 3 - i * 0.4, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Transition function label
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('œÜ ‚àò œà‚Åª¬π', cx - 15, cy + 35);
                    }
                    // Mode 1: Tangent Bundle (Waving Vector Field)
                    else if (mode === 1) {
                        // Draw manifold (half circle)
                        ctx.globalAlpha = 0.8;
                        ctx.strokeStyle = '#f97316';
                        ctx.beginPath(); ctx.arc(cx, cy + 18, 38, Math.PI, 2*Math.PI); ctx.stroke();
                        
                        // Vectors waving like grass in wind
                        for(let i = 0; i < 9; i++) {
                            const a = Math.PI + i * (Math.PI / 8);
                            const bx = cx + Math.cos(a) * 38;
                            const by = cy + 18 + Math.sin(a) * 38;
                            
                            // Wind wave effect
                            const wave = Math.sin(time * 2.5 + i * 0.6) * 0.5;
                            const vAngle = a - Math.PI/2 + wave;
                            const len = 14 + Math.sin(time * 3 + i) * 3;
                            
                            ctx.strokeStyle = '#a855f7';
                            ctx.lineWidth = 1.5;
                            ctx.beginPath(); 
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(vAngle) * len, by + Math.sin(vAngle) * len);
                            ctx.stroke();
                            
                            // Arrow tip
                            const tipX = bx + Math.cos(vAngle) * len;
                            const tipY = by + Math.sin(vAngle) * len;
                            ctx.fillStyle = '#a855f7';
                            ctx.beginPath();
                            ctx.arc(tipX, tipY, 2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#f97316';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('TM', cx - 10, cy - 8);
                    }
                    // Mode 2: Diffeomorphism (Active Grid Morphing!)
                    else if (mode === 2) {
                        // Oscillate between square grid and warped configuration
                        const morphT = (Math.sin(time * 0.8) + 1) / 2; // 0 to 1
                        
                        ctx.globalAlpha = 0.6;
                        ctx.strokeStyle = '#f97316';
                        
                        // Draw morphing grid lines (vertical)
                        for(let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            for(let j = -15; j <= 15; j++) {
                                const prog = j / 15; // -1 to 1
                                
                                // Square state
                                const sx = i * 14;
                                const sy = prog * 25;
                                
                                // Warped state (wave + rotation)
                                const warpX = i * 14 * (1 + 0.3 * Math.sin(prog * Math.PI));
                                const warpY = prog * 25 + Math.sin(prog * 2 + i) * 8;
                                
                                const x = cx + sx * (1 - morphT) + warpX * morphT;
                                const y = cy + sy * (1 - morphT) + warpY * morphT;
                                
                                if(j === -15) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        // Draw morphing grid lines (horizontal)
                        for(let j = -2; j <= 2; j++) {
                            ctx.beginPath();
                            for(let i = -15; i <= 15; i++) {
                                const prog = i / 15;
                                
                                const sx = prog * 28;
                                const sy = j * 10;
                                
                                const warpX = prog * 28 + Math.cos(j * 0.8) * prog * 5 * morphT;
                                const warpY = j * 10 * (1 + 0.2 * Math.cos(prog * Math.PI)) * (1 + morphT * 0.3);
                                
                                const x = cx + sx * (1 - morphT) + warpX * morphT;
                                const y = cy + sy * (1 - morphT) + warpY * morphT;
                                
                                if(i === -15) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('f: M ‚âÖ N', cx - 18, cy + 38);
                    }
                    // Mode 3: Orientability (Ant Walking on M√∂bius)
                    else if (mode === 3) {
                        // Draw figure-8 path (M√∂bius representation)
                        ctx.strokeStyle = '#888';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        for(let t = 0; t <= Math.PI * 2; t += 0.1) {
                            ctx.lineTo(cx + 28 * Math.cos(t), cy + 12 * Math.sin(2*t));
                        }
                        ctx.stroke();
                        
                        // Ant walking on the path
                        const antT = time * 0.8;
                        const ax = cx + 28 * Math.cos(antT);
                        const ay = cy + 12 * Math.sin(2 * antT);
                        
                        // Normal vector flips based on position (demonstrating non-orientability)
                        const normalFlip = Math.sin(antT / 2) > 0;
                        const normalDir = normalFlip ? -1 : 1;
                        
                        // Calculate tangent for normal direction
                        const nextT = antT + 0.1;
                        const nextX = cx + 28 * Math.cos(nextT);
                        const nextY = cy + 12 * Math.sin(2 * nextT);
                        const tangentAngle = Math.atan2(nextY - ay, nextX - ax);
                        const normalAngle = tangentAngle + Math.PI/2;
                        
                        // Draw normal vector
                        ctx.strokeStyle = normalFlip ? '#4ecdc4' : '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(ax, ay);
                        ctx.lineTo(ax + Math.cos(normalAngle) * 15 * normalDir, ay + Math.sin(normalAngle) * 15 * normalDir);
                        ctx.stroke();
                        
                        // Ant point
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(ax, ay, 4, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Orientation Flip', cx - 35, cy + 35);
                    }
                    // Mode 4: Partition of Unity (Animated Bump Functions)
                    else if (mode === 4) {
                        // Two bump functions moving and summing to 1
                        const offset = Math.sin(time) * 20;
                        
                        // Draw first bump
                        ctx.beginPath();
                        for(let x = 0; x < width; x++) {
                            const nx = (x - cx - offset) / 12;
                            const b1 = Math.exp(-nx * nx);
                            const y = cy + 20 - b1 * 30;
                            if(x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.strokeStyle = '#f97316';
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        // Draw second bump
                        ctx.beginPath();
                        for(let x = 0; x < width; x++) {
                            const nx = (x - cx + offset) / 12;
                            const b2 = Math.exp(-nx * nx);
                            const y = cy + 20 - b2 * 30;
                            if(x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.strokeStyle = '#a855f7';
                        ctx.stroke();
                        
                        // Draw sum (should be constant = 1 in overlap)
                        ctx.beginPath();
                        for(let x = 0; x < width; x++) {
                            const nx1 = (x - cx - offset) / 12;
                            const nx2 = (x - cx + offset) / 12;
                            const sum = Math.exp(-nx1 * nx1) + Math.exp(-nx2 * nx2);
                            const y = cy + 20 - sum * 30;
                            if(x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.9;
                        ctx.stroke();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œ£œÅ·µ¢ = 1', cx - 18, cy - 20);
                    }
                },

                // 2. RIEMANNIAN GEOMETRY - HIGHLY DYNAMIC
                'riemannian-geometry': (ctx, time, mode) => {
                    ctx.strokeStyle = '#f97316'; ctx.fillStyle = '#f97316';

                    // Mode 0: Metric Tensor (Pulsing, Rotating Tissot Indicatrices)
                    if (mode === 0) {
                        for(let i = -1; i <= 1; i++) {
                            for(let j = -1; j <= 1; j++) {
                                // Phase offset based on position for wave effect
                                const phase = (i + j) * 0.8 + time * 2;
                                const g11 = 1 + 0.4 * Math.sin(phase);
                                const g22 = 1 + 0.4 * Math.cos(phase);
                                
                                ctx.globalAlpha = 0.7;
                                ctx.beginPath();
                                // Rotating ellipse
                                ctx.ellipse(cx + i * 24, cy + j * 20, 7 * g11, 7 * g22, time * 0.5 + i * 0.3, 0, Math.PI*2);
                                ctx.stroke();
                                
                                // Center dot
                                ctx.globalAlpha = 0.4;
                                ctx.beginPath();
                                ctx.arc(cx + i * 24, cy + j * 20, 2, 0, Math.PI*2);
                                ctx.fill();
                            }
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('g·µ¢‚±º(x)', cx - 15, cy + 38);
                    }
                    // Mode 1: Geodesics (Shooting Particles on Sphere)
                    else if (mode === 1) {
                        // Draw sphere
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.5;
                        ctx.stroke();
                        
                        // Draw latitude lines
                        for(let lat = -0.5; lat <= 0.5; lat += 0.5) {
                            const yOff = lat * 30;
                            const rLat = Math.sqrt(30*30 - yOff*yOff);
                            ctx.globalAlpha = 0.2;
                            ctx.beginPath();
                            ctx.ellipse(cx, cy + yOff, rLat, rLat * 0.3, 0, 0, Math.PI*2);
                            ctx.stroke();
                        }
                        
                        // Multiple geodesic particles
                        for(let p = 0; p < 3; p++) {
                            const particleT = (time + p * 1.5) % 4;
                            const lat = (particleT - 2) * 0.6; // -1.2 to 1.2
                            const r = 30 * Math.cos(lat);
                            const y = 30 * Math.sin(lat);
                            const lng = p * Math.PI * 0.4 + time * 0.3;
                            const x = r * Math.sin(lng);
                            
                            // Depth shading
                            const z = r * Math.cos(lng);
                            const alpha = 0.4 + 0.6 * (z / 30 + 1) / 2;
                            
                            ctx.fillStyle = p === 0 ? '#fff' : '#f97316';
                            ctx.globalAlpha = alpha;
                            ctx.beginPath();
                            ctx.arc(cx + x, cy + y, p === 0 ? 4 : 3, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('‚àá·µßŒ≥Ãá = 0', cx - 18, cy + 40);
                    }
                    // Mode 2: Parallel Transport (Ghost Trail Holonomy)
                    else if (mode === 2) {
                        // Path circle
                        ctx.globalAlpha = 0.4;
                        ctx.setLineDash([3, 3]);
                        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        
                        const angle = time * 0.8;
                        const px = cx + Math.cos(angle) * 26;
                        const py = cy + Math.sin(angle) * 26;
                        
                        // The vector rotates faster than position (holonomy!)
                        const vAngle = angle * 1.4;
                        
                        // Ghost trail of previous vectors
                        for(let k = 1; k < 8; k++) {
                            const oldAng = angle - k * 0.15;
                            const oldVAng = oldAng * 1.4;
                            const ox = cx + Math.cos(oldAng) * 26;
                            const oy = cy + Math.sin(oldAng) * 26;
                            
                            ctx.strokeStyle = '#f97316';
                            ctx.globalAlpha = 0.3 - k * 0.03;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(ox, oy);
                            ctx.lineTo(ox + Math.cos(oldVAng) * 12, oy + Math.sin(oldVAng) * 12);
                            ctx.stroke();
                        }
                        
                        // Current vector
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(vAngle) * 14, py + Math.sin(vAngle) * 14);
                        ctx.stroke();
                        
                        // Point
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Holonomy', cx - 22, cy + 40);
                    }
                    // Mode 3: Curvature (Morphing Between + and - Curvature)
                    else if (mode === 3) {
                        const k = Math.sin(time * 0.8); // Oscillate between +1 and -1
                        
                        // Draw surface profile
                        ctx.strokeStyle = k > 0 ? '#4ecdc4' : '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        for(let x = -28; x <= 28; x += 2) {
                            const y = cy + (x * x * k) / 35;
                            if(x === -28) ctx.moveTo(cx + x, y); else ctx.lineTo(cx + x, y);
                        }
                        ctx.stroke();
                        
                        // Geodesic deviation arrows (converge for +, diverge for -)
                        const arrowSpread = 10 + k * 8;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.6;
                        
                        // Left arrow
                        ctx.beginPath();
                        ctx.moveTo(cx - 12, cy - 25);
                        ctx.lineTo(cx - 12 - arrowSpread * 0.5, cy + 5 + k * 5);
                        ctx.stroke();
                        
                        // Right arrow
                        ctx.beginPath();
                        ctx.moveTo(cx + 12, cy - 25);
                        ctx.lineTo(cx + 12 + arrowSpread * 0.5, cy + 5 + k * 5);
                        ctx.stroke();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = k > 0 ? '#4ecdc4' : '#ff6b6b';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText(k > 0 ? 'K > 0' : 'K < 0', cx - 15, cy - 28);
                    }
                    // Mode 4: Christoffel Symbols (Interacting Index Dance)
                    else if (mode === 4) {
                        // Three orbiting elements representing indices
                        const r = 18;
                        const positions = [];
                        const labels = ['i', 'j', 'k'];
                        const colors = ['#ff6b6b', '#4ecdc4', '#fbbf24'];
                        
                        for(let n = 0; n < 3; n++) {
                            const angle = time * 0.8 + n * Math.PI * 2 / 3;
                            const x = cx + Math.cos(angle) * r;
                            const y = cy + Math.sin(angle) * r;
                            positions.push({x, y});
                            
                            ctx.fillStyle = colors[n];
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(x, y, 5, 0, Math.PI*2);
                            ctx.fill();
                            
                            ctx.font = '9px serif';
                            ctx.fillText(labels[n], x + 8, y + 3);
                        }
                        
                        // Connection lines between indices
                        ctx.strokeStyle = '#f97316';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.moveTo(positions[0].x, positions[0].y);
                        ctx.lineTo(positions[1].x, positions[1].y);
                        ctx.lineTo(positions[2].x, positions[2].y);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Center Gamma symbol
                        ctx.font = '18px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œì', cx - 7, cy + 6);
                    }
                },

                // 3. FIBER BUNDLES
                'fiber-bundles': (ctx, time, mode) => {
                    ctx.strokeStyle = '#f97316'; ctx.fillStyle = '#f97316';

                    // Mode 0: Bundle Structure (E ‚Üí B)
                    if (mode === 0) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy+18, 30, 0, Math.PI*2); ctx.stroke();
                        const numFibers = 10;
                        for(let i=0; i<numFibers; i++) {
                            const angle = (i/numFibers)*Math.PI*2 + time*0.3;
                            const bx = cx + Math.cos(angle)*30;
                            const by = cy+18 + Math.sin(angle)*30*0.4;
                            ctx.globalAlpha = 0.4;
                            ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(bx, by-28); ctx.stroke();
                            const fy = by - 14 + Math.sin(time*2 + i)*10;
                            ctx.fillStyle = '#f97316';
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath(); ctx.arc(bx, fy, 2, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('E', cx+38, cy-8);
                        ctx.fillText('B', cx+38, cy+28);
                    }
                    // Mode 1: M√∂bius Strip (Non-trivial bundle)
                    else if (mode === 1) {
                        const twist = Math.sin(time)*15;
                        ctx.beginPath();
                        ctx.moveTo(cx-35, cy-12); ctx.lineTo(cx+35, cy-12 + twist);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx-35, cy+12); ctx.lineTo(cx+35, cy+12 - twist);
                        ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(cx, cy, 35, 12, 0, 0, Math.PI*2);
                        ctx.globalAlpha = 0.3; ctx.stroke();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Twist ‚â† 0', cx-22, cy+35);
                    }
                    // Mode 2: Section (s: B ‚Üí E)
                    else if (mode === 2) {
                        for(let x=-35; x<=35; x+=10) {
                            ctx.globalAlpha = 0.3;
                            ctx.beginPath(); ctx.moveTo(cx+x, cy-25); ctx.lineTo(cx+x, cy+25); ctx.stroke();
                        }
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        for(let x=-35; x<=35; x++) {
                            const y = cy + Math.sin(x*0.08 + time)*15;
                            if(x===-35) ctx.moveTo(cx+x, y); else ctx.lineTo(cx+x, y);
                        }
                        ctx.stroke();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('s: B ‚Üí E', cx-20, cy+38);
                    }
                    // Mode 3: Local Triviality
                    else if (mode === 3) {
                        ctx.globalAlpha = 0.2;
                        ctx.fillRect(cx-25, cy-20, 50, 40);
                        ctx.globalAlpha = 0.8;
                        ctx.strokeRect(cx-25, cy-20, 50, 40);
                        for(let i=0; i<5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx-25+i*12.5, cy-20);
                            ctx.lineTo(cx-25+i*12.5, cy+20);
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('œÄ‚Åª¬π(U) ‚âÖ U√óF', cx-30, cy+35);
                    }
                    // Mode 4: Structure Group
                    else if (mode === 4) {
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.arc(cx, cy, 25, 0, Math.PI*2); ctx.stroke();
                        const px = cx + Math.cos(time*2)*25;
                        const py = cy + Math.sin(time*2)*25;
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        ctx.font = '12px serif';
                        ctx.fillStyle = '#f97316';
                        ctx.fillText('G', cx-5, cy+5);
                    }
                },

                // 4. CONNECTIONS & CURVATURE
                'connections': (ctx, time, mode) => {
                    ctx.strokeStyle = '#f97316'; ctx.fillStyle = '#f97316';

                    // Mode 0: Covariant Derivative
                    if (mode === 0) {
                        ctx.beginPath(); ctx.arc(cx, cy+10, 30, Math.PI, 2*Math.PI); ctx.stroke();
                        const t = time*0.8;
                        const px = cx + Math.cos(Math.PI + t)*30;
                        const py = cy + 10 + Math.sin(Math.PI + t)*30;
                        const len = 18 + Math.sin(time*2)*5;
                        const vAngle = Math.PI + t - Math.PI/2;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(vAngle)*len, py + Math.sin(vAngle)*len);
                        ctx.stroke();
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚àá‚ÇìY', cx-12, cy-18);
                    }
                    // Mode 1: Holonomy (Loop transport)
                    else if (mode === 1) {
                        ctx.globalAlpha = 0.5;
                        ctx.strokeRect(cx-22, cy-22, 44, 44);
                        const phase = (time*0.5) % 4;
                        let px, py;
                        if(phase < 1) { px = cx-22 + phase*44; py = cy-22; }
                        else if(phase < 2) { px = cx+22; py = cy-22 + (phase-1)*44; }
                        else if(phase < 3) { px = cx+22 - (phase-2)*44; py = cy+22; }
                        else { px = cx-22; py = cy+22 - (phase-3)*44; }
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        const vAngle = phase * Math.PI/2 + Math.PI/4;
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(vAngle)*12, py + Math.sin(vAngle)*12);
                        ctx.stroke();
                    }
                    // Mode 2: Curvature 2-form (Œ© = dœâ + œâ‚àßœâ)
                    else if (mode === 2) {
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath(); ctx.arc(cx, cy, 28, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.8;
                        for(let i=0; i<6; i++) {
                            const a = time + i*(Math.PI/3);
                            ctx.beginPath();
                            ctx.moveTo(cx + Math.cos(a)*10, cy + Math.sin(a)*10);
                            ctx.lineTo(cx + Math.cos(a)*28, cy + Math.sin(a)*28);
                            ctx.stroke();
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('Œ©', cx-5, cy+5);
                    }
                    // Mode 3: Horizontal Lift
                    else if (mode === 3) {
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(cx-35, cy+22); ctx.lineTo(cx+35, cy+22);
                        ctx.stroke();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        for(let x=-35; x<=35; x+=2) {
                            const y = cy - 5 + Math.sin(x*0.1 + time)*12;
                            if(x===-35) ctx.moveTo(cx+x, y); else ctx.lineTo(cx+x, y);
                        }
                        ctx.stroke();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('horizontal', cx-22, cy+38);
                    }
                    // Mode 4: Gauge Potential (A_Œº)
                    else if (mode === 4) {
                        for(let i=-1; i<=1; i++) {
                            for(let j=-1; j<=1; j++) {
                                const x = cx + i*22;
                                const y = cy + j*18;
                                const ang = Math.atan2(j, i) + time;
                                ctx.globalAlpha = 0.7;
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + Math.cos(ang)*10, y + Math.sin(ang)*10);
                                ctx.stroke();
                            }
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('AŒº', cx+30, cy+30);
                    }
                },

                // 5. COMPLEX PROJECTIVE SPACE - DYNAMIC RIEMANN SPHERE
                'complex-geometry': (ctx, time, mode) => {
                    ctx.strokeStyle = '#f97316'; ctx.fillStyle = '#f97316';

                    // Mode 0: Riemann Sphere Stereographic Projection
                    if (mode === 0) {
                        const r = 24;
                        
                        // Draw sphere
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.5;
                        ctx.stroke();
                        
                        // Complex plane line
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(cx-40, cy+r+5);
                        ctx.lineTo(cx+40, cy+r+5);
                        ctx.stroke();
                        
                        // North Pole (‚àû)
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx, cy-r, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '8px serif';
                        ctx.fillText('‚àû', cx+5, cy-r+3);
                        
                        // Moving point on sphere
                        const sphereAng = time * 0.8;
                        const sphereElev = Math.sin(time * 0.5) * 0.8;
                        const px = cx + Math.cos(sphereAng) * r * Math.cos(sphereElev);
                        const py = cy - Math.sin(sphereElev) * r;
                        
                        ctx.fillStyle = '#f97316';
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        
                        // Projection ray from North Pole through point to plane
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([2,2]);
                        ctx.globalAlpha = 0.5;
                        
                        // Calculate intersection with plane
                        const planeY = cy + r + 5;
                        const t = (planeY - (cy-r)) / (py - (cy-r));
                        const projX = cx + (px - cx) * t;
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, cy-r);
                        ctx.lineTo(projX, planeY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Projected point on plane
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.arc(projX, planeY, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('‚ÑÇ ‚à™ {‚àû}', cx-16, cy+42);
                    }
                    
                    // Mode 1: M√∂bius Transformation Flow
                    else if (mode === 1) {
                        // Draw flowing circles being transformed
                        for(let i=0; i<6; i++) {
                            const baseR = 5 + i*5;
                            const offset = Math.sin(time * 0.8 + i*0.5) * 8;
                            const squeeze = 0.6 + 0.4*Math.cos(time*0.5 + i);
                            
                            ctx.beginPath();
                            ctx.ellipse(cx+offset, cy, baseR*squeeze, baseR/squeeze, time*0.2, 0, Math.PI*2);
                            ctx.strokeStyle = `hsla(${25 + i*8}, 80%, 55%, ${0.3 + 0.1*(6-i)})`;
                            ctx.stroke();
                        }
                        
                        // Flowing particles along transformed circles
                        for(let i=0; i<4; i++) {
                            const pt = time * 1.5 + i * Math.PI/2;
                            const r = 15 + Math.sin(pt) * 10;
                            const px = cx + Math.cos(pt) * r;
                            const py = cy + Math.sin(pt) * r * 0.7;
                            
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath(); ctx.arc(px, py, 2, 0, Math.PI*2); ctx.fill();
                        }
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('z ‚Ü¶ (az+b)/(cz+d)', cx-38, cy+38);
                    }
                    
                    // Mode 2: Fubini-Study Metric (Curvature Visualization)
                    else if (mode === 2) {
                        // Sphere with curvature grid
                        ctx.fillStyle = '#f97316';
                        ctx.globalAlpha = 0.15;
                        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();
                        
                        // Latitude lines (get denser at equator)
                        ctx.strokeStyle = '#f97316';
                        for(let i=1; i<6; i++) {
                            const lat = (i/6 - 0.5) * Math.PI;
                            const y = Math.sin(lat) * 26;
                            const rLat = Math.cos(lat) * 26;
                            
                            ctx.globalAlpha = 0.3 + 0.2*Math.cos(lat);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy + y, rLat, rLat*0.25, 0, 0, Math.PI*2);
                            ctx.stroke();
                        }
                        
                        // Longitude lines (rotating)
                        for(let i=0; i<4; i++) {
                            const lng = time*0.3 + i*Math.PI/4;
                            ctx.globalAlpha = 0.4;
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, 26, 26*Math.abs(Math.sin(lng)), lng, 0, Math.PI*2);
                            ctx.stroke();
                        }
                        
                        // Highlight point with local geometry
                        const hlAng = time * 0.5;
                        const hlx = cx + Math.cos(hlAng) * 26;
                        const hly = cy + Math.sin(hlAng) * 8;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(hlx, hly, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('constant K > 0', cx-30, cy+38);
                    }
                    
                    // Mode 3: Tautological Line Bundle O(-1)
                    else if (mode === 3) {
                        // Base ‚ÑÇP¬π
                        ctx.strokeStyle = '#f97316';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy+12, 28, 10, 0, 0, Math.PI*2);
                        ctx.stroke();
                        
                        // Fibers (lines through origin)
                        for(let i=0; i<10; i++) {
                            const a = time*0.4 + i*(Math.PI/5);
                            const bx = cx + Math.cos(a)*28;
                            const by = cy + 12 + Math.sin(a)*10;
                            
                            // Line through origin (the actual fiber)
                            const lineAng = a;
                            const lineLen = 18 + Math.sin(time*2 + i)*4;
                            
                            ctx.strokeStyle = `hsla(${25 + i*8}, 70%, 55%, 0.5)`;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(lineAng)*lineLen*0.3, by - lineLen);
                            ctx.stroke();
                        }
                        
                        // Central origin point
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx, cy-8, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '8px serif';
                        ctx.fillText('0', cx+5, cy-6);
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('O(-1)', cx-12, cy+38);
                    }
                    
                    // Mode 4: Divisors (Zeros and Poles Dancing)
                    else if (mode === 4) {
                        // Riemann sphere background
                        ctx.globalAlpha = 0.15;
                        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.3; ctx.stroke();
                        
                        // Zero (moving point) - positive divisor
                        const zeroAng = time * 0.7;
                        const zeroR = 18;
                        const zx = cx + Math.cos(zeroAng) * zeroR;
                        const zy = cy + Math.sin(zeroAng) * zeroR * 0.6;
                        
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(zx, zy, 5, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillText('0', zx+7, zy+3);
                        
                        // Pole (opposite side) - negative divisor
                        const px = cx - Math.cos(zeroAng) * zeroR;
                        const py = cy - Math.sin(zeroAng) * zeroR * 0.6;
                        
                        // Draw pole as X mark
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(px-4, py-4); ctx.lineTo(px+4, py+4);
                        ctx.moveTo(px+4, py-4); ctx.lineTo(px-4, py+4);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillText('‚àû', px+7, py+3);
                        
                        // Show they're linked (flow line)
                        ctx.setLineDash([3,3]);
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(zx, zy);
                        ctx.quadraticCurveTo(cx, cy - 15, px, py);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('deg D = 0', cx-20, cy+38);
                    }
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TOPOLOGY NODES (Teal Theme: #10b981) - 5 nodes √ó 5 modes = 25 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 6. POINT-SET TOPOLOGY - HIGHLY DYNAMIC LIVING SETS
                'point-set-topology': (ctx, time, mode) => {
                    ctx.strokeStyle = '#10b981'; ctx.fillStyle = '#10b981';
                    
                    // Mode 0: Open Sets (Living Amoeba with multi-frequency wobble)
                    if (mode === 0) {
                        ctx.beginPath();
                        for(let a = 0; a <= Math.PI * 2; a += 0.08) {
                            // Multi-frequency noise for organic amoeba shape
                            const r = 22 
                                + Math.sin(a * 3 + time * 2) * 4
                                + Math.sin(a * 5 - time * 1.5) * 3
                                + Math.sin(a * 7 + time * 3) * 2
                                + Math.sin(a * 2 - time) * 5;
                            const x = cx + Math.cos(a) * r;
                            const y = cy + Math.sin(a) * r;
                            if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        
                        // Gradient fill
                        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
                        grad.addColorStop(0, 'rgba(16, 185, 129, 0.4)');
                        grad.addColorStop(1, 'rgba(16, 185, 129, 0.1)');
                        ctx.fillStyle = grad;
                        ctx.fill();
                        
                        // Dashed boundary (not included)
                        ctx.setLineDash([4, 3]);
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Interior points floating
                        for(let i = 0; i < 5; i++) {
                            const angle = time * 0.5 + i * 1.2;
                            const dist = 8 + Math.sin(time * 2 + i) * 5;
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Open Set', cx - 22, cy + 38);
                    }
                    // Mode 1: Continuity (Stretching/Morphing Domain)
                    else if (mode === 1) {
                        // Source domain
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.5;
                        ctx.strokeRect(cx - 38, cy - 18, 22, 36);
                        
                        // Target domain (stretching over time)
                        const stretch = 1 + Math.sin(time) * 0.4;
                        const squash = 1 - Math.sin(time) * 0.2;
                        ctx.save();
                        ctx.translate(cx + 27, cy);
                        ctx.scale(squash, stretch);
                        ctx.strokeRect(-11, -18, 22, 36);
                        ctx.restore();
                        
                        // Flowing mapping particles
                        for(let i = 0; i < 4; i++) {
                            const phase = (time * 0.8 + i * 0.25) % 1;
                            const startX = cx - 27;
                            const endX = cx + 27;
                            const x = startX + (endX - startX) * phase;
                            const yWobble = Math.sin(phase * Math.PI) * 10 * (i % 2 === 0 ? 1 : -1);
                            const y = cy + yWobble;
                            
                            ctx.fillStyle = phase < 0.5 ? '#10b981' : '#4ecdc4';
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Arrow
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(cx - 12, cy);
                        ctx.lineTo(cx + 8, cy);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx + 5, cy - 3);
                        ctx.lineTo(cx + 8, cy);
                        ctx.lineTo(cx + 5, cy + 3);
                        ctx.stroke();
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Continuous', cx - 25, cy + 38);
                    }
                    // Mode 2: Hausdorff Separation (Points Repelling)
                    else if (mode === 2) {
                        // Two points that try to stay separated
                        const repelForce = Math.sin(time * 2);
                        const baseSep = 18;
                        const sep = baseSep + repelForce * 5;
                        
                        // Draw repulsion field lines
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.2;
                        for(let i = 0; i < 6; i++) {
                            const angle = i * Math.PI / 3 + time * 0.3;
                            ctx.beginPath();
                            ctx.moveTo(cx - sep + Math.cos(angle) * 5, cy + Math.sin(angle) * 5);
                            ctx.lineTo(cx - sep + Math.cos(angle) * 15, cy + Math.sin(angle) * 15);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(cx + sep + Math.cos(angle + Math.PI) * 5, cy + Math.sin(angle + Math.PI) * 5);
                            ctx.lineTo(cx + sep + Math.cos(angle + Math.PI) * 15, cy + Math.sin(angle + Math.PI) * 15);
                            ctx.stroke();
                        }
                        
                        // Neighborhoods (expanding/contracting)
                        const nhoodR = 14 + Math.sin(time * 1.5) * 3;
                        ctx.setLineDash([3, 3]);
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx - sep, cy, nhoodR, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(cx + sep, cy, nhoodR, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Points
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx - sep, cy, 4, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(cx + sep, cy, 4, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('T‚ÇÇ: Separated', cx - 30, cy + 35);
                    }
                    // Mode 3: Compactness (Shrinking Cover Animation)
                    else if (mode === 3) {
                        // The compact set
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                        
                        // Covering sets that shrink to finite subcover
                        const n = 6;
                        const coverPhase = (time % 4) / 4; // 0 to 1 cycle
                        
                        for(let i = 0; i < n; i++) {
                            const baseAngle = (i / n) * Math.PI * 2;
                            const angle = baseAngle + time * 0.2;
                            
                            // Start large, shrink to tight cover
                            const dist = 12 * (1 - coverPhase * 0.3);
                            const coverR = 20 - coverPhase * 8;
                            
                            const x = cx + Math.cos(angle) * dist;
                            const y = cy + Math.sin(angle) * dist;
                            
                            // Highlight active cover elements
                            const isActive = i <= Math.floor(coverPhase * n);
                            ctx.fillStyle = isActive ? 'rgba(78, 205, 196, 0.3)' : 'rgba(16, 185, 129, 0.15)';
                            ctx.beginPath();
                            ctx.arc(x, y, coverR, 0, Math.PI*2);
                            ctx.fill();
                            
                            ctx.strokeStyle = isActive ? '#4ecdc4' : '#10b981';
                            ctx.globalAlpha = isActive ? 0.8 : 0.3;
                            ctx.stroke();
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Finite Subcover', cx - 35, cy + 40);
                    }
                    // Mode 4: Connectedness (Tearing Apart Animation)
                    else if (mode === 4) {
                        const tearPhase = (Math.sin(time * 0.7) + 1) / 2; // 0 to 1
                        const tearDist = tearPhase * 22;
                        
                        // Draw stretching bridge
                        if (tearDist < 18) {
                            ctx.fillStyle = '#10b981';
                            ctx.globalAlpha = 0.3 * (1 - tearPhase);
                            ctx.beginPath();
                            ctx.moveTo(cx - 12 - tearDist, cy - 8);
                            ctx.quadraticCurveTo(cx, cy - 5 - tearDist * 0.3, cx + 12 + tearDist, cy - 8);
                            ctx.quadraticCurveTo(cx, cy + 5 + tearDist * 0.3, cx - 12 - tearDist, cy + 8);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Two blobs
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 0.5;
                        
                        // Left blob (amoeba-like)
                        ctx.beginPath();
                        for(let a = 0; a <= Math.PI * 2; a += 0.1) {
                            const r = 14 + Math.sin(a * 3 + time * 2) * 2;
                            const x = cx - 12 - tearDist + Math.cos(a) * r;
                            const y = cy + Math.sin(a) * r;
                            if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Right blob
                        ctx.beginPath();
                        for(let a = 0; a <= Math.PI * 2; a += 0.1) {
                            const r = 14 + Math.sin(a * 3 - time * 2) * 2;
                            const x = cx + 12 + tearDist + Math.cos(a) * r;
                            const y = cy + Math.sin(a) * r;
                            if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = tearDist > 15 ? '#ff6b6b' : '#4ecdc4';
                        ctx.fillText(tearDist > 15 ? 'Disconnected' : 'Connected', cx - 28, cy + 38);
                    }
                },

                // 7. ALGEBRAIC TOPOLOGY - DYNAMIC HOMOTOPY & PATHS
                'algebraic-topology': (ctx, time, mode) => {
                    ctx.strokeStyle = '#10b981'; ctx.fillStyle = '#10b981';

                    // Mode 0: Fundamental Group œÄ‚ÇÅ (Multiple Winding Loops)
                    if (mode === 0) {
                        // The puncture/hole
                        ctx.fillStyle = '#000';
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); 
                        ctx.fill(); ctx.stroke();
                        
                        // Winding loop with multiple windings visible
                        const windings = 3;
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        
                        ctx.beginPath();
                        for(let i=0; i<=100; i++) {
                            const t = (i/100) * Math.PI*2 * windings;
                            const r = 16 + 8 * (1 - i/100); // Spiral inward
                            const wobble = Math.sin(t * 2 + time * 3) * 2;
                            const x = cx + Math.cos(t + time) * (r + wobble);
                            const y = cy + Math.sin(t + time) * (r + wobble);
                            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        // Moving point along the loop
                        const pt = (time * 2) % (Math.PI*2*windings);
                        const pr = 16 + 8 * (1 - pt/(Math.PI*2*windings));
                        const px = cx + Math.cos(pt + time) * pr;
                        const py = cy + Math.sin(pt + time) * pr;
                        
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('œÄ‚ÇÅ = ‚Ñ§', cx-14, cy+35);
                    }
                    // Mode 1: Homotopy (Smooth Path Morphing)
                    else if (mode === 1) {
                        const t = (Math.sin(time * 0.8) + 1) / 2; // 0 to 1 smooth
                        
                        // Draw ghost paths (start and end configurations)
                        ctx.globalAlpha = 0.2;
                        ctx.strokeStyle = '#10b981';
                        
                        // Path at t=0 (curved up)
                        ctx.beginPath();
                        ctx.moveTo(cx-32, cy);
                        ctx.quadraticCurveTo(cx, cy - 28, cx+32, cy);
                        ctx.stroke();
                        
                        // Path at t=1 (curved down)
                        ctx.beginPath();
                        ctx.moveTo(cx-32, cy);
                        ctx.quadraticCurveTo(cx, cy + 28, cx+32, cy);
                        ctx.stroke();
                        
                        // Current morphing path
                        const cpY = -28 * (1-t) + 28 * t;
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(cx-32, cy);
                        ctx.quadraticCurveTo(cx, cy + cpY, cx+32, cy);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        // Endpoints (fixed)
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(cx-32, cy, 4, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(cx+32, cy, 4, 0, Math.PI*2); ctx.fill();
                        
                        // Moving point along path
                        const pt = (time * 1.5) % 1;
                        const pathX = cx - 32 + pt * 64;
                        const pathY = cy + cpY * 4 * pt * (1-pt); // Parabola approximation
                        ctx.fillStyle = '#4ecdc4';
                        ctx.beginPath(); ctx.arc(pathX, pathY, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '11px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('H(x,t)', cx-15, cy-32);
                    }
                    // Mode 2: Simplicial Complex (Rotating 3D Tetrahedron)
                    else if (mode === 2) {
                        const size = 22;
                        const yaw = time * 0.6;
                        const pitch = time * 0.4;
                        
                        // Tetrahedron vertices (4 points)
                        const verts = [
                            {x: 0, y: -1.2, z: 0},     // apex
                            {x: -1, y: 0.8, z: -0.8},  // base vertices
                            {x: 1, y: 0.8, z: -0.8},
                            {x: 0, y: 0.8, z: 1}
                        ];
                        
                        // 4 triangular faces
                        const faces = [
                            [0, 1, 2],  // front-left
                            [0, 2, 3],  // front-right
                            [0, 3, 1],  // back
                            [1, 3, 2]   // base
                        ];
                        
                        // Apply rotation and project
                        const cY = Math.cos(yaw), sY = Math.sin(yaw);
                        const cP = Math.cos(pitch), sP = Math.sin(pitch);
                        
                        const projected = verts.map(v => {
                            // Yaw rotation
                            let x = v.x * cY - v.z * sY;
                            let z = v.x * sY + v.z * cY;
                            let y = v.y;
                            
                            // Pitch rotation
                            const y2 = y * cP - z * sP;
                            z = y * sP + z * cP;
                            y = y2;
                            
                            return {
                                x: cx + x * size,
                                y: cy + y * size,
                                z: z
                            };
                        });
                        
                        // Calculate face depths and sort back-to-front
                        const facesWithDepth = faces.map((f, i) => ({
                            indices: f,
                            depth: (projected[f[0]].z + projected[f[1]].z + projected[f[2]].z) / 3
                        }));
                        facesWithDepth.sort((a, b) => a.depth - b.depth);
                        
                        // Draw faces with transparency
                        facesWithDepth.forEach(face => {
                            const f = face.indices;
                            const p = [projected[f[0]], projected[f[1]], projected[f[2]]];
                            
                            // Fill face
                            ctx.fillStyle = '#10b981';
                            ctx.globalAlpha = 0.12 + (face.depth + 1) * 0.08;
                            ctx.beginPath();
                            ctx.moveTo(p[0].x, p[0].y);
                            ctx.lineTo(p[1].x, p[1].y);
                            ctx.lineTo(p[2].x, p[2].y);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Stroke edges
                            ctx.strokeStyle = '#10b981';
                            ctx.globalAlpha = 0.5 + (face.depth + 1) * 0.25;
                            ctx.lineWidth = face.depth > 0 ? 1.5 : 1;
                            ctx.stroke();
                        });
                        
                        // Draw vertices with depth shading
                        projected.forEach((p, i) => {
                            ctx.fillStyle = p.z > 0 ? '#fff' : '#10b981';
                            ctx.globalAlpha = 0.5 + (p.z + 1) * 0.25;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.z > 0 ? 4 : 2.5, 0, Math.PI*2);
                            ctx.fill();
                        });
                        
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('3-Simplex (Œî¬≥)', cx - 32, cy + 42);
                    }
                    // Mode 3: Chain Complex (Flowing Exact Sequence)
                    else if (mode === 3) {
                        const groups = ['C‚ÇÇ', 'C‚ÇÅ', 'C‚ÇÄ'];
                        const spacing = 32;
                        
                        // Draw groups
                        ctx.font = '12px serif';
                        groups.forEach((g, i) => {
                            const x = cx - spacing + i * spacing;
                            
                            // Circle around active group
                            const isActive = Math.floor(time * 1.2) % 3 === i;
                            if(isActive) {
                                ctx.strokeStyle = '#4ecdc4';
                                ctx.globalAlpha = 0.8;
                                ctx.beginPath();
                                ctx.arc(x, cy, 14, 0, Math.PI*2);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = isActive ? '#fff' : '#10b981';
                            ctx.globalAlpha = isActive ? 1.0 : 0.6;
                            ctx.fillText(g, x-8, cy+4);
                        });
                        
                        // Arrows with flowing particles
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.5;
                        for(let i=0; i<2; i++) {
                            const x1 = cx - spacing + i*spacing + 12;
                            const x2 = x1 + spacing - 24;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, cy);
                            ctx.lineTo(x2, cy);
                            ctx.stroke();
                            
                            // Arrow head
                            ctx.beginPath();
                            ctx.moveTo(x2, cy);
                            ctx.lineTo(x2-5, cy-3);
                            ctx.moveTo(x2, cy);
                            ctx.lineTo(x2-5, cy+3);
                            ctx.stroke();
                            
                            // Flowing particle
                            const pt = (time * 2 + i * 0.5) % 1;
                            const px = x1 + (x2 - x1) * pt;
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath(); ctx.arc(px, cy, 2, 0, Math.PI*2); ctx.fill();
                        }
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('‚àÇ¬≤ = 0', cx-12, cy+30);
                    }
                    // Mode 4: Cup Product (Cohomology Intersection)
                    else if (mode === 4) {
                        const pulse = 0.5 + 0.5*Math.sin(time * 2);
                        
                        // Œ± form (vertical band)
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 0.25 + 0.1*pulse;
                        ctx.fillRect(cx-12, cy-28, 24, 56);
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.6;
                        ctx.strokeRect(cx-12, cy-28, 24, 56);
                        
                        // Œ≤ form (horizontal band)
                        ctx.fillStyle = '#a855f7';
                        ctx.globalAlpha = 0.25 + 0.1*pulse;
                        ctx.fillRect(cx-28, cy-12, 56, 24);
                        ctx.strokeStyle = '#a855f7';
                        ctx.globalAlpha = 0.6;
                        ctx.strokeRect(cx-28, cy-12, 56, 24);
                        
                        // Intersection (the cup product) - pulsing
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.5 + 0.4*pulse;
                        ctx.fillRect(cx-12, cy-12, 24, 24);
                        
                        // Labels
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œ±', cx-5, cy-32);
                        ctx.fillStyle = '#a855f7';
                        ctx.fillText('Œ≤', cx+32, cy+4);
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('Œ± ‚å£ Œ≤', cx-14, cy+42);
                    }
                },

                // 8. CHARACTERISTIC CLASSES - DYNAMIC HAIRY BALL & BUNDLES
                'characteristic-classes': (ctx, time, mode) => {
                    ctx.strokeStyle = '#10b981'; ctx.fillStyle = '#10b981';

                    // Mode 0: The Hairy Ball Theorem (Vector Field with Moving Singularity)
                    if (mode === 0) {
                        const r = 28;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
                        ctx.globalAlpha = 0.15; ctx.fill();
                        ctx.globalAlpha = 0.4; ctx.stroke();

                        // Moving singularity (zero of vector field)
                        const singX = Math.cos(time * 0.7) * 12;
                        const singY = Math.sin(time * 0.7) * 12;

                        // Draw vector field around singularity
                        for(let x=-24; x<=24; x+=8) {
                            for(let y=-24; y<=24; y+=8) {
                                if (x*x + y*y > r*r - 20) continue;
                                
                                const dx = x - singX;
                                const dy = y - singY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const ang = Math.atan2(dy, dx) + Math.PI/2; // Vortex
                                const len = Math.min(6, 40 / (dist + 5));
                                
                                ctx.strokeStyle = `hsla(${160 - dist*2}, 70%, 50%, ${0.3 + 0.4/(dist*0.1+1)})`;
                                ctx.beginPath();
                                ctx.moveTo(cx+x, cy+y);
                                ctx.lineTo(cx+x + Math.cos(ang)*len, cy+y + Math.sin(ang)*len);
                                ctx.stroke();
                            }
                        }
                        
                        // The Singularity (pulsing)
                        const pulse = 0.5 + 0.5*Math.sin(time*4);
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.7 + pulse*0.3;
                        ctx.beginPath(); ctx.arc(cx+singX, cy+singY, 3 + pulse, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Index = 2', cx-22, cy+38);
                    }
                    
                    // Mode 1: Chern Class (Complex Line Bundle Twist)
                    else if (mode === 1) {
                        const twists = 2;
                        
                        // Base circle (manifold)
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy+8, 28, 12, 0, 0, Math.PI*2);
                        ctx.stroke();
                        
                        // Fiber bundle visualization with twist
                        for(let i=0; i<30; i++) {
                            const t = i/30;
                            const ang = t * Math.PI*2;
                            
                            const bx = cx + Math.cos(ang)*28;
                            const by = cy + 8 + Math.sin(ang)*12;
                            
                            // Fiber twist animation
                            const twistAng = ang * twists + time * 2;
                            const fiberLen = 18 + Math.sin(ang*4 + time*2)*3;
                            const fx = Math.cos(twistAng) * 5;
                            
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + fx, by - fiberLen);
                            ctx.strokeStyle = `hsla(${150 + t*60}, 70%, 55%, ${0.3 + Math.abs(Math.cos(twistAng))*0.4})`;
                            ctx.stroke();
                        }
                        
                        // Highlight twisting point
                        const hlAng = time * 0.8;
                        const hlx = cx + Math.cos(hlAng)*28;
                        const hly = cy + 8 + Math.sin(hlAng)*12;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(hlx, hly, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '11px serif';
                        ctx.fillText(`c‚ÇÅ = ${twists}`, cx-14, cy-22);
                    }
                    
                    // Mode 2: Stiefel-Whitney (M√∂bius Strip Ant Walk)
                    else if (mode === 2) {
                        const pathR = 24;
                        const t = time * 0.4;
                        const u = t * Math.PI * 2;
                        
                        // Draw M√∂bius strip wireframe
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.25;
                        for(let i=0; i<50; i++) {
                            const ut = (i/50)*Math.PI*2;
                            const x = (pathR + 6*Math.cos(ut/2))*Math.cos(ut);
                            const y = (pathR + 6*Math.cos(ut/2))*Math.sin(ut);
                            ctx.beginPath(); ctx.arc(cx+x, cy+y*0.55, 1, 0, Math.PI*2); ctx.fill();
                        }
                        
                        // The Ant position on strip
                        const ax = (pathR)*Math.cos(u);
                        const ay = (pathR)*Math.sin(u) * 0.55;
                        
                        // Normal vector flips direction after 2œÄ
                        const loopCount = Math.floor(t);
                        const flip = loopCount % 2 === 0 ? 1 : -1;
                        const normalLen = 14;
                        
                        // Ant body
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx+ax, cy+ay, 4, 0, Math.PI*2); ctx.fill();
                        
                        // Normal vector (flips color when inverted)
                        ctx.strokeStyle = flip > 0 ? '#4ecdc4' : '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cx+ax, cy+ay);
                        ctx.lineTo(cx+ax, cy+ay - normalLen*flip);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        // Arrow head
                        ctx.beginPath();
                        ctx.moveTo(cx+ax - 4, cy+ay - normalLen*flip + 4*flip);
                        ctx.lineTo(cx+ax, cy+ay - normalLen*flip);
                        ctx.lineTo(cx+ax + 4, cy+ay - normalLen*flip + 4*flip);
                        ctx.stroke();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = flip > 0 ? '#4ecdc4' : '#ff6b6b';
                        ctx.fillText('w‚ÇÅ ‚â† 0', cx-16, cy+38);
                    }
                    
                    // Mode 3: Pontryagin (4k Signature Manifold)
                    else if (mode === 3) {
                        // Animated 4-manifold blob
                        ctx.beginPath();
                        for(let i=0; i<=Math.PI*2; i+=0.15) {
                            const r = 24 + Math.cos(i*4 + time)*5 + Math.sin(i*3 - time*1.5)*3;
                            const x = cx + Math.cos(i)*r;
                            const y = cy + Math.sin(i)*r;
                            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 0.2;
                        ctx.fill();
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        // Internal structure lines
                        for(let i=0; i<4; i++) {
                            const ang = time*0.3 + i*Math.PI/2;
                            ctx.globalAlpha = 0.2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy);
                            ctx.lineTo(cx + Math.cos(ang)*20, cy + Math.sin(ang)*20);
                            ctx.stroke();
                        }
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillText('Sign(M) = p‚ÇÅ/3', cx-30, cy+38);
                    }
                    // Mode 4: Euler Class (Gauss-Bonnet Curvature)
                    else if (mode === 4) {
                        // Sphere with curvature visualization
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath(); ctx.arc(cx, cy-5, 22, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.5;
                        ctx.stroke();
                        
                        // Curvature field (arrows pointing outward)
                        for(let i=0; i<8; i++) {
                            const ang = i*Math.PI/4 + time*0.3;
                            const bx = cx + Math.cos(ang)*22;
                            const by = cy - 5 + Math.sin(ang)*22;
                            const len = 8 + Math.sin(time*2 + i)*2;
                            
                            ctx.strokeStyle = '#4ecdc4';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(ang)*len, by + Math.sin(ang)*len);
                            ctx.stroke();
                        }
                        
                        // Holes (genus)
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.ellipse(cx-10, cy-5, 5, 2.5, 0, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(cx+10, cy-5, 5, 2.5, 0, 0, Math.PI*2); ctx.stroke();
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillText('‚à´K dA = 2œÄœá', cx-28, cy+32);
                    }
                },

                // 9. HOPF FIBRATION
                'hopf-fibration': (ctx, time, mode) => {
                    ctx.strokeStyle = '#10b981'; ctx.fillStyle = '#10b981';
                    
                    // Mode 0: Villarceau Circles (linked fibers)
                    if (mode === 0) {
                        const numFibers = 5;
                        for(let f=0; f<numFibers; f++) {
                            const phase = (f/numFibers)*Math.PI*2;
                            const x1 = cx + Math.cos(time*0.6 + phase)*12;
                            const tilt = time*0.6 + phase;
                            const z = Math.sin(time*0.6 + phase);
                            ctx.beginPath();
                            ctx.ellipse(x1, cy, 25, 10, tilt, 0, Math.PI*2);
                            ctx.strokeStyle = z > 0 ? '#10b981' : '#fff';
                            ctx.lineWidth = z > 0 ? 2 : 1;
                            ctx.globalAlpha = 0.3 + Math.abs(z)*0.5;
                            ctx.stroke();
                        }
                        const pt = time*2.5;
                        const mainX = cx + Math.cos(time*0.6)*12;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(mainX + Math.cos(pt)*20, cy + Math.sin(pt)*8, 3, 0, Math.PI*2); ctx.fill();
                    }
                    // Mode 1: S¬≥ ‚Üí S¬≤ projection
                    else if (mode === 1) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy-15, 18, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(cx, cy+18, 15, 0, Math.PI*2); ctx.stroke();
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([3,3]);
                        ctx.beginPath(); ctx.moveTo(cx, cy-15); ctx.lineTo(cx, cy+18); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('S¬≥', cx+22, cy-15);
                        ctx.fillText('S¬≤', cx+22, cy+18);
                    }
                    // Mode 2: Linking Number
                    else if (mode === 2) {
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.arc(cx-8, cy, 18, 0, Math.PI*2); ctx.stroke();
                        ctx.strokeStyle = '#a855f7';
                        ctx.beginPath(); ctx.arc(cx+8, cy, 18, 0, Math.PI*2); ctx.stroke();
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Link = 1', cx-22, cy+35);
                    }
                    // Mode 3: Stereographic Projection
                    else if (mode === 3) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy-8, 20, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx-35, cy+25); ctx.lineTo(cx+35, cy+25); ctx.stroke();
                        ctx.setLineDash([3,3]);
                        ctx.strokeStyle = '#fff';
                        const t = Math.sin(time)*0.8;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy-28);
                        ctx.lineTo(cx + t*30, cy+25);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    // Mode 4: Torus Decomposition
                    else if (mode === 4) {
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath(); ctx.ellipse(cx, cy, 32, 15, 0, 0, Math.PI*2); ctx.stroke();
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.ellipse(cx, cy, 18, 8, 0, 0, Math.PI*2); ctx.stroke();
                        const a = time;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(cx + Math.cos(a)*25, cy + Math.sin(a)*12, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                },

                // 10. GENERALIZATIONS (Higher Hopf)
                'generalizations': (ctx, time, mode) => {
                    ctx.strokeStyle = '#10b981'; ctx.fillStyle = '#10b981';
                    
                    // Mode 0: The Octonions (8D) - Rotating 4D Tesseract Shadow
                    if (mode === 0) {
                        const size = 22;
                        const t = time * 0.4;
                        const vertices = [];
                        
                        // Generate 16 vertices of 4D hypercube
                        for(let i=0; i<16; i++) {
                            let x = (i&1)?1:-1, y = (i&2)?1:-1;
                            let z = (i&4)?1:-1, w = (i&8)?1:-1;
                            
                            // 4D Rotations (ZW and XW planes)
                            let x2 = x*Math.cos(t) - w*Math.sin(t);
                            let w2 = x*Math.sin(t) + w*Math.cos(t);
                            let z2 = z*Math.cos(t*0.7) - w2*Math.sin(t*0.7);
                            
                            // Perspective projection to 2D
                            let scale = 2.5 / (3.5 - z2*0.5);
                            vertices.push({x: x2*scale*size + cx, y: y*scale*size + cy, depth: z2});
                        }
                        
                        // Draw edges (connect vertices with Hamming distance 1)
                        for(let i=0; i<16; i++) {
                            for(let j=i+1; j<16; j++) {
                                let diff = i ^ j;
                                if ((diff & (diff - 1)) === 0) {
                                    const avgDepth = (vertices[i].depth + vertices[j].depth) / 2;
                                    ctx.globalAlpha = 0.2 + avgDepth * 0.2;
                                    ctx.strokeStyle = `hsl(${160 + avgDepth*30}, 70%, 50%)`;
                                    ctx.beginPath();
                                    ctx.moveTo(vertices[i].x, vertices[i].y);
                                    ctx.lineTo(vertices[j].x, vertices[j].y);
                                    ctx.stroke();
                                }
                            }
                        }
                        ctx.font = '9px monospace';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('ùïÜ (dim 8)', cx - 22, cy + 38);
                    }
                    // Mode 1: S¬π‚Åµ ‚Üí S‚Å∏ (Nested Fibration Flow with particles)
                    else if (mode === 1) {
                        const fibers = 8;
                        for(let i=0; i<fibers; i++) {
                            const phase = i * (Math.PI*2/fibers) + time * 0.8;
                            const r = 22 + 4 * Math.sin(time * 2 + i);
                            
                            ctx.beginPath();
                            for(let j=0; j<=50; j++) {
                                const ang = (j/50) * Math.PI*2;
                                const x = cx + Math.cos(ang + phase) * r * Math.sin(ang * 3 + time);
                                const y = cy + Math.sin(ang) * (r * 0.5);
                                if(j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                            }
                            ctx.strokeStyle = `hsla(${160 + i*12}, 80%, 55%, 0.5)`;
                            ctx.stroke();
                        }
                        // Flowing particle
                        const pt = time * 2;
                        const px = cx + Math.cos(pt) * 20 * Math.sin(pt * 3);
                        const py = cy + Math.sin(pt) * 12;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('S¬π‚Åµ ‚Üí S‚Å∏', cx-20, cy-32);
                    }
                    // Mode 2: Bott Periodicity (Clockwork with rotating hand)
                    else if (mode === 2) {
                        const n = 8;
                        const r = 26;
                        
                        ctx.strokeStyle = '#333';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                        
                        const handAngle = (time * 0.5) % (Math.PI*2);
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + Math.cos(handAngle - Math.PI/2)*r*0.85, cy + Math.sin(handAngle - Math.PI/2)*r*0.85);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        const activeIdx = Math.floor((handAngle / (Math.PI*2)) * n) % n;
                        const labels = ['œÄ‚ÇôO', '‚Ñ§‚ÇÇ', '‚Ñ§‚ÇÇ', '0', '‚Ñ§', '0', '0', '0'];
                        
                        for(let i=0; i<n; i++) {
                            const ang = i * (Math.PI*2/n) - Math.PI/2;
                            const px = cx + Math.cos(ang) * r;
                            const py = cy + Math.sin(ang) * r;
                            
                            ctx.fillStyle = i === activeIdx ? '#fff' : '#10b981';
                            ctx.globalAlpha = i === activeIdx ? 1.0 : 0.4;
                            ctx.beginPath(); ctx.arc(px, py, i === activeIdx ? 4 : 3, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.font = '11px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText(labels[activeIdx], cx-8, cy+5);
                    }
                    // Mode 3: Exotic Spheres (Milnor's Twisted Gluing)
                    else if (mode === 3) {
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath(); ctx.arc(cx, cy-6, 20, Math.PI, 0); ctx.stroke();
                        ctx.beginPath(); ctx.arc(cx, cy+6, 20, 0, Math.PI); ctx.stroke();
                        
                        // Twisted equator with flowing distortion
                        const twist = time * 2;
                        ctx.beginPath();
                        for(let i=0; i<=60; i++) {
                            const t = (i/60) * Math.PI*2;
                            const x = cx + Math.cos(t) * 20;
                            const y = cy + Math.sin(t * 3 + twist) * 4;
                            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.9;
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        // Glowing points at twist extrema
                        for(let i=0; i<3; i++) {
                            const t = i * Math.PI * 2/3 + twist/3;
                            const px = cx + Math.cos(t) * 20;
                            const py = cy + Math.sin(t * 3 + twist) * 4;
                            ctx.fillStyle = '#4ecdc4';
                            ctx.globalAlpha = 0.5 + 0.5*Math.sin(time*3 + i);
                            ctx.beginPath(); ctx.arc(px, py, 2, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Exotic Œ£‚Å∑', cx-22, cy+35);
                    }
                    // Mode 4: Adams H-Spaces (Growing dimension bars)
                    else if (mode === 4) {
                        const dims = [1, 2, 4, 8];
                        const pulse = (Math.sin(time * 2) + 1) / 2;
                        
                        dims.forEach((d, i) => {
                            const w = d * 6 * (0.7 + pulse * 0.3);
                            const y = cy + 18 - i * 14;
                            
                            // Gradient bar
                            const grad = ctx.createLinearGradient(cx - w/2, y, cx + w/2, y);
                            grad.addColorStop(0, 'rgba(16, 185, 129, 0.2)');
                            grad.addColorStop(0.5, 'rgba(16, 185, 129, 0.6)');
                            grad.addColorStop(1, 'rgba(16, 185, 129, 0.2)');
                            ctx.fillStyle = grad;
                            ctx.fillRect(cx - w/2, y, w, 10);
                            
                            // Border
                            ctx.strokeStyle = '#10b981';
                            ctx.globalAlpha = 0.4 + i * 0.15;
                            ctx.strokeRect(cx - w/2, y, w, 10);
                            
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 1.0;
                            ctx.font = '8px monospace';
                            ctx.fillText(`‚Ñù${d}`, cx + w/2 + 5, y + 8);
                        });
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Normed Division Algebras', cx-45, cy+38);
                    }
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ANALYSIS NODES (Blue Theme: #3b82f6) - 3 nodes √ó 5 modes = 15 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 11. CALCULUS - HIGHLY DYNAMIC
                'calculus': (ctx, time, mode) => {
                    ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = '#3b82f6';

                    // Mode 0: Derivative as tangent (Sliding point with velocity vector)
                    if (mode === 0) {
                        // Draw curve
                        ctx.beginPath();
                        for(let x=0; x<width; x+=2) {
                            const nx = (x/width)*4 - 2;
                            const y = cy - (Math.sin(nx*1.5)*20 + nx*5);
                            if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        // Sliding point on curve
                        const t = (time*0.5) % 4 - 2;
                        const px = (t+2)/4 * width;
                        const py = cy - (Math.sin(t*1.5)*20 + t*5);
                        
                        // Calculate derivative
                        const dt = 0.01;
                        const dy = (Math.sin((t+dt)*1.5)*20 + (t+dt)*5) - (Math.sin(t*1.5)*20 + t*5);
                        const slope = -dy / (dt * width / 4);
                        
                        // Draw tangent line
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(px-35, py - slope*35);
                        ctx.lineTo(px+35, py + slope*35);
                        ctx.stroke();
                        
                        // Draw point
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        
                        // Draw velocity vector (perpendicular visualization)
                        const vecLen = Math.abs(slope) * 20;
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + 15, py + slope * 15);
                        ctx.stroke();
                        
                        // Arrow head
                        const arrowAngle = Math.atan(slope);
                        ctx.beginPath();
                        ctx.moveTo(px + 15, py + slope * 15);
                        ctx.lineTo(px + 15 - 5*Math.cos(arrowAngle - 0.4), py + slope * 15 - 5*Math.sin(arrowAngle - 0.4));
                        ctx.stroke();
                    }
                    // Mode 1: Integration (Animated Refining Riemann Sums!)
                    else if (mode === 1) {
                        // Cycle through increasing number of bars
                        const cycle = time % 4;
                        const numBars = Math.pow(2, Math.floor(cycle) + 2); // 4, 8, 16, 32 bars
                        const barWidth = 60 / numBars;
                        
                        const fn = (x) => Math.abs(Math.sin(x * 0.08) * 25) + 5;
                        
                        // Draw bars with slight animation
                        ctx.globalAlpha = 0.4;
                        for(let i=0; i<numBars; i++) {
                            const x = 10 + i * barWidth;
                            const midX = x + barWidth/2;
                            const h = fn(midX);
                            
                            // Slight wave animation on bar heights
                            const waveOffset = Math.sin(time * 3 + i * 0.3) * 2;
                            
                            // Color gradient based on position
                            const hue = 200 + (i / numBars) * 40;
                            ctx.fillStyle = `hsla(${hue}, 70%, 55%, 0.5)`;
                            ctx.fillRect(x, cy + 18 - h - waveOffset, barWidth - 1, h + waveOffset);
                            
                            ctx.strokeStyle = '#3b82f6';
                            ctx.globalAlpha = 0.6;
                            ctx.strokeRect(x, cy + 18 - h - waveOffset, barWidth - 1, h + waveOffset);
                        }
                        
                        // Draw actual curve on top
                        ctx.beginPath();
                        for(let x=10; x<width-10; x++) {
                            const y = cy + 18 - fn(x);
                            if(x===10) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                        
                        // Label showing bar count
                        ctx.fillStyle = '#3b82f6';
                        ctx.globalAlpha = 1.0;
                        ctx.font = '10px serif';
                        ctx.fillText('n = ' + numBars, cx - 15, cy - 25);
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚à´ f dx', cx - 12, cy + 35);
                    }
                    // Mode 2: Limits (Squeeze Theorem with Converging Bounds)
                    else if (mode === 2) {
                        const convergeCycle = time % 3;
                        const d = 30 * Math.exp(-convergeCycle);
                        
                        // Draw converging bounds
                        ctx.strokeStyle = '#888';
                        ctx.globalAlpha = 0.4;
                        ctx.setLineDash([3,3]);
                        ctx.beginPath(); ctx.arc(cx, cy, d + 5, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Oscillating point being squeezed
                        const oscAngle = time * 8;
                        const oscR = d * 0.8;
                        const px = cx + Math.cos(oscAngle) * oscR;
                        const py = cy + Math.sin(oscAngle * 1.3) * oscR * 0.5;
                        
                        // Trail effect
                        ctx.globalAlpha = 0.3;
                        for(let i=1; i<8; i++) {
                            const trailAngle = oscAngle - i * 0.2;
                            const trailR = d * 0.8;
                            const tx = cx + Math.cos(trailAngle) * trailR;
                            const ty = cy + Math.sin(trailAngle * 1.3) * trailR * 0.5;
                            ctx.fillStyle = '#3b82f6';
                            ctx.beginPath();
                            ctx.arc(tx, ty, 2 - i * 0.2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Main point
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        
                        // Limit point at center
                        ctx.fillStyle = '#ff0055';
                        ctx.globalAlpha = d < 3 ? 1.0 : 0.3;
                        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('lim ‚Üí L', cx-15, cy+35);
                    }
                    // Mode 3: Taylor Series (Progressive Term Addition)
                    else if (mode === 3) {
                        const terms = Math.floor(time) % 6 + 1;
                        
                        // Draw actual sin curve (ghost)
                        ctx.strokeStyle = '#ffffff44';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        for(let x=0; x<width; x+=2) {
                            const nx = (x-cx)/15;
                            ctx.lineTo(x, cy - Math.sin(nx)*22);
                        }
                        ctx.stroke();
                        
                        // Draw Taylor approximation
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        for(let x=0; x<width; x+=2) {
                            const nx = (x-cx)/15;
                            let y = 0;
                            for(let n=0; n<terms; n++) {
                                const sign = n%2===0 ? 1 : -1;
                                const fact = [1, 1, 2, 6, 24, 120, 720, 5040][2*n+1] || 1;
                                y += sign * Math.pow(nx, 2*n+1) / fact;
                            }
                            y = Math.max(-40, Math.min(40, y * 22));
                            ctx.lineTo(x, cy - y);
                        }
                        ctx.stroke();
                        
                        // Animated term indicator
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.8;
                        ctx.font = '10px monospace';
                        let termStr = '';
                        for(let n=0; n<terms; n++) {
                            const sign = n%2===0 ? '+' : '-';
                            termStr += (n===0?'':sign) + 'x^' + (2*n+1);
                        }
                        ctx.fillText(terms + ' terms', cx-20, cy-28);
                    }
                    // Mode 4: Fundamental Theorem (Area Accumulator)
                    else if (mode === 4) {
                        // Moving integral bound
                        const t = (time % 4) / 4;
                        const endX = 15 + t * 50;
                        
                        // Draw function
                        ctx.strokeStyle = '#3b82f6';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        for(let x=10; x<width-10; x++) {
                            const y = cy - 5 - Math.abs(Math.sin(x * 0.1)) * 20;
                            if(x===10) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Accumulating area
                        ctx.fillStyle = '#3b82f6';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(15, cy + 15);
                        for(let x=15; x<=endX; x++) {
                            const y = cy - 5 - Math.abs(Math.sin(x * 0.1)) * 20;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(endX, cy + 15);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Moving boundary line
                        ctx.strokeStyle = '#ff0055';
                        ctx.globalAlpha = 1.0;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(endX, cy - 5 - Math.abs(Math.sin(endX * 0.1)) * 20);
                        ctx.lineTo(endX, cy + 15);
                        ctx.stroke();
                        
                        // F(x) value indicator
                        const area = t * 35;
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px serif';
                        ctx.fillText('F(x) = ' + area.toFixed(0), cx - 20, cy + 32);
                    }
                },

                // 12. COMPLEX NUMBERS
                'complex-numbers': (ctx, time, mode) => {
                    ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = '#3b82f6';
                    
                    // Mode 0: Argand Plane
                    if (mode === 0) {
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.moveTo(cx-35, cy); ctx.lineTo(cx+35, cy); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx, cy-35); ctx.lineTo(cx, cy+35); ctx.stroke();
                        const a = time;
                        const r = 25;
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + Math.cos(a)*r, cy - Math.sin(a)*r);
                        ctx.stroke();
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(cx + Math.cos(a)*r, cy - Math.sin(a)*r, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('z = re^iŒ∏', cx+8, cy-25);
                    }
                    // Mode 1: Euler's Formula (e^iœÄ = -1)
                    else if (mode === 1) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy, 25, 0, Math.PI*2); ctx.stroke();
                        const px = cx + Math.cos(time)*25;
                        const py = cy - Math.sin(time)*25;
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('e^iœÄ + 1 = 0', cx-28, cy+40);
                    }
                    // Mode 2: Roots of Unity
                    else if (mode === 2) {
                        const n = 5;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath(); ctx.arc(cx, cy, 25, 0, Math.PI*2); ctx.stroke();
                        ctx.globalAlpha = 0.8;
                        for(let i=0; i<n; i++) {
                            const a = time*0.5 + i*(Math.PI*2/n);
                            ctx.fillStyle = i===0 ? '#fff' : '#3b82f6';
                            ctx.beginPath();
                            ctx.arc(cx + Math.cos(a)*25, cy - Math.sin(a)*25, 4, 0, Math.PI*2);
                            ctx.fill();
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('z‚Åµ = 1', cx-12, cy+40);
                    }
                    // Mode 3: Riemann Sphere
                    else if (mode === 3) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy-8, 20, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx-35, cy+20); ctx.lineTo(cx+35, cy+20); ctx.stroke();
                        const t = Math.sin(time)*0.7;
                        ctx.setLineDash([3,3]);
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        ctx.moveTo(cx, cy-28);
                        ctx.lineTo(cx + t*35, cy+20);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#ff0055';
                        ctx.beginPath(); ctx.arc(cx, cy-28, 3, 0, Math.PI*2); ctx.fill();
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚àû', cx+5, cy-28);
                    }
                    // Mode 4: Holomorphic Functions
                    else if (mode === 4) {
                        ctx.globalAlpha = 0.5;
                        for(let i=-1; i<=1; i++) {
                            for(let j=-1; j<=1; j++) {
                                const rot = time + (i+j)*0.2;
                                ctx.save();
                                ctx.translate(cx + i*20, cy + j*15);
                                ctx.rotate(rot);
                                ctx.strokeRect(-6, -6, 12, 12);
                                ctx.restore();
                            }
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚àÇf/‚àÇzÃÑ = 0', cx-18, cy+38);
                    }
                },

                // 13. REAL ANALYSIS
                'real-analysis': (ctx, time, mode) => {
                    ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = '#3b82f6';

                    // Mode 0: Epsilon-Delta Definition
                    if (mode === 0) {
                        const eps = 20 * (0.3 + 0.7*Math.exp(-time*0.5));
                        ctx.fillStyle = '#3b82f6' + '33';
                        ctx.fillRect(cx-30, cy-eps, 60, eps*2);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.setLineDash([4,4]);
                        ctx.beginPath();
                        ctx.moveTo(cx-35, cy-eps); ctx.lineTo(cx+35, cy-eps);
                        ctx.moveTo(cx-35, cy+eps); ctx.lineTo(cx+35, cy+eps);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath(); ctx.moveTo(cx-35, cy); ctx.lineTo(cx+35, cy); ctx.stroke();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚àÄŒµ>0 ‚àÉŒ¥>0', cx-25, cy+35);
                    }
                    // Mode 1: Cauchy Sequence
                    else if (mode === 1) {
                        for(let i=1; i<=12; i++) {
                            const x = cx - 35 + 70*(1 - 1/i);
                            const y = cy + (i%2===0 ? 1 : -1) * 15/i;
                            ctx.globalAlpha = 0.3 + i*0.05;
                            ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx+30, cy, 4, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('|x‚Çô-x‚Çò|<Œµ', cx-22, cy+35);
                    }
                    // Mode 2: Bolzano-Weierstrass
                    else if (mode === 2) {
                        ctx.globalAlpha = 0.3;
                        ctx.strokeRect(cx-30, cy-25, 60, 50);
                        for(let i=0; i<8; i++) {
                            const x = cx + Math.sin(time + i*0.8)*25;
                            const y = cy + Math.cos(time*1.3 + i)*20;
                            ctx.fillStyle = '#3b82f6';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('bounded ‚Üí subsequence', cx-45, cy+40);
                    }
                    // Mode 3: Dedekind Cut
                    else if (mode === 3) {
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath(); ctx.moveTo(cx-40, cy); ctx.lineTo(cx+40, cy); ctx.stroke();
                        const cut = cx + Math.sin(time)*20;
                        ctx.fillStyle = '#3b82f6';
                        ctx.fillRect(cx-40, cy-3, cut-(cx-40), 6);
                        ctx.fillStyle = '#a855f7';
                        ctx.fillRect(cut, cy-3, (cx+40)-cut, 6);
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(cut, cy, 4, 0, Math.PI*2); ctx.fill();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('L | R', cx-10, cy+25);
                    }
                    // Mode 4: Lebesgue Measure
                    else if (mode === 4) {
                        for(let i=0; i<8; i++) {
                            ctx.globalAlpha = 0.3 + Math.sin(time + i)*0.2;
                            ctx.fillRect(cx-30, cy-20+i*5, 60, 3);
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œº(E)', cx-12, cy+30);
                    }
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ALGEBRA NODES (Purple Theme: #a855f7) - 4 nodes √ó 5 modes = 20 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 14. LINEAR ALGEBRA
                'linear-algebra-basic': (ctx, time, mode) => {
                    ctx.strokeStyle = '#a855f7'; ctx.fillStyle = '#a855f7';

                    // Mode 0: Vector Space (Basis vectors)
                    if (mode === 0) {
                        ctx.globalAlpha = 0.3;
                        for(let i=-3; i<=3; i++) {
                            ctx.beginPath(); ctx.moveTo(cx-40, cy+i*12); ctx.lineTo(cx+40, cy+i*12); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(cx+i*12, cy-35); ctx.lineTo(cx+i*12, cy+35); ctx.stroke();
                        }
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+30, cy); ctx.stroke();
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy-30); ctx.stroke();
                    }
                    // Mode 1: Eigenvalues (Stretching)
                    else if (mode === 1) {
                        const stretch = 1 + 0.4*Math.sin(time*2);
                        ctx.globalAlpha = 0.4;
                        ctx.setLineDash([4,4]);
                        ctx.beginPath(); ctx.moveTo(cx-35, cy); ctx.lineTo(cx+35, cy); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + 25*stretch, cy); ctx.stroke();
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Av = Œªv', cx-15, cy+30);
                    }
                    // Mode 2: Determinant (Area scaling)
                    else if (mode === 2) {
                        const s = 1 + 0.4*Math.sin(time);
                        ctx.globalAlpha = 0.3;
                        ctx.strokeRect(cx-15, cy-15, 30, 30);
                        ctx.fillStyle = '#a855f7' + '44';
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.scale(s, 1/s);
                        ctx.fillRect(-15, -15, 30, 30);
                        ctx.restore();
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('det(A)', cx-15, cy+35);
                    }
                    // Mode 3: Matrix Transformation
                    else if (mode === 3) {
                        const angle = time*0.5;
                        ctx.globalAlpha = 0.3;
                        for(let i=-2; i<=2; i++) {
                            for(let j=-2; j<=2; j++) {
                                const x = i*12;
                                const y = j*12;
                                const tx = x*Math.cos(angle) - y*Math.sin(angle);
                                const ty = x*Math.sin(angle) + y*Math.cos(angle);
                                ctx.beginPath(); ctx.arc(cx+tx, cy+ty, 2, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }
                    // Mode 4: Dual Space
                    else if (mode === 4) {
                        for(let i=-2; i<=2; i++) {
                            const y = cy + i*10 + Math.sin(time)*5;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath(); ctx.moveTo(cx-30, y); ctx.lineTo(cx+30, y); ctx.stroke();
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('V*', cx-8, cy-30);
                    }
                },

                // 15. ABSTRACT ALGEBRA - HIGHLY DYNAMIC
                'abstract-algebra': (ctx, time, mode) => {
                    ctx.strokeStyle = '#a855f7'; ctx.fillStyle = '#a855f7';

                    // Mode 0: Permutation Shell Game (Elements Actually Swap!)
                    if (mode === 0) {
                        const pos = [-22, 0, 22];
                        const cycleTime = 1.5;
                        const t = (time % cycleTime) / cycleTime;
                        const step = Math.floor(time / cycleTime) % 3;
                        
                        // Smooth easing
                        const ease = t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
                        
                        // Draw slot markers
                        ctx.fillStyle = '#333';
                        pos.forEach(p => { 
                            ctx.beginPath(); 
                            ctx.arc(cx+p, cy+15, 4, 0, Math.PI*2); 
                            ctx.fill(); 
                        });
                        
                        // Calculate ball positions based on current permutation step
                        const colors = ['#ff6b6b', '#4ecdc4', '#fbbf24'];
                        let ballPos = [0, 1, 2]; // indices into pos array
                        
                        // Apply completed permutations
                        for(let s=0; s<step; s++) {
                            const temp = ballPos[0];
                            ballPos[0] = ballPos[1];
                            ballPos[1] = ballPos[2];
                            ballPos[2] = temp;
                        }
                        
                        // Draw balls with current swap animation
                        colors.forEach((c, i) => {
                            let x, y;
                            const baseX = cx + pos[ballPos[i]];
                            
                            // Animate the current swap
                            if (step === 0 || step === 1 || step === 2) {
                                const swapFrom = i;
                                const swapTo = (i + 1) % 3;
                                if (ballPos[i] === swapFrom && t > 0) {
                                    const fromX = cx + pos[swapFrom];
                                    const toX = cx + pos[swapTo];
                                    x = fromX + (toX - fromX) * ease;
                                    y = cy + 15 - Math.sin(ease * Math.PI) * 20;
                                } else {
                                    x = baseX;
                                    y = cy + 15;
                                }
                            } else {
                                x = baseX;
                                y = cy + 15;
                            }
                            
                            ctx.fillStyle = c;
                            ctx.globalAlpha = 0.9;
                            ctx.beginPath(); 
                            ctx.arc(x, y, 6, 0, Math.PI*2); 
                            ctx.fill();
                            
                            // Add glow effect
                            ctx.globalAlpha = 0.3;
                            ctx.beginPath();
                            ctx.arc(x, y, 10, 0, Math.PI*2);
                            ctx.fill();
                        });
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('S‚ÇÉ Cycle', cx-20, cy-20);
                    }
                    // Mode 1: Ring Operations (Clock Arithmetic with Racing Hands)
                    else if (mode === 1) {
                        const n = 12;
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.arc(cx, cy, 28, 0, Math.PI*2); ctx.stroke();
                        
                        // Draw clock markers
                        for(let i=0; i<n; i++) {
                            const a = i*(Math.PI*2/n) - Math.PI/2;
                            const inner = i % 3 === 0 ? 22 : 24;
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.moveTo(cx + Math.cos(a)*inner, cy + Math.sin(a)*inner);
                            ctx.lineTo(cx + Math.cos(a)*28, cy + Math.sin(a)*28);
                            ctx.stroke();
                        }
                        
                        // Addition hand (continuous rotation)
                        const addAngle = time * 1.5 - Math.PI/2;
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + Math.cos(addAngle)*22, cy + Math.sin(addAngle)*22);
                        ctx.stroke();
                        
                        // Multiplication hand (discrete jumps with smooth interpolation)
                        const multBase = Math.floor(time * 0.8);
                        const multFrac = (time * 0.8) % 1;
                        const multVal = (multBase * 5) % n;
                        const nextVal = ((multBase + 1) * 5) % n;
                        const multAngle = (multVal + (nextVal - multVal) * Math.pow(multFrac, 0.3)) * (Math.PI*2/n) - Math.PI/2;
                        
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + Math.cos(multAngle)*16, cy + Math.sin(multAngle)*16);
                        ctx.stroke();
                        
                        // Center dot
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '9px monospace';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚Ñ§‚ÇÅ‚ÇÇ', cx-10, cy+38);
                    }
                    // Mode 2: Homomorphism (Flowing Transformation Tunnel)
                    else if (mode === 2) {
                        // Source group (chaotic motion)
                        ctx.strokeStyle = '#a855f7';
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.arc(cx-28, cy, 20, 0, Math.PI*2); ctx.stroke();
                        
                        // Target group (structured)
                        ctx.beginPath(); ctx.arc(cx+28, cy, 16, 0, Math.PI*2); ctx.stroke();
                        
                        // Transformation funnel
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.moveTo(cx-8, cy-12);
                        ctx.lineTo(cx+12, cy-8);
                        ctx.moveTo(cx-8, cy+12);
                        ctx.lineTo(cx+12, cy+8);
                        ctx.stroke();
                        
                        // Particles flowing through homomorphism
                        for(let i=0; i<4; i++) {
                            const phase = (time * 0.8 + i * 0.25) % 1;
                            
                            // Source: chaotic position
                            const srcAngle = time * 2 + i * 1.5;
                            const srcX = cx - 28 + Math.cos(srcAngle) * 12 * (1 - phase);
                            const srcY = cy + Math.sin(srcAngle * 1.3) * 8 * (1 - phase);
                            
                            // Target: structured position
                            const tgtAngle = (i / 4) * Math.PI * 2;
                            const tgtX = cx + 28 + Math.cos(tgtAngle) * 10 * phase;
                            const tgtY = cy + Math.sin(tgtAngle) * 10 * phase;
                            
                            // Interpolate position through funnel
                            const x = srcX * (1 - phase) + tgtX * phase;
                            const y = srcY * (1 - phase) + tgtY * phase;
                            
                            ctx.fillStyle = phase < 0.5 ? '#a855f7' : '#4ecdc4';
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(x, y, 3 - phase, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '11px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('œÜ', cx-3, cy-2);
                    }
                    // Mode 3: Kernel (Collapsing to Identity Singularity)
                    else if (mode === 3) {
                        // Pulsing collapse animation
                        const pulse = (Math.sin(time * 2) + 1) / 2;
                        const radius = 25 * pulse;
                        
                        // Elements spiraling inward
                        for(let i=0; i<8; i++) {
                            const baseAngle = (i / 8) * Math.PI * 2;
                            const spiralR = radius + 5 * Math.sin(time * 3 + i);
                            const angle = baseAngle + time * (1 - pulse);
                            
                            const x = cx + Math.cos(angle) * spiralR;
                            const y = cy + Math.sin(angle) * spiralR;
                            
                            // Color shifts to white as elements approach identity
                            const brightness = 1 - pulse;
                            ctx.fillStyle = `rgba(168, 85, 247, ${0.3 + brightness * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 3 - pulse * 2, 0, Math.PI*2);
                            ctx.fill();
                            
                            // Trail effect
                            ctx.globalAlpha = 0.2;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(cx, cy);
                            ctx.strokeStyle = '#a855f7';
                            ctx.stroke();
                        }
                        
                        // Identity element at center (grows as kernel collapses)
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.8 + pulse * 0.2;
                        ctx.beginPath();
                        ctx.arc(cx, cy, 4 + pulse * 3, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Ker œÜ ‚Üí e', cx-22, cy+35);
                    }
                    // Mode 4: Cosets (Stacking/Sliding Layers)
                    else if (mode === 4) {
                        const numCosets = 4;
                        const layerHeight = 18;
                        const offset = (time * 15) % (layerHeight * 2);
                        
                        // Draw coset layers sliding and stacking
                        for(let i=0; i<numCosets; i++) {
                            const baseY = cy - 25 + i * layerHeight;
                            const slideX = Math.sin(time * 1.5 + i * 0.8) * 8;
                            const y = baseY + (offset > layerHeight ? offset - layerHeight * 2 : 0);
                            
                            if (y < cy - 35 || y > cy + 30) continue;
                            
                            // Layer background
                            const hue = (i * 30 + time * 20) % 360;
                            ctx.fillStyle = `hsla(${270 + i * 15}, 70%, 60%, 0.3)`;
                            ctx.fillRect(cx - 25 + slideX, y, 50, layerHeight - 2);
                            
                            // Layer border
                            ctx.strokeStyle = '#a855f7';
                            ctx.globalAlpha = 0.6;
                            ctx.strokeRect(cx - 25 + slideX, y, 50, layerHeight - 2);
                            
                            // Coset label
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.8;
                            ctx.font = '9px serif';
                            ctx.fillText('g' + i + 'H', cx - 8 + slideX, y + 12);
                            
                            // Elements within coset (dots)
                            for(let j=0; j<3; j++) {
                                ctx.globalAlpha = 0.5;
                                ctx.beginPath();
                                ctx.arc(cx - 15 + j * 15 + slideX, y + 8, 2, 0, Math.PI*2);
                                ctx.fill();
                            }
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('G/H', cx-12, cy+40);
                    }
                },

                // 16. LIE GROUPS - HIGHLY DYNAMIC
                'lie-groups': (ctx, time, mode) => {
                    ctx.strokeStyle = '#a855f7'; ctx.fillStyle = '#a855f7';

                    // Mode 0: Continuous Symmetry (Flowing around the group manifold)
                    if (mode === 0) {
                        const r = 26;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                        
                        // Multiple particles flowing on the group
                        for(let i = 0; i < 5; i++) {
                            const angle = time * (1 + i * 0.15) + i * Math.PI * 0.4;
                            const px = cx + Math.cos(angle) * r;
                            const py = cy + Math.sin(angle) * r;
                            
                            ctx.fillStyle = i === 0 ? '#fff' : '#a855f7';
                            ctx.globalAlpha = i === 0 ? 1.0 : 0.5;
                            ctx.beginPath();
                            ctx.arc(px, py, i === 0 ? 4 : 3, 0, Math.PI*2);
                            ctx.fill();
                            
                            // Velocity vectors (tangent)
                            if(i === 0) {
                                const tangentAngle = angle + Math.PI/2;
                                ctx.strokeStyle = '#4ecdc4';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(px, py);
                                ctx.lineTo(px + Math.cos(tangentAngle) * 12, py + Math.sin(tangentAngle) * 12);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '11px serif';
                        ctx.fillStyle = '#a855f7';
                        ctx.fillText('G', cx - 4, cy + 4);
                    }
                    // Mode 1: Lie Algebra (Tangent Space with Flowing Generators)
                    else if (mode === 1) {
                        // The group (circle)
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.arc(cx + 22, cy, 22, 0, Math.PI*2); ctx.stroke();
                        
                        // Identity point
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx + 22, cy - 22, 3, 0, Math.PI*2); ctx.fill();
                        
                        // Tangent space (Lie algebra) as a line at identity
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(cx - 5, cy - 22);
                        ctx.lineTo(cx + 40, cy - 22);
                        ctx.stroke();
                        
                        // Animated vector in the Lie algebra
                        const vecLen = 15 + Math.sin(time * 2) * 8;
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.moveTo(cx + 22, cy - 22);
                        ctx.lineTo(cx + 22 + vecLen, cy - 22);
                        ctx.stroke();
                        
                        // Arrow head
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.moveTo(cx + 22 + vecLen, cy - 22);
                        ctx.lineTo(cx + 22 + vecLen - 5, cy - 25);
                        ctx.lineTo(cx + 22 + vecLen - 5, cy - 19);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('ùî§ = T‚ÇëG', cx - 5, cy + 15);
                    }
                    // Mode 2: Exponential Map (Active Flow from ùî§ to G)
                    else if (mode === 2) {
                        // Lie algebra (line)
                        ctx.strokeStyle = '#a855f7';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(cx - 38, cy);
                        ctx.lineTo(cx - 5, cy);
                        ctx.stroke();
                        
                        // Lie group (circle)
                        ctx.beginPath(); ctx.arc(cx + 22, cy, 20, 0, Math.PI*2); ctx.stroke();
                        
                        // Animated exponential map flow
                        const flowT = (time % 2) / 2; // 0 to 1
                        const ease = flowT < 0.5 ? 2*flowT*flowT : 1 - Math.pow(-2*flowT + 2, 2) / 2;
                        
                        // Starting point in algebra
                        const algX = cx - 25 + Math.sin(time) * 8;
                        
                        // Ending point on group
                        const groupAngle = Math.sin(time) * 0.8 - Math.PI/2;
                        const groupX = cx + 22 + Math.cos(groupAngle) * 20;
                        const groupY = cy + Math.sin(groupAngle) * 20;
                        
                        // Interpolate along curved path
                        const pathX = algX + (groupX - algX) * ease;
                        const pathY = cy - Math.sin(ease * Math.PI) * 18;
                        
                        // Draw flow curve
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([3, 3]);
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(algX, cy);
                        ctx.quadraticCurveTo(cx, cy - 25, groupX, groupY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Flowing particle
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(pathX, pathY, 4, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillText('exp', cx - 5, cy - 25);
                    }
                    // Mode 3: Commutator [X,Y] (Two Paths That Don't Commute)
                    else if (mode === 3) {
                        const t = (time % 4) / 4;
                        
                        // Path 1: X then Y (red)
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.7;
                        
                        // Starting point
                        const startX = cx - 25;
                        const startY = cy + 15;
                        
                        // X direction, then Y direction
                        const midX1 = startX + 25;
                        const midY1 = startY;
                        const endX1 = midX1;
                        const endY1 = midY1 - 25;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        if(t < 0.5) {
                            ctx.lineTo(startX + (midX1 - startX) * (t * 2), startY);
                        } else {
                            ctx.lineTo(midX1, midY1);
                            ctx.lineTo(midX1, midY1 + (endY1 - midY1) * ((t - 0.5) * 2));
                        }
                        ctx.stroke();
                        
                        // Path 2: Y then X (cyan)
                        ctx.strokeStyle = '#4ecdc4';
                        
                        const midX2 = startX;
                        const midY2 = startY - 25;
                        const endX2 = midX2 + 25;
                        const endY2 = midY2;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        if(t < 0.5) {
                            ctx.lineTo(startX, startY + (midY2 - startY) * (t * 2));
                        } else {
                            ctx.lineTo(midX2, midY2);
                            ctx.lineTo(midX2 + (endX2 - midX2) * ((t - 0.5) * 2), midY2);
                        }
                        ctx.stroke();
                        
                        // Endpoints don't match! (the commutator gap)
                        if(t > 0.9) {
                            ctx.fillStyle = '#ff6b6b';
                            ctx.beginPath(); ctx.arc(endX1, endY1, 4, 0, Math.PI*2); ctx.fill();
                            ctx.fillStyle = '#4ecdc4';
                            ctx.beginPath(); ctx.arc(endX2, endY2, 4, 0, Math.PI*2); ctx.fill();
                            
                            // Gap indicator
                            ctx.strokeStyle = '#fff';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath();
                            ctx.moveTo(endX1, endY1);
                            ctx.lineTo(endX2, endY2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#a855f7';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('[X, Y] ‚â† 0', cx - 22, cy + 38);
                    }
                    // Mode 4: SO(3) - ROTATING 3D WIREFRAME CUBE
                    else if (mode === 4) {
                        const size = 18;
                        const yaw = time * 0.5;
                        const pitch = time * 0.3;
                        const roll = time * 0.2;
                        
                        // Cube vertices (8 corners of unit cube)
                        const verts = [
                            {x:-1, y:-1, z:-1}, {x:1, y:-1, z:-1}, 
                            {x:1, y:1, z:-1}, {x:-1, y:1, z:-1},
                            {x:-1, y:-1, z:1}, {x:1, y:-1, z:1}, 
                            {x:1, y:1, z:1}, {x:-1, y:1, z:1}
                        ];
                        
                        // 12 edges connecting vertices
                        const edges = [
                            [0,1], [1,2], [2,3], [3,0],  // back face
                            [4,5], [5,6], [6,7], [7,4],  // front face
                            [0,4], [1,5], [2,6], [3,7]   // connecting edges
                        ];
                        
                        // Apply 3D rotation and project
                        const cY = Math.cos(yaw), sY = Math.sin(yaw);
                        const cP = Math.cos(pitch), sP = Math.sin(pitch);
                        const cR = Math.cos(roll), sR = Math.sin(roll);
                        
                        const projected = verts.map(v => {
                            // Yaw (rotate around Y)
                            let x = v.x * cY - v.z * sY;
                            let z = v.x * sY + v.z * cY;
                            let y = v.y;
                            
                            // Pitch (rotate around X)
                            const y2 = y * cP - z * sP;
                            const z2 = y * sP + z * cP;
                            y = y2; z = z2;
                            
                            // Roll (rotate around Z)
                            const x2 = x * cR - y * sR;
                            const y3 = x * sR + y * cR;
                            x = x2; y = y3;
                            
                            // Perspective projection
                            const scale = 150 / (150 + z * 30);
                            return {
                                x: cx + x * size * scale, 
                                y: cy + y * size * scale,
                                z: z
                            };
                        });
                        
                        // Draw edges with depth-based opacity
                        edges.forEach(e => {
                            const p1 = projected[e[0]];
                            const p2 = projected[e[1]];
                            const avgZ = (p1.z + p2.z) / 2;
                            
                            ctx.strokeStyle = '#a855f7';
                            ctx.lineWidth = avgZ > 0 ? 2 : 1;
                            ctx.globalAlpha = 0.4 + (avgZ + 1) * 0.3;
                            
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        });
                        
                        // Draw vertices with glow
                        projected.forEach(p => {
                            ctx.fillStyle = p.z > 0 ? '#fff' : '#a855f7';
                            ctx.globalAlpha = 0.5 + (p.z + 1) * 0.25;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.z > 0 ? 2.5 : 1.5, 0, Math.PI*2);
                            ctx.fill();
                        });
                        
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 1.0;
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('SO(3)', cx - 15, cy + 40);
                    }
                },

                // 17. QUATERNIONS - DYNAMIC 4D & GIMBAL LOCK
                'quaternions': (ctx, time, mode) => {
                    ctx.strokeStyle = '#a855f7'; ctx.fillStyle = '#a855f7';
                    
                    // Mode 0: 4D Hypersphere Rotation (Stereographic Projection)
                    if (mode === 0) {
                        const numPoints = 50;
                        const r = 26;
                        
                        for(let i=0; i<numPoints; i++) {
                            const layer = i % 3;
                            const phase = (i / numPoints) * Math.PI * 2;
                            const speed = 1 + layer * 0.4;
                            
                            // Simulate 4D rotation projected to 3D then 2D
                            const rotX = Math.cos(time * speed + phase) * r * (0.4 + layer*0.2);
                            const rotY = Math.sin(time * speed + phase) * r * (0.4 + layer*0.2);
                            const rotZ = Math.sin(time * speed * 1.3 + phase);
                            const rotW = Math.cos(time * speed * 0.7 + phase * 2);
                            
                            // Perspective from 4D
                            const scale = 1 / (1.5 - rotW * 0.3);
                            const px = cx + rotX * scale;
                            const py = cy + rotY * scale;
                            
                            ctx.globalAlpha = 0.3 + 0.5 * (rotZ + 1) / 2;
                            ctx.fillStyle = `hsl(${270 + rotW*30}, 70%, ${50 + rotZ*20}%)`;
                            ctx.beginPath();
                            ctx.arc(px, py, 2 + layer*0.5, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Central glowing point
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.6 + 0.4*Math.sin(time*2);
                        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
                        
                        ctx.globalAlpha = 1.0;
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('S¬≥ ‚äÇ ‚Ñù‚Å¥', cx-18, cy+38);
                    }

                    // Mode 1: Non-Commutativity (Animated i¬∑j vs j¬∑i)
                    else if (mode === 1) {
                        const cycleTime = 3;
                        const t = (time % cycleTime) / cycleTime;
                        
                        ctx.font = '13px serif';
                        ctx.textAlign = 'center';
                        
                        // Animated equation switch
                        if (t < 0.5) {
                            const ease = Math.sin(t * Math.PI);
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 1.0;
                            ctx.fillText('i ¬∑ j', cx, cy-12);
                            
                            // Arrow
                            ctx.strokeStyle = '#a855f7';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy-2);
                            ctx.lineTo(cx, cy+12);
                            ctx.stroke();
                            ctx.lineWidth = 1;
                            
                            // Result with glow
                            ctx.fillStyle = '#a855f7';
                            ctx.shadowBlur = 8 * ease;
                            ctx.shadowColor = '#a855f7';
                            ctx.fillText('k', cx, cy+28);
                            ctx.shadowBlur = 0;
                        } else {
                            const ease = Math.sin((t - 0.5) * 2 * Math.PI);
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 1.0;
                            ctx.fillText('j ¬∑ i', cx, cy-12);
                            
                            // Arrow
                            ctx.strokeStyle = '#ff6b6b';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy-2);
                            ctx.lineTo(cx, cy+12);
                            ctx.stroke();
                            ctx.lineWidth = 1;
                            
                            // Result (negative!)
                            ctx.fillStyle = '#ff6b6b';
                            ctx.shadowBlur = 8 * Math.abs(ease);
                            ctx.shadowColor = '#ff6b6b';
                            ctx.fillText('-k', cx, cy+28);
                            ctx.shadowBlur = 0;
                        }
                        ctx.textAlign = 'left';
                    }

                    // Mode 2: The Sandwich Product (q v q‚Åª¬π)
                    else if (mode === 2) {
                        // Rotation axis
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([3,3]);
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.moveTo(cx, cy-32); ctx.lineTo(cx, cy+32); ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Original vector v
                        ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+22, cy-10); ctx.stroke();
                        ctx.fillStyle = '#a855f7';
                        ctx.font = '10px serif';
                        ctx.fillText('v', cx+24, cy-12);
                        
                        // Rotated vector v' (orbiting)
                        const rot = time * 1.5;
                        const vx = 22 * Math.cos(rot);
                        const vy = 10 * Math.sin(rot);
                        const depth = Math.cos(rot);
                        
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.5 + 0.5*depth;
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+vx, cy-vy); ctx.stroke();
                        
                        // Orbital trace
                        ctx.strokeStyle = '#4ecdc4'; ctx.globalAlpha = 0.2;
                        ctx.beginPath(); ctx.ellipse(cx, cy, 22, 10, 0, 0, Math.PI*2); ctx.stroke();
                        
                        // Tip glow
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.arc(cx+vx, cy-vy, 3, 0, Math.PI*2); ctx.fill();
                        
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = '#fff';
                        ctx.fillText("v' = qvq‚Åª¬π", cx-22, cy+38);
                    }

                    // Mode 3: Pauli Matrices Link (Quantum Spin)
                    else if (mode === 3) {
                        const matrices = [
                            {q: 'i', s: 'œÉ‚ÇÅ', color: '#ff6b6b'},
                            {q: 'j', s: 'œÉ‚ÇÇ', color: '#4ecdc4'},
                            {q: 'k', s: 'œÉ‚ÇÉ', color: '#a855f7'}
                        ];
                        
                        matrices.forEach((m, i) => {
                            const y = cy - 18 + i * 18;
                            const pulse = 0.7 + 0.3*Math.sin(time*2 + i*Math.PI/3);
                            
                            ctx.font = '12px serif';
                            ctx.fillStyle = m.color;
                            ctx.globalAlpha = pulse;
                            ctx.fillText(m.q, cx-25, y);
                            
                            // Arrow
                            ctx.strokeStyle = '#fff';
                            ctx.globalAlpha = 0.4;
                            ctx.beginPath();
                            ctx.moveTo(cx-15, y-4);
                            ctx.lineTo(cx+5, y-4);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(cx+2, y-7); ctx.lineTo(cx+5, y-4); ctx.lineTo(cx+2, y-1);
                            ctx.stroke();
                            
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = pulse;
                            ctx.fillText('-i' + m.s, cx+10, y);
                        });
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('SU(2) ‚Üî Spin', cx-22, cy+36);
                    }

                    // Mode 4: GIMBAL LOCK vs QUATERNIONS
                    else if (mode === 4) {
                        const rOuter = 26, rMid = 20, rInner = 14;
                        
                        // Simulate gyroscope alignment
                        // Using 1.5 instead of 0.6 ensures ~2 lock events per 8-second carousel cycle
                        // Full cycle: 2œÄ/1.5 ‚âà 4.2 seconds, meaning users see lock state reliably
                        const pitchAngle = (Math.sin(time * 1.5) * 0.5 + 0.5) * (Math.PI/2);
                        const isLocked = pitchAngle > 1.35;
                        
                        // Outer gimbal ring (yaw)
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rOuter, rOuter * 0.4, 0, 0, Math.PI*2);
                        ctx.stroke();
                        
                        // Middle gimbal ring (pitch) - this one aligns
                        const midTilt = pitchAngle;
                        ctx.strokeStyle = isLocked ? '#ff0000' : '#fbbf24';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rMid, rMid * Math.cos(midTilt) * 0.4 + 2, 0, 0, Math.PI*2);
                        ctx.stroke();
                        
                        // Inner gimbal ring (roll)
                        ctx.strokeStyle = isLocked ? '#ff0000' : '#a855f7';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rInner, rInner * 0.4, 0, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        if (isLocked) {
                            // LOCK indicator
                            ctx.font = '9px serif';
                            ctx.fillStyle = '#ff0000';
                            ctx.globalAlpha = 0.5 + 0.5*Math.sin(time*8);
                            ctx.fillText('‚ö† LOCK', cx-18, cy+5);
                            
                            // Quaternion ghost escaping the lock
                            const qt = time * 2;
                            const qx = cx + Math.cos(qt) * 32;
                            const qy = cy + Math.sin(qt * 0.8) * 20;
                            
                            ctx.fillStyle = '#4ecdc4';
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath(); ctx.arc(qx, qy, 4, 0, Math.PI*2); ctx.fill();
                            
                            // Ghost trail
                            ctx.globalAlpha = 0.2;
                            ctx.strokeStyle = '#4ecdc4';
                            ctx.beginPath(); ctx.arc(cx, cy, 32, 0, Math.PI*2); ctx.stroke();
                            
                            ctx.font = '7px serif';
                            ctx.fillStyle = '#4ecdc4';
                            ctx.globalAlpha = 1.0;
                            ctx.fillText('SLERP', qx+6, qy-2);
                        } else {
                            ctx.font = '8px serif';
                            ctx.fillStyle = '#888';
                            ctx.globalAlpha = 1.0;
                            ctx.fillText('Approaching lock...', cx-35, cy+38);
                        }
                    }
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FOUNDATIONS NODE (Gray Theme: #64748b) - 1 node √ó 5 modes = 5 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 18. PROOFS
                'proofs': (ctx, time, mode) => {
                    ctx.strokeStyle = '#64748b'; ctx.fillStyle = '#64748b';

                    // Mode 0: Implication Chain (P ‚üπ Q with flowing logic)
                    if (mode === 0) {
                        // Animated implication arrow
                        const arrowProgress = (time % 2) / 2;
                        
                        // P box
                        ctx.fillStyle = '#64748b';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(cx - 45, cy - 12, 25, 24);
                        ctx.font = '14px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('P', cx - 38, cy + 5);
                        
                        // Q box
                        ctx.fillStyle = '#64748b';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(cx + 20, cy - 12, 25, 24);
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Q', cx + 27, cy + 5);
                        
                        // Animated implication arrow
                        const arrowX = cx - 18 + arrowProgress * 35;
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(cx - 18, cy);
                        ctx.lineTo(cx + 17, cy);
                        ctx.stroke();
                        
                        // Arrow head
                        ctx.beginPath();
                        ctx.moveTo(cx + 17, cy);
                        ctx.lineTo(cx + 12, cy - 4);
                        ctx.lineTo(cx + 12, cy + 4);
                        ctx.closePath();
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fill();
                        
                        // Flowing truth particle
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(arrowX, cy, 4, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Glow effect
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(arrowX, cy, 8, 0, Math.PI*2);
                        ctx.fill();
                    }
                    // Mode 1: Logic Table (Scanning Rows)
                    else if (mode === 1) {
                        const rows = [
                            {p: 'T', q: 'T', r: 'T'},
                            {p: 'T', q: 'F', r: 'F'},
                            {p: 'F', q: 'T', r: 'T'},
                            {p: 'F', q: 'F', r: 'T'}
                        ];
                        
                        const activeRow = Math.floor(time * 0.8) % 4;
                        
                        // Draw truth table
                        ctx.font = '9px monospace';
                        rows.forEach((row, i) => {
                            const y = cy - 18 + i * 11;
                            const isActive = i === activeRow;
                            
                            // Highlight active row
                            if(isActive) {
                                ctx.fillStyle = '#64748b';
                                ctx.globalAlpha = 0.3;
                                ctx.fillRect(cx - 30, y - 8, 60, 11);
                            }
                            
                            ctx.globalAlpha = isActive ? 1.0 : 0.5;
                            ctx.fillStyle = isActive ? '#fff' : '#64748b';
                            ctx.fillText(`${row.p}  ${row.q} ‚îÇ ${row.r}`, cx - 25, y);
                        });
                        
                        // Scanning line effect
                        const scanY = cy - 18 + activeRow * 11;
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.6;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx - 32, scanY - 8);
                        ctx.lineTo(cx + 32, scanY - 8);
                        ctx.stroke();
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('P ‚Üí Q', cx - 12, cy + 32);
                    }
                    // Mode 2: Induction (Smoothly Falling Dominoes)
                    else if (mode === 2) {
                        const cycleTime = 4;
                        const t = (time % cycleTime) / cycleTime;
                        const numDominoes = 7;
                        
                        for(let i = 0; i < numDominoes; i++) {
                            const fallStart = i / numDominoes;
                            const fallDuration = 0.15;
                            let angle = 0;
                            
                            if(t > fallStart) {
                                const fallProgress = Math.min(1, (t - fallStart) / fallDuration);
                                // Smooth easing
                                angle = fallProgress * fallProgress * (Math.PI / 3);
                            }
                            
                            ctx.save();
                            ctx.translate(cx - 35 + i * 11, cy + 12);
                            ctx.rotate(angle);
                            
                            // Domino color based on fall state
                            ctx.fillStyle = angle > 0.1 ? '#4ecdc4' : '#64748b';
                            ctx.globalAlpha = 0.8;
                            ctx.fillRect(-3, -20, 6, 28);
                            
                            // Dot on domino
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.arc(0, -10, 2, 0, Math.PI*2);
                            ctx.fill();
                            
                            ctx.restore();
                        }
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('P(n) ‚üπ P(n+1)', cx - 32, cy + 40);
                    }
                    // Mode 3: Quantifiers (Morphing ‚àÄ ‚Üî ‚àÉ)
                    else if (mode === 3) {
                        const morphT = (Math.sin(time * 1.5) + 1) / 2;
                        
                        // Background circle representing domain
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.arc(cx, cy, 30, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Draw domain points
                        for(let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + time * 0.3;
                            const r = 20;
                            const px = cx + Math.cos(angle) * r;
                            const py = cy + Math.sin(angle) * r;
                            
                            // For ‚àÄ: all points light up; for ‚àÉ: only one
                            const isActive = morphT > 0.5 ? true : (i === Math.floor(time) % 8);
                            
                            ctx.fillStyle = isActive ? '#4ecdc4' : '#64748b';
                            ctx.globalAlpha = isActive ? 0.8 : 0.3;
                            ctx.beginPath();
                            ctx.arc(px, py, 3, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Morphing symbol
                        ctx.font = '28px serif';
                        ctx.fillStyle = morphT > 0.5 ? '#4ecdc4' : '#ff6b6b';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText(morphT > 0.5 ? '‚àÄ' : '‚àÉ', cx - 10, cy + 8);
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText(morphT > 0.5 ? 'For all' : 'There exists', cx - 22, cy + 38);
                    }
                    // Mode 4: Set Theory (Animated Venn Intersection)
                    else if (mode === 4) {
                        // Breathing sets
                        const breathe = Math.sin(time * 2) * 3;
                        const sepPhase = Math.sin(time * 0.8) * 5;
                        
                        // Set A
                        ctx.fillStyle = '#64748b';
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.arc(cx - 14 - sepPhase, cy, 22 + breathe, 0, Math.PI*2);
                        ctx.fill();
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        // Set B
                        ctx.beginPath();
                        ctx.arc(cx + 14 + sepPhase, cy, 22 - breathe, 0, Math.PI*2);
                        ctx.globalAlpha = 0.25;
                        ctx.fill();
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        // Intersection highlight
                        if(sepPhase < 3) {
                            ctx.fillStyle = '#4ecdc4';
                            ctx.globalAlpha = 0.5 + Math.sin(time * 3) * 0.2;
                            ctx.beginPath();
                            ctx.arc(cx, cy, 8 - sepPhase * 0.5, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Labels
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.8;
                        ctx.fillText('A', cx - 28 - sepPhase, cy + 4);
                        ctx.fillText('B', cx + 22 + sepPhase, cy + 4);
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText(sepPhase < 3 ? 'A ‚à© B' : 'A ‚à™ B', cx - 12, cy + 38);
                    }
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHYSICS NODE (Red Theme: #ef4444) - 1 node √ó 5 modes = 5 unique
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 19. APPLICATIONS (Physics)
                'applications': (ctx, time, mode) => {
                    ctx.strokeStyle = '#ef4444'; ctx.fillStyle = '#ef4444';

                    // Mode 0: Magnetic Monopole (Dirac String Visualization)
                    if (mode === 0) {
                        // Monopole at center (source of radial B-field)
                        ctx.fillStyle = '#fff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ef4444';
                        ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Radial magnetic field lines
                        ctx.strokeStyle = '#ef4444';
                        for(let i = 0; i < 8; i++) {
                            const a = time * 0.15 + i * (Math.PI/4);
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(cx + Math.cos(a) * 8, cy + Math.sin(a) * 8);
                            ctx.lineTo(cx + Math.cos(a) * 32, cy + Math.sin(a) * 32);
                            ctx.stroke();
                            
                            // Arrow heads on field lines
                            const ax = cx + Math.cos(a) * 24;
                            const ay = cy + Math.sin(a) * 24;
                            ctx.fillStyle = '#ef4444';
                            ctx.beginPath();
                            ctx.arc(ax, ay, 2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // The Dirac String (singularity line extending to infinity)
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy + 6);
                        ctx.lineTo(cx, cy + 42);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.lineWidth = 1;
                        
                        // Electron spiraling around the Dirac string (Aharonov-Bohm effect)
                        const spiralPhase = time * 8;
                        const spiralY = cy + 12 + ((time * 15) % 28);
                        const spiralX = cx + Math.sin(spiralPhase) * 7;
                        
                        ctx.fillStyle = '#4ecdc4';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(spiralX, spiralY, 3, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Trail for electron
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        for(let i = 0; i < 20; i++) {
                            const tPhase = spiralPhase - i * 0.4;
                            const ty = spiralY - i * 1.2;
                            const tx = cx + Math.sin(tPhase) * 7;
                            if (i === 0) ctx.moveTo(tx, ty);
                            else ctx.lineTo(tx, ty);
                        }
                        ctx.stroke();
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Dirac String', cx + 8, cy + 35);
                    }
                    // Mode 1: Berry Phase (Geometric Phase on Parameter Space)
                    else if (mode === 1) {
                        const r = 26;
                        
                        // Parameter space sphere (semi-transparent)
                        ctx.strokeStyle = '#ef4444';
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                        
                        // Latitude circle (adiabatic path)
                        const coneAngle = Math.PI / 5;  // Latitude of path
                        const pathY = cy - r * Math.sin(coneAngle) * 0.3;
                        const pathR = r * Math.cos(coneAngle) * 0.85;
                        
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.ellipse(cx, pathY + 5, pathR, pathR * 0.35, 0, 0, Math.PI*2);
                        ctx.stroke();
                        
                        // Moving state point on path
                        const t = time * 0.8;
                        const px = cx + Math.cos(t) * pathR;
                        const py = pathY + 5 + Math.sin(t) * pathR * 0.35;
                        
                        // Berry phase: vector rotates as state traverses loop
                        // The geometric phase accumulates = solid angle enclosed
                        const phaseAccum = t * (1 - Math.cos(coneAngle));
                        
                        // Draw state vector with accumulated phase
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(phaseAccum) * 14, py - Math.sin(phaseAccum) * 10);
                        ctx.stroke();
                        
                        // Trail showing phase history
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        for(let i = 0; i < 25; i++) {
                            const tOff = t - i * 0.12;
                            const tpx = cx + Math.cos(tOff) * pathR;
                            const tpy = pathY + 5 + Math.sin(tOff) * pathR * 0.35;
                            if (i === 0) ctx.moveTo(tpx, tpy);
                            else ctx.lineTo(tpx, tpy);
                        }
                        ctx.stroke();
                        
                        // State point with glow
                        ctx.fillStyle = '#fff';
                        ctx.shadowBlur = 6;
                        ctx.shadowColor = '#4ecdc4';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        ctx.lineWidth = 1;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Œ≥ = Œ©(C)', cx - 18, cy + 42);
                    }
                    // Mode 2: Aharonov-Bohm Effect
                    else if (mode === 2) {
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath(); ctx.arc(cx, cy, 22, -Math.PI/2, Math.PI/2); ctx.stroke();
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.beginPath(); ctx.arc(cx, cy, 22, Math.PI/2, 3*Math.PI/2); ctx.stroke();
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('ŒîœÜ ‚â† 0', cx+25, cy+5);
                    }
                    // Mode 3: Bloch Sphere (Quantum State with Trail)
                    else if (mode === 3) {
                        const r = 26;
                        
                        // Wireframe sphere
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(cx, cy, r, r * 0.3, 0, 0, Math.PI*2); ctx.stroke();
                        
                        // Z-axis (|0‚ü© to |1‚ü©)
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath(); ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r); ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // State vector evolving on Bloch sphere
                        const theta = time * 0.5;  // polar angle
                        const phi = time * 1.3;    // azimuthal angle
                        
                        // Bloch sphere coordinates
                        const stateX = r * Math.sin(theta) * Math.cos(phi);
                        const stateY = r * Math.cos(theta);
                        const stateZ = r * Math.sin(theta) * Math.sin(phi);
                        
                        // Project 3D to 2D
                        const px = cx + stateX;
                        const py = cy - stateY;  // Y inverted for screen
                        
                        // Draw fading trail
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const trailLen = 30;
                        for(let i = 0; i < trailLen; i++) {
                            const tOffset = i * 0.08;
                            const tTheta = (time - tOffset) * 0.5;
                            const tPhi = (time - tOffset) * 1.3;
                            
                            const tx = r * Math.sin(tTheta) * Math.cos(tPhi);
                            const ty = r * Math.cos(tTheta);
                            const tpx = cx + tx;
                            const tpy = cy - ty;
                            
                            ctx.globalAlpha = (trailLen - i) / trailLen * 0.7;
                            if (i === 0) ctx.moveTo(tpx, tpy);
                            else ctx.lineTo(tpx, tpy);
                        }
                        ctx.stroke();
                        
                        // State vector arrow
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(px, py);
                        ctx.stroke();
                        
                        // State point with glow
                        ctx.fillStyle = '#fff';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#4ecdc4';
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Poles labels
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('|0‚ü©', cx + 4, cy - r - 3);
                        ctx.fillText('|1‚ü©', cx + 4, cy + r + 8);
                        
                        ctx.lineWidth = 1;
                        ctx.font = '9px serif';
                        ctx.fillText('|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©', cx - 35, cy + 42);
                    }
                    // Mode 4: Yang-Mills Gauge Field (Non-Abelian Interaction)
                    else if (mode === 4) {
                        // Draw a 3x3 grid of interacting gauge field vectors
                        for(let i = -1; i <= 1; i++) {
                            for(let j = -1; j <= 1; j++) {
                                const x = cx + i * 22;
                                const y = cy + j * 18;
                                
                                // Non-abelian interaction: rotation depends on neighbors
                                const interaction = Math.sin(i * j * 0.5 + time);
                                const rot = time * 1.2 + interaction * Math.PI * 0.3;
                                
                                // Color varies with internal symmetry state
                                const hue = 0 + interaction * 30;
                                ctx.strokeStyle = `hsl(${hue}, 70%, 55%)`;
                                ctx.lineWidth = 1.5;
                                ctx.globalAlpha = 0.7;
                                
                                // Vector direction
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + Math.cos(rot) * 10, y + Math.sin(rot) * 10);
                                ctx.stroke();
                                
                                // Arrow tip with glow
                                ctx.fillStyle = `hsl(${hue}, 70%, 65%)`;
                                ctx.globalAlpha = 0.9;
                                ctx.beginPath();
                                ctx.arc(x + Math.cos(rot) * 10, y + Math.sin(rot) * 10, 2, 0, Math.PI*2);
                                ctx.fill();
                            }
                        }
                        
                        // Central gluon interaction indicator
                        const pulse = 0.5 + 0.3 * Math.sin(time * 3);
                        ctx.fillStyle = '#ef4444';
                        ctx.globalAlpha = pulse;
                        ctx.beginPath();
                        ctx.arc(cx, cy, 4, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 1.0;
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('SU(N) Gauge', cx - 25, cy + 40);
                    }
                }
            };

            const ENGINES = {
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 1. ANALYSIS: 5 PhD-Grade Visualizations
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                analysis: (ctx, time, mode) => {
                    ctx.strokeStyle = CATEGORY_HEX['analysis'];
                    ctx.fillStyle = CATEGORY_HEX['analysis'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: FOURIER EPICYCLES (Classic)
                    if (mode === 0) {
                        let x = cx - 35, y = cy;
                        const N = 6;
                        
                        for(let n=0; n<N; n++) {
                            const prevX = x, prevY = y;
                            const k = 2*n + 1;
                            const r = 25 / k;
                            const speed = k * 1.2;
                            
                            x += Math.cos(time * speed) * r;
                            y += Math.sin(time * speed) * r;
                            
                            ctx.globalAlpha = 0.25;
                            ctx.beginPath(); 
                            ctx.arc(prevX, prevY, r, 0, Math.PI*2); 
                            ctx.stroke();
                            
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath(); 
                            ctx.moveTo(prevX, prevY); 
                            ctx.lineTo(x, y); 
                            ctx.stroke();
                        }
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath(); 
                        ctx.arc(x, y, 3, 0, Math.PI*2); 
                        ctx.fill();
                    }
                    
                    // MODE 1: LAPLACE TRANSFORM (s-plane poles/zeros)
                    else if (mode === 1) {
                        // Draw imaginary axis
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(cx, 5); ctx.lineTo(cx, height - 5);
                        ctx.stroke();
                        // Real axis
                        ctx.beginPath();
                        ctx.moveTo(5, cy); ctx.lineTo(width - 5, cy);
                        ctx.stroke();
                        
                        // Poles (X marks) rotating in complex plane
                        const poles = [
                            { re: -0.5, im: 1 },
                            { re: -0.5, im: -1 },
                            { re: -1.5, im: 0 }
                        ];
                        
                        ctx.globalAlpha = 1.0;
                        ctx.lineWidth = 2;
                        poles.forEach((pole, i) => {
                            const wobble = Math.sin(time * 2 + i) * 0.2;
                            const px = cx + (pole.re + wobble) * 25;
                            const py = cy - pole.im * 25;
                            
                            ctx.strokeStyle = '#ff6b6b';
                            ctx.beginPath();
                            ctx.moveTo(px - 5, py - 5); ctx.lineTo(px + 5, py + 5);
                            ctx.moveTo(px + 5, py - 5); ctx.lineTo(px - 5, py + 5);
                            ctx.stroke();
                        });
                        
                        // Zero (circle)
                        const zx = cx + Math.cos(time) * 20;
                        const zy = cy + Math.sin(time * 0.7) * 15;
                        ctx.strokeStyle = CATEGORY_HEX['analysis'];
                        ctx.beginPath();
                        ctx.arc(zx, zy, 5, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('œÉ', width - 15, cy - 5);
                        ctx.fillText('jœâ', cx + 5, 15);
                    }
                    
                    // MODE 2: CONVERGENT SEQUENCE (Œµ-Œ¥ visualization)
                    else if (mode === 2) {
                        const limit = cy;
                        const epsilon = 15 + Math.sin(time) * 10;
                        
                        // Epsilon band
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = CATEGORY_HEX['analysis'];
                        ctx.fillRect(0, limit - epsilon, width, epsilon * 2);
                        
                        // Limit line
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.5;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(0, limit); ctx.lineTo(width, limit);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Sequence terms
                        for(let n = 1; n <= 15; n++) {
                            const x = (n / 15) * (width - 20) + 10;
                            const term = limit + Math.pow(-1, n) * 35 / n;
                            const inBand = Math.abs(term - limit) < epsilon;
                            
                            ctx.fillStyle = inBand ? '#4ecdc4' : '#ff6b6b';
                            ctx.globalAlpha = 0.4 + n / 20;
                            ctx.beginPath();
                            ctx.arc(x, term, 3, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    
                    // MODE 3: CONTOUR INTEGRATION (Residue theorem)
                    else if (mode === 3) {
                        // Draw a contour around singularities
                        const contourR = 30;
                        
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = CATEGORY_HEX['analysis'];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(cx, cy, contourR, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Singularity (pole)
                        ctx.fillStyle = '#ff4444';
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.arc(cx + 10, cy - 5, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Moving point on contour
                        const t = time * 1.5;
                        const px = cx + Math.cos(t) * contourR;
                        const py = cy + Math.sin(t) * contourR;
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(px, py, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Direction arrow
                        const arrowAngle = t + Math.PI/2;
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(arrowAngle) * 10, py + Math.sin(arrowAngle) * 10);
                        ctx.stroke();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚àÆ f(z)dz = 2œÄi Œ£ Res', cx - 45, cy + 45);
                    }
                    
                    // MODE 4: POWER SERIES (Taylor expansion)
                    else if (mode === 4) {
                        // Show partial sums converging
                        const numTerms = Math.floor((time % 6) + 1);
                        
                        // Draw actual function (sin)
                        ctx.globalAlpha = 0.3;
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        for(let i = 0; i < width; i++) {
                            const x = (i / width - 0.5) * 4;
                            const y = cy - Math.sin(x) * 30;
                            if(i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
                        }
                        ctx.stroke();
                        
                        // Draw Taylor approximation
                        ctx.strokeStyle = CATEGORY_HEX['analysis'];
                        ctx.globalAlpha = 1.0;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for(let i = 0; i < width; i++) {
                            const x = (i / width - 0.5) * 4;
                            let taylor = 0;
                            for(let n = 0; n < numTerms; n++) {
                                const sign = Math.pow(-1, n);
                                const factorial = [1, 1, 2, 6, 24, 120, 720][2*n+1] || 1;
                                taylor += sign * Math.pow(x, 2*n+1) / factorial;
                            }
                            const y = cy - taylor * 30;
                            if(i === 0) ctx.moveTo(i, Math.max(5, Math.min(height-5, y)));
                            else ctx.lineTo(i, Math.max(5, Math.min(height-5, y)));
                        }
                        ctx.stroke();
                        
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('sin(x) ‚âà ' + numTerms + ' terms', 10, 15);
                    }
                    
                    ctx.globalAlpha = 1.0;
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 2. ALGEBRA: 5 PhD-Grade Visualizations
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                algebra: (ctx, time, mode) => {
                    ctx.strokeStyle = CATEGORY_HEX['algebra'];
                    ctx.fillStyle = CATEGORY_HEX['algebra'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: 3D CUBE ROTATION (Symmetry Group)
                    if (mode === 0) {
                        const size = 30;
                        const vertices = [
                            [-1,-1,-1], [1,-1,-1], [1, 1,-1], [-1, 1,-1],
                            [-1,-1, 1], [1,-1, 1], [1, 1, 1], [-1, 1, 1]
                        ];
                        const edges = [
                            [0,1], [1,2], [2,3], [3,0],
                            [4,5], [5,6], [6,7], [7,4],
                            [0,4], [1,5], [2,6], [3,7]
                        ];

                        const rotX = time * 0.5, rotY = time * 0.7, rotZ = time * 0.3;
                        const project = (v) => {
                            let x = v[0], y = v[1], z = v[2];
                            let x2 = x*Math.cos(rotY) - z*Math.sin(rotY);
                            let z2 = x*Math.sin(rotY) + z*Math.cos(rotY);
                            let y3 = y*Math.cos(rotX) - z2*Math.sin(rotX);
                            let z3 = y*Math.sin(rotX) + z2*Math.cos(rotX);
                            let x4 = x2*Math.cos(rotZ) - y3*Math.sin(rotZ);
                            let y4 = x2*Math.sin(rotZ) + y3*Math.cos(rotZ);
                            const perspective = 3 / (3 + z3 * 0.3);
                            return [cx + x4*size*perspective, cy + y4*size*perspective, z3];
                        };

                        edges.forEach(e => {
                            const p1 = project(vertices[e[0]]);
                            const p2 = project(vertices[e[1]]);
                            ctx.globalAlpha = 0.3 + (p1[2] + p2[2] + 2) * 0.17;
                            ctx.beginPath();
                            ctx.moveTo(p1[0], p1[1]); ctx.lineTo(p2[0], p2[1]);
                            ctx.stroke();
                        });
                        
                        vertices.forEach(v => {
                            const p = project(v);
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 0.5 + (p[2] + 1) * 0.25;
                            ctx.beginPath(); ctx.arc(p[0], p[1], 2.5, 0, Math.PI*2); ctx.fill();
                        });
                    }
                    
                    // MODE 1: CAYLEY TABLE (Group Operation)
                    else if (mode === 1) {
                        const n = 4;
                        const cellSize = 14;
                        const startX = cx - (n * cellSize) / 2;
                        const startY = cy - (n * cellSize) / 2;
                        
                        ctx.globalAlpha = 0.6;
                        for(let i = 0; i <= n; i++) {
                            ctx.beginPath();
                            ctx.moveTo(startX, startY + i * cellSize);
                            ctx.lineTo(startX + n * cellSize, startY + i * cellSize);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(startX + i * cellSize, startY);
                            ctx.lineTo(startX + i * cellSize, startY + n * cellSize);
                            ctx.stroke();
                        }
                        
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'center';
                        const highlight = Math.floor(time * 2) % (n * n);
                        
                        for(let i = 0; i < n; i++) {
                            for(let j = 0; j < n; j++) {
                                const val = (i + j) % n;
                                const idx = i * n + j;
                                if(idx === highlight) {
                                    ctx.fillStyle = CATEGORY_HEX['algebra'];
                                    ctx.globalAlpha = 0.8;
                                    ctx.fillRect(startX + j * cellSize + 1, startY + i * cellSize + 1, cellSize - 2, cellSize - 2);
                                    ctx.fillStyle = '#000';
                                } else {
                                    ctx.fillStyle = '#fff';
                                }
                                ctx.globalAlpha = 1.0;
                                ctx.fillText(val.toString(), startX + j * cellSize + cellSize/2, startY + i * cellSize + cellSize/2 + 3);
                            }
                        }
                        ctx.textAlign = 'left';
                    }
                    
                    // MODE 2: EIGENSPACE (Linear Algebra)
                    else if (mode === 2) {
                        // Grid
                        ctx.globalAlpha = 0.2;
                        ctx.strokeStyle = '#888';
                        for(let i = -3; i <= 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx + i * 15, cy - 45);
                            ctx.lineTo(cx + i * 15, cy + 45);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(cx - 50, cy + i * 15);
                            ctx.lineTo(cx + 50, cy + i * 15);
                            ctx.stroke();
                        }
                        
                        const stretch = 1 + 0.4 * Math.sin(time * 2);
                        
                        // Eigenvector 1 (stretched)
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(cx - 35 * stretch, cy);
                        ctx.lineTo(cx + 35 * stretch, cy);
                        ctx.stroke();
                        
                        // Eigenvector 2 (compressed)
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - 25 / stretch);
                        ctx.lineTo(cx, cy + 25 / stretch);
                        ctx.stroke();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillText('Œª‚ÇÅ', cx + 40, cy - 3);
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillText('Œª‚ÇÇ', cx + 3, cy - 30);
                    }
                    
                    // MODE 3: PERMUTATION CYCLES (Symmetric Group)
                    else if (mode === 3) {
                        const n = 5;
                        const r = 30;
                        const tick = Math.floor(time * 1.5) % n;
                        
                        for(let i = 0; i < n; i++) {
                            const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
                            const x = cx + Math.cos(angle) * r;
                            const y = cy + Math.sin(angle) * r;
                            
                            ctx.fillStyle = i === tick ? '#fff' : CATEGORY_HEX['algebra'];
                            ctx.globalAlpha = i === tick ? 1.0 : 0.5;
                            ctx.beginPath();
                            ctx.arc(x, y, i === tick ? 6 : 4, 0, Math.PI*2);
                            ctx.fill();
                            
                            ctx.font = '9px monospace';
                            ctx.fillStyle = '#888';
                            ctx.globalAlpha = 0.8;
                            ctx.fillText(i.toString(), x + 10, y + 3);
                        }
                        
                        // Cycle arrows
                        ctx.strokeStyle = CATEGORY_HEX['algebra'];
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r + 8, -Math.PI * 0.7, Math.PI * 0.5);
                        ctx.stroke();
                    }
                    
                    // MODE 4: REPRESENTATION (Character Table hint)
                    else if (mode === 4) {
                        // Show irreducible representations
                        const reps = [
                            { dim: 1, color: '#ff6b6b', label: 'A' },
                            { dim: 1, color: '#4ecdc4', label: 'B' },
                            { dim: 2, color: CATEGORY_HEX['algebra'], label: 'E' }
                        ];
                        
                        ctx.font = '10px serif';
                        ctx.textAlign = 'center';
                        
                        reps.forEach((rep, i) => {
                            const x = 25 + i * (width - 50) / 2;
                            const y = cy;
                            
                            // Draw representation as rotating shape
                            ctx.strokeStyle = rep.color;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.8;
                            
                            if (rep.dim === 1) {
                                // 1D rep: rotating point
                                const angle = time * (i + 1);
                                ctx.beginPath();
                                ctx.arc(x + Math.cos(angle) * 15, y + Math.sin(angle) * 15, 4, 0, Math.PI * 2);
                                ctx.stroke();
                            } else {
                                // 2D rep: rotating pair
                                const angle = time * 1.5;
                                ctx.beginPath();
                                ctx.arc(x + Math.cos(angle) * 12, y + Math.sin(angle) * 12, 3, 0, Math.PI * 2);
                                ctx.arc(x + Math.cos(angle + Math.PI) * 12, y + Math.sin(angle + Math.PI) * 12, 3, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = '#888';
                            ctx.globalAlpha = 1.0;
                            ctx.fillText(rep.label + ' (dim ' + rep.dim + ')', x, y + 35);
                        });
                        ctx.textAlign = 'left';
                    }
                    
                    ctx.globalAlpha = 1.0;
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 3. TOPOLOGY: 5 PhD-Grade Visualizations
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                topology: (ctx, time, mode) => {
                    ctx.strokeStyle = CATEGORY_HEX['topology'];
                    ctx.fillStyle = CATEGORY_HEX['topology'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: VECTOR FIELD FLOW (Vortex with singularity)
                    if (mode === 0) {
                        const rows = 6, cols = 9;
                        const stepX = (width - 20) / cols;
                        const stepY = (height - 20) / rows;

                        for(let r=0; r<=rows; r++) {
                            for(let c=0; c<=cols; c++) {
                                const x = 10 + c * stepX;
                                const y = 10 + r * stepY;
                                const dx = x - cx, dy = y - cy;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                
                                const vortexAngle = Math.atan2(dy, dx) + Math.PI/2;
                                const breathe = Math.sin(time * 2 + dist * 0.1);
                                const angle = vortexAngle + breathe * 0.3;
                                const len = Math.min(10, 7 + 3 * Math.sin(dist * 0.15 + time));
                                
                                ctx.globalAlpha = 0.4 + 0.3 * Math.sin(dist * 0.1);
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.fillStyle = '#ff4444';
                        ctx.globalAlpha = 0.8 + 0.2 * Math.sin(time * 3);
                        ctx.beginPath();
                        ctx.arc(cx, cy, 4, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // MODE 1: FUNDAMENTAL GROUP œÄ‚ÇÅ (Loops on Torus)
                    else if (mode === 1) {
                        const R = 25, r = 10;
                        
                        // Draw torus wireframe
                        ctx.globalAlpha = 0.2;
                        for(let u = 0; u < Math.PI * 2; u += 0.6) {
                            ctx.beginPath();
                            for(let v = 0; v < Math.PI * 2.1; v += 0.2) {
                                const x = (R + r * Math.cos(v)) * Math.cos(u);
                                const y = (R + r * Math.cos(v)) * Math.sin(u);
                                const z = r * Math.sin(v);
                                const rotX = 0.5;
                                const y2 = y * Math.cos(rotX) - z * Math.sin(rotX);
                                const px = cx + x;
                                const py = cy + y2;
                                if(v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }
                        
                        // Alpha loop
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        for(let u = 0; u < Math.PI * 2.1; u += 0.15) {
                            const x = R * Math.cos(u + time * 0.5);
                            const y = R * Math.sin(u + time * 0.5);
                            const y2 = y * Math.cos(0.5);
                            const px = cx + x;
                            const py = cy + y2;
                            if(u === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                        
                        // Beta loop
                        ctx.strokeStyle = '#4ecdc4';
                        const uFixed = time * 0.3;
                        ctx.beginPath();
                        for(let v = 0; v < Math.PI * 2.1; v += 0.15) {
                            const x = (R + r * Math.cos(v)) * Math.cos(uFixed);
                            const y = (R + r * Math.cos(v)) * Math.sin(uFixed);
                            const z = r * Math.sin(v);
                            const y2 = y * Math.cos(0.5) - z * Math.sin(0.5);
                            const px = cx + x;
                            const py = cy + y2;
                            if(v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }
                    
                    // MODE 2: COVERING SPACE (Helix over circle)
                    else if (mode === 2) {
                        // Base circle
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(cx, cy + 25, 25, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Helix (covering space R over S¬π)
                        ctx.strokeStyle = CATEGORY_HEX['topology'];
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        for(let t = -3; t < 3; t += 0.1) {
                            const angle = t * Math.PI + time;
                            const x = cx + Math.cos(angle) * 25;
                            const y = cy - t * 8;
                            if(t === -3) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // Moving point and its projection
                        const pt = Math.sin(time) * 2;
                        const pAngle = pt * Math.PI + time;
                        const px = cx + Math.cos(pAngle) * 25;
                        const py = cy - pt * 8;
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(px, py, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Projection
                        ctx.setLineDash([3, 3]);
                        ctx.strokeStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px, cy + 25 + Math.sin(pAngle) * 25 * 0);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // MODE 3: HOMOLOGY (Betti numbers)
                    else if (mode === 3) {
                        // Show three surfaces with different Œ≤‚ÇÅ
                        const surfaces = [
                            { x: 35, holes: 0, label: 'Œ≤‚ÇÅ=0' },
                            { x: cx, holes: 1, label: 'Œ≤‚ÇÅ=1' },
                            { x: width - 35, holes: 2, label: 'Œ≤‚ÇÅ=2' }
                        ];
                        
                        surfaces.forEach(s => {
                            ctx.strokeStyle = CATEGORY_HEX['topology'];
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.7;
                            
                            // Draw sphere/torus based on holes
                            if (s.holes === 0) {
                                ctx.beginPath();
                                ctx.arc(s.x, cy - 5, 18, 0, Math.PI * 2);
                                ctx.stroke();
                            } else {
                                // Torus-like shape
                                ctx.beginPath();
                                ctx.ellipse(s.x, cy - 5, 20, 12, 0, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                for(let h = 0; h < s.holes; h++) {
                                    const hx = s.x + (h - (s.holes-1)/2) * 12;
                                    ctx.fillStyle = '#000';
                                    ctx.globalAlpha = 1.0;
                                    ctx.beginPath();
                                    ctx.ellipse(hx, cy - 5, 4, 3, 0, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            
                            ctx.font = '9px serif';
                            ctx.fillStyle = '#888';
                            ctx.globalAlpha = 1.0;
                            ctx.textAlign = 'center';
                            ctx.fillText(s.label, s.x, cy + 25);
                        });
                        ctx.textAlign = 'left';
                    }
                    
                    // MODE 4: FIBER BUNDLE (Principal bundle)
                    else if (mode === 4) {
                        // Base space
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(cx, cy + 15, 30, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Fibers
                        const numFibers = 10;
                        for(let i = 0; i < numFibers; i++) {
                            const angle = (i / numFibers) * Math.PI * 2 + time * 0.3;
                            const bx = cx + Math.cos(angle) * 30;
                            const by = cy + 15 + Math.sin(angle) * 30 * 0.4;
                            
                            ctx.strokeStyle = CATEGORY_HEX['topology'];
                            ctx.lineWidth = 1;
                            ctx.globalAlpha = 0.4;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx, by - 25);
                            ctx.stroke();
                            
                            // Point on fiber
                            const fiberPhase = time * 2 + i * 0.5;
                            const fy = by - 12 + Math.sin(fiberPhase) * 10;
                            ctx.fillStyle = CATEGORY_HEX['topology'];
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(bx, fy, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('E', cx + 35, cy - 10);
                        ctx.fillText('B', cx + 35, cy + 25);
                    }
                    
                    ctx.globalAlpha = 1.0;
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 4. GEOMETRY: 5 PhD-Grade Visualizations (RED TEAMED & FIXED)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                geometry: (ctx, time, mode) => {
                    // Reset standard styles
                    ctx.strokeStyle = CATEGORY_HEX['geometry'];
                    ctx.fillStyle = CATEGORY_HEX['geometry'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: PARALLEL TRANSPORT (Holonomy on Gaussian Surface)
                    if (mode === 0) {
                        const res = 14;
                        // Draw a Gaussian hill surface
                        ctx.globalAlpha = 0.3;
                        for(let i=0; i<=res; i++) {
                            ctx.beginPath();
                            for(let j=0; j<=res; j++) {
                                // Normalized coordinates -1 to 1
                                const normX = (j/res)*2 - 1;
                                const normY = (i/res)*2 - 1;
                                
                                // Calculate Z height (Gaussian bump)
                                const z = Math.exp(-(normX*normX + normY*normY)*2.5);
                                
                                // Project to 2D
                                const x = (j/res) * width;
                                const y = (i/res)*height + (height/2 - 40) - z * 35;
                                
                                if(j===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        // Moving vector illustrating Holonomy (rotation after loop)
                        const t = (time * 0.4) % (Math.PI * 2);
                        const orbitR = 25;
                        const px = cx + Math.cos(t) * orbitR;
                        // Project py based on the same Gaussian math
                        const pZ = Math.exp(-Math.pow(Math.cos(t)*0.5, 2) * 2.5);
                        const py = cy + Math.sin(t) * orbitR * 0.6 - pZ * 10;
                        
                        // Vector rotates due to curvature (Simulated Berry phase)
                        // It rotates slightly faster/slower than the path tangent
                        const vecAngle = t - Math.PI/2 + Math.sin(t) * 0.8; 
                        
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2.5;
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(vecAngle) * 18, py + Math.sin(vecAngle) * 18);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fill();
                    }
                    
                    // MODE 1: HYPERBOLIC GEOMETRY (Poincar√© Disk)
                    else if (mode === 1) {
                        const r = 35;
                        
                        // 1. Draw Boundary
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI * 2);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // 2. SAVE CONTEXT STATE (Critical for clipping)
                        ctx.save();
                        
                        // 3. Define Clip Region (The Disk)
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI * 2);
                        ctx.clip();
                        
                        // 4. Draw Geodesics (Orthogonal Arcs)
                        const numArcs = 5;
                        ctx.strokeStyle = CATEGORY_HEX['geometry'];
                        ctx.lineWidth = 1.5;
                        
                        for(let i=0; i<numArcs; i++) {
                            const angle = i * (Math.PI / numArcs) + time * 0.15;
                            
                            // Math for orthogonal circles in Poincar√© disk:
                            // Center of arc circle is at distance d from origin
                            const d = r / Math.cos(Math.PI/4 + Math.sin(time*0.5+i)*0.2); 
                            // Radius of arc circle
                            const arcR = Math.sqrt(d*d - r*r);
                            
                            const ax = cx + Math.cos(angle) * d;
                            const ay = cy + Math.sin(angle) * d;
                            
                            ctx.beginPath();
                            ctx.arc(ax, ay, arcR, 0, Math.PI*2);
                            ctx.globalAlpha = 0.6;
                            ctx.stroke();
                        }
                        
                        // 5. Ideal Triangle (Visualization)
                        ctx.fillStyle = CATEGORY_HEX['geometry'];
                        ctx.globalAlpha = 0.15;
                        ctx.beginPath();
                        ctx.moveTo(cx + r*Math.cos(time), cy + r*Math.sin(time));
                        ctx.lineTo(cx + r*Math.cos(time+2), cy + r*Math.sin(time+2));
                        ctx.lineTo(cx + r*Math.cos(time+4), cy + r*Math.sin(time+4));
                        ctx.fill();
                        
                        // 6. RESTORE CONTEXT (Releases clip for next frame)
                        ctx.restore();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('H¬≤', cx - 6, height - 5);
                    }
                    
                    // MODE 2: OSCULATING CIRCLE (Curvature with proper calculus)
                    else if (mode === 2) {
                        // Draw function curve
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        for(let x=0; x<width; x++) {
                            // Curve: f(x) = 30 * sin(0.05x)
                            const y = cy + Math.sin((x-cx)*0.05)*30;
                            if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.stroke();
                        
                        // Moving osculating circle
                        // Parameter t goes 0 -> 1 back and forth
                        const t = (Math.sin(time * 0.8) + 1) / 2;
                        const px = t * (width-40) + 20;
                        const dx = (px-cx)*0.05;
                        const py = cy + Math.sin(dx)*30;
                        
                        // Derivatives of f(x) = A sin(kx)
                        const A = 30, k = 0.05;
                        const f_prime = A * k * Math.cos(dx); // 1.5 cos
                        const f_double = -A * k * k * Math.sin(dx); // -0.075 sin
                        
                        // Radius of curvature R = (1 + y'^2)^(3/2) / |y''|
                        const R = Math.pow(1 + f_prime*f_prime, 1.5) / Math.max(0.001, Math.abs(f_double));
                        const oscR = Math.min(45, R); // Clamp max visual size
                        
                        // Normal vector direction (perpendicular to tangent)
                        // Tangent angle = atan(f')
                        const tanAngle = Math.atan(f_prime);
                        
                        // Center of osculating circle depends on concavity (sign of f'')
                        const cxOsc = px - oscR * Math.sin(tanAngle) * (f_double < 0 ? -1 : 1);
                        const cyOsc = py + oscR * Math.cos(tanAngle) * (f_double < 0 ? -1 : 1);
                        
                        ctx.strokeStyle = CATEGORY_HEX['geometry'];
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.arc(cxOsc, cyOsc, oscR, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œ∫ = 1/R', width - 45, 15);
                    }
                    
                    // MODE 3: TISSOT'S INDICATRIX (Metric Tensor Visualization)
                    else if (mode === 3) {
                        const cols = 5, rows = 3;
                        
                        // Draw manifold surface background
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = CATEGORY_HEX['geometry'];
                        ctx.fillRect(10, 10, width-20, height-20);
                        
                        // Draw Tissot ellipses
                        for(let i=0; i<cols; i++) {
                            for(let j=0; j<rows; j++) {
                                const x = 25 + i * 27;
                                const y = 20 + j * 22;
                                
                                // Metric distortion g_11, g_22 based on field position
                                const g11 = 1 + 0.4 * Math.cos(x*0.1 - time);
                                const g22 = 1 + 0.4 * Math.sin(y*0.1 + time);
                                
                                ctx.beginPath();
                                ctx.ellipse(x, y, 7 * g11, 7 * g22, time*0.2, 0, Math.PI*2);
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 1;
                                ctx.globalAlpha = 0.7;
                                ctx.stroke();
                                
                                // Draw Basis Vectors (local frame)
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + 7*g11 * Math.cos(time*0.2), y + 7*g11 * Math.sin(time*0.2));
                                ctx.strokeStyle = '#ff0055';
                                ctx.stroke();
                            }
                        }
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('ds¬≤ = g·µ¢‚±ºdx‚Å±dx ≤', width - 70, height - 5);
                    }
                    
                    // MODE 4: GAUSS-BONNET (Curvature + Topology)
                    else if (mode === 4) {
                        const r = 30;
                        // Base Sphere
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI*2);
                        ctx.strokeStyle = '#888';
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        
                        // Geodesic Triangle (Bulging outwards = Positive Curvature)
                        ctx.beginPath();
                        // Top Vertex
                        ctx.moveTo(cx, cy - r);
                        // Curve to Right Vertex
                        ctx.quadraticCurveTo(cx + r, cy, cx + r*0.5, cy + r*0.8);
                        // Curve to Left Vertex
                        ctx.quadraticCurveTo(cx, cy + r*0.5, cx - r*0.5, cy + r*0.8);
                        // Curve back to Top
                        ctx.quadraticCurveTo(cx - r, cy, cx, cy - r);
                        
                        ctx.fillStyle = CATEGORY_HEX['geometry'];
                        ctx.globalAlpha = 0.25;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 1.0;
                        ctx.stroke();
                        
                        // Angle markers (pulsing to show they're > 90¬∞)
                        const pulse = 0.7 + 0.3 * Math.sin(time * 2);
                        ctx.fillStyle = '#ff0055';
                        ctx.globalAlpha = pulse;
                        ctx.beginPath(); ctx.arc(cx, cy - r, 3, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(cx + r*0.5, cy + r*0.8, 3, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(cx - r*0.5, cy + r*0.8, 3, 0, Math.PI*2); ctx.fill();

                        ctx.font = '10px serif';
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('Œ£Œ∏ > œÄ', cx - 15, cy + 5);
                        ctx.fillStyle = '#888';
                        ctx.fillText('K > 0', cx - 15, cy - 35);
                    }
                    
                    ctx.globalAlpha = 1.0;
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 5. PHYSICS: 5 PhD-Grade Visualizations
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                physics: (ctx, time, mode) => {
                    ctx.strokeStyle = CATEGORY_HEX['physics'];
                    ctx.fillStyle = CATEGORY_HEX['physics'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: DOUBLE PENDULUM (Chaos)
                    if (mode === 0) {
                        const g = 0.8;
                        const p1 = state.p1;
                        const p2 = state.p2;
                        
                        const num1 = -g * (2 * p1.m + p2.m) * Math.sin(p1.a);
                        const num2 = -p2.m * g * Math.sin(p1.a - 2 * p2.a);
                        const num3 = -2 * Math.sin(p1.a - p2.a) * p2.m;
                        const num4 = p2.v * p2.v * p2.r + p1.v * p1.v * p1.r * Math.cos(p1.a - p2.a);
                        const den = p1.r * (2 * p1.m + p2.m - p2.m * Math.cos(2 * p1.a - 2 * p2.a));
                        const a1 = (num1 + num2 + num3 * num4) / den;

                        const num5 = 2 * Math.sin(p1.a - p2.a);
                        const num6 = (p1.v * p1.v * p1.r * (p1.m + p2.m));
                        const num7 = g * (p1.m + p2.m) * Math.cos(p1.a);
                        const num8 = p2.v * p2.v * p2.r * p2.m * Math.cos(p1.a - p2.a);
                        const den2 = p2.r * (2 * p1.m + p2.m - p2.m * Math.cos(2 * p1.a - 2 * p2.a));
                        const a2 = (num5 * (num6 + num7 + num8)) / den2;

                        p1.v += a1; p2.v += a2;
                        p1.a += p1.v; p2.a += p2.v;
                        p1.v *= 0.9995; p2.v *= 0.9995;

                        const x1 = cx + p1.r * Math.sin(p1.a);
                        const y1 = cy + p1.r * Math.cos(p1.a);
                        const x2 = x1 + p2.r * Math.sin(p2.a);
                        const y2 = y1 + p2.r * Math.cos(p2.a);

                        ctx.fillStyle = '#666';
                        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x1, y1); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                        ctx.fillStyle = '#aaa';
                        ctx.beginPath(); ctx.arc(x1, y1, 4, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(x2, y2, 4, 0, Math.PI*2); ctx.fill();

                        state.pendulumTrail.push({x: x2, y: y2});
                        if(state.pendulumTrail.length > 120) state.pendulumTrail.shift();
                        
                        ctx.strokeStyle = CATEGORY_HEX['physics'];
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        state.pendulumTrail.forEach((p, i) => {
                            ctx.globalAlpha = i / state.pendulumTrail.length;
                            if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                        });
                        ctx.stroke();
                    }
                    
                    // MODE 1: LORENZ ATTRACTOR (Strange attractor)
                    else if (mode === 1) {
                        const œÉ = 10, œÅ = 28, Œ≤ = 8/3;
                        const dt = 0.01;
                        const L = state.lorenz;
                        
                        for(let i = 0; i < 5; i++) {
                            const dx = œÉ * (L.y - L.x);
                            const dy = L.x * (œÅ - L.z) - L.y;
                            const dz = L.x * L.y - Œ≤ * L.z;
                            L.x += dx * dt;
                            L.y += dy * dt;
                            L.z += dz * dt;
                            
                            state.lorenzTrail.push({x: L.x, y: L.y, z: L.z});
                        }
                        if(state.lorenzTrail.length > 300) state.lorenzTrail.splice(0, 5);
                        
                        ctx.strokeStyle = CATEGORY_HEX['physics'];
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        state.lorenzTrail.forEach((p, i) => {
                            const px = cx + p.x * 2.5;
                            const py = cy + (p.z - 25) * 2;
                            ctx.globalAlpha = i / state.lorenzTrail.length;
                            if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                        });
                        ctx.stroke();
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        const px = cx + L.x * 2.5;
                        const py = cy + (L.z - 25) * 2;
                        ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI * 2); ctx.fill();
                    }
                    
                    // MODE 2: HAMILTONIAN FLOW (Phase space)
                    else if (mode === 2) {
                        ctx.globalAlpha = 0.3;
                        ctx.strokeStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(cx - 60, cy); ctx.lineTo(cx + 60, cy);
                        ctx.moveTo(cx, cy - 40); ctx.lineTo(cx, cy + 40);
                        ctx.stroke();
                        
                        ctx.strokeStyle = CATEGORY_HEX['physics'];
                        ctx.globalAlpha = 0.7;
                        
                        state.hamiltonian.forEach((orbit, i) => {
                            orbit.q += orbit.p * 0.05;
                            orbit.p -= Math.sin(orbit.q) * 0.05;
                            
                            const qx = cx + orbit.q * 15;
                            const py = cy - orbit.p * 25;
                            
                            ctx.fillStyle = CATEGORY_HEX['physics'];
                            ctx.beginPath();
                            ctx.arc(qx, py, 3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Draw energy contour hint
                            ctx.globalAlpha = 0.2;
                            ctx.beginPath();
                            ctx.arc(cx, cy, 15 + i * 5, 0, Math.PI * 2);
                            ctx.stroke();
                        });
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('q', width - 15, cy - 5);
                        ctx.fillText('p', cx + 5, 15);
                    }
                    
                    // MODE 3: WAVE EQUATION (Oscillation modes)
                    else if (mode === 3) {
                        const numModes = 3;
                        
                        for(let m = 1; m <= numModes; m++) {
                            ctx.strokeStyle = m === 1 ? '#ff6b6b' : m === 2 ? '#4ecdc4' : CATEGORY_HEX['physics'];
                            ctx.lineWidth = 2 - m * 0.4;
                            ctx.globalAlpha = 0.8 - m * 0.2;
                            
                            ctx.beginPath();
                            for(let x = 0; x < width; x++) {
                                const phase = time * (m + 1);
                                const y = cy + Math.sin(m * Math.PI * x / width) * Math.sin(phase) * (20 / m);
                                if(x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        // Fixed endpoints
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(0, cy, 4, 0, Math.PI * 2);
                        ctx.arc(width, cy, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // MODE 4: GAUGE FIELD (Berry phase / quantum geometry)
                    else if (mode === 4) {
                        const r = 28;
                        
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Adiabatic path
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, r * 0.8, r * 0.3, time * 0.2, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // State vector acquiring phase
                        const pathT = time * 1.5;
                        const px = cx + Math.cos(pathT) * r * 0.8;
                        const py = cy + Math.sin(pathT) * r * 0.3;
                        
                        // Phase arrow
                        const phaseAngle = pathT * 2;
                        ctx.strokeStyle = '#ff0055';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + Math.cos(phaseAngle) * 12, py - Math.sin(phaseAngle) * 12);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.beginPath();
                        ctx.arc(px, py, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Œ≥ = ‚àÆA¬∑dR', cx - 25, cy + 40);
                    }
                    
                    ctx.globalAlpha = 1.0;
                },

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 6. FOUNDATIONS: 5 PhD-Grade Visualizations
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                foundations: (ctx, time, mode) => {
                    ctx.strokeStyle = CATEGORY_HEX['foundations'];
                    ctx.fillStyle = CATEGORY_HEX['foundations'];
                    ctx.lineWidth = 1.5;
                    
                    // MODE 0: PROOF TREE (Logical deduction)
                    if (mode === 0) {
                        // Draw a proof tree structure
                        const levels = 3;
                        const baseY = 15;
                        const levelHeight = 25;
                        
                        for (let level = 0; level < levels; level++) {
                            const nodesAtLevel = Math.pow(2, level);
                            const y = baseY + level * levelHeight;
                            const spacing = width / (nodesAtLevel + 1);
                            
                            for (let n = 0; n < nodesAtLevel; n++) {
                                const x = spacing * (n + 1);
                                
                                // Pulsing effect based on time
                                const pulse = Math.sin(time * 2 + level + n) * 0.3 + 0.7;
                                
                                // Draw node
                                ctx.globalAlpha = pulse;
                                ctx.beginPath();
                                ctx.arc(x, y, 4, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Draw connection to parent
                                if (level > 0) {
                                    const parentX = width / (Math.pow(2, level - 1) + 1) * (Math.floor(n / 2) + 1);
                                    const parentY = y - levelHeight;
                                    ctx.globalAlpha = 0.4;
                                    ctx.beginPath();
                                    ctx.moveTo(x, y - 4);
                                    ctx.lineTo(parentX, parentY + 4);
                                    ctx.stroke();
                                }
                            }
                        }
                        
                        // Highlight current deduction step
                        const step = Math.floor(time * 0.8) % 7;
                        const highlightLevel = step < 4 ? 2 : step < 6 ? 1 : 0;
                        const highlightNode = step % Math.pow(2, highlightLevel);
                        const hx = width / (Math.pow(2, highlightLevel) + 1) * (highlightNode + 1);
                        const hy = baseY + highlightLevel * levelHeight;
                        
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 1.0;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(hx, hy, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚à¥ Q.E.D.', cx - 15, height - 8);
                    }
                    
                    // MODE 1: SET OPERATIONS (Venn diagram dynamics)
                    else if (mode === 1) {
                        const r = 22;
                        const offset = 15;
                        const breathe = Math.sin(time) * 3;
                        
                        // Set A
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(cx - offset + breathe, cy, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#3b82f6';
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                        
                        // Set B
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath();
                        ctx.arc(cx + offset - breathe, cy, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ef4444';
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                        
                        // Intersection highlight
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#a855f7';
                        ctx.beginPath();
                        ctx.arc(cx, cy, r * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Labels
                        ctx.font = '10px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('A', cx - offset - r + 5, cy);
                        ctx.fillText('B', cx + offset + r - 12, cy);
                        ctx.fillText('A‚à©B', cx - 8, cy + 3);
                    }
                    
                    // MODE 2: FUNCTION MAPPING (Domain ‚Üí Codomain)
                    else if (mode === 2) {
                        // Domain (left circle)
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.ellipse(cx - 40, cy, 25, 30, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Codomain (right circle)
                        ctx.beginPath();
                        ctx.ellipse(cx + 40, cy, 25, 30, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Domain points
                        const domainPts = [
                            { y: -15 }, { y: 0 }, { y: 15 }
                        ];
                        
                        domainPts.forEach((pt, i) => {
                            const dx = cx - 40;
                            const dy = cy + pt.y;
                            
                            ctx.fillStyle = CATEGORY_HEX['foundations'];
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(dx, dy, 3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Arrow to codomain
                            const targetY = cy + Math.sin(time + i) * 20;
                            const progress = (Math.sin(time * 2 + i) + 1) / 2;
                            const arrowX = dx + (cx + 40 - dx) * progress;
                            const arrowY = dy + (targetY - dy) * progress;
                            
                            ctx.strokeStyle = CATEGORY_HEX['foundations'];
                            ctx.globalAlpha = 0.5;
                            ctx.setLineDash([3, 3]);
                            ctx.beginPath();
                            ctx.moveTo(dx + 5, dy);
                            ctx.quadraticCurveTo(cx, dy + (targetY - dy) * 0.5, cx + 35, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Moving point
                            ctx.fillStyle = '#fff';
                            ctx.globalAlpha = 1.0;
                            ctx.beginPath();
                            ctx.arc(arrowX, arrowY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        ctx.font = '9px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('f: X ‚Üí Y', cx - 18, height - 5);
                    }
                    
                    // MODE 3: INDUCTION STEPS (n ‚Üí n+1)
                    else if (mode === 3) {
                        const step = Math.floor(time * 0.6) % 6;
                        const stepWidth = (width - 20) / 6;
                        
                        // Draw dominoes falling
                        for (let i = 0; i <= 5; i++) {
                            const x = 10 + i * stepWidth + stepWidth / 2;
                            const fallen = i < step || (i === step && (time * 0.6) % 1 > 0.5);
                            const falling = i === step && (time * 0.6) % 1 <= 0.5;
                            
                            ctx.save();
                            ctx.translate(x, cy + 15);
                            
                            if (falling) {
                                const angle = ((time * 0.6) % 1) * Math.PI / 2;
                                ctx.rotate(angle);
                            } else if (fallen) {
                                ctx.rotate(Math.PI / 2);
                            }
                            
                            ctx.fillStyle = fallen || falling ? '#10b981' : CATEGORY_HEX['foundations'];
                            ctx.globalAlpha = 0.8;
                            ctx.fillRect(-4, -20, 8, 35);
                            
                            ctx.strokeStyle = '#fff';
                            ctx.globalAlpha = 0.5;
                            ctx.strokeRect(-4, -20, 8, 35);
                            
                            ctx.restore();
                            
                            // Label
                            ctx.font = '8px monospace';
                            ctx.fillStyle = '#888';
                            ctx.globalAlpha = 0.7;
                            ctx.fillText(i === 0 ? 'P(1)' : `P(${i + 1})`, x - 10, cy + 45);
                        }
                        
                        // Arrow showing implication
                        ctx.strokeStyle = '#10b981';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(20, cy - 25);
                        ctx.lineTo(width - 20, cy - 25);
                        ctx.stroke();
                        ctx.fillText('P(n) ‚üπ P(n+1)', cx - 30, cy - 30);
                    }
                    
                    // MODE 4: AXIOM SYSTEM (Building blocks)
                    else if (mode === 4) {
                        const blockSize = 18;
                        const cols = 5;
                        const rows = 3;
                        const startX = cx - (cols * blockSize) / 2;
                        const startY = cy - (rows * blockSize) / 2;
                        
                        // Draw axiom blocks
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                const x = startX + c * blockSize;
                                const y = startY + r * blockSize;
                                
                                // Staggered appearance
                                const delay = r * 0.3 + c * 0.1;
                                const alpha = Math.max(0, Math.sin(time - delay) * 0.5 + 0.5);
                                
                                // Color based on "axiom type"
                                const colors = ['#3b82f6', '#10b981', '#f97316', '#a855f7', '#ef4444'];
                                ctx.fillStyle = colors[(r + c) % colors.length];
                                ctx.globalAlpha = alpha * 0.6;
                                ctx.fillRect(x + 1, y + 1, blockSize - 2, blockSize - 2);
                                
                                ctx.strokeStyle = '#fff';
                                ctx.globalAlpha = alpha * 0.3;
                                ctx.strokeRect(x + 1, y + 1, blockSize - 2, blockSize - 2);
                            }
                        }
                        
                        // Label
                        ctx.font = '8px serif';
                        ctx.fillStyle = '#888';
                        ctx.globalAlpha = 1.0;
                        ctx.fillText('ZFC Axioms', cx - 25, height - 5);
                    }
                    
                    ctx.globalAlpha = 1.0;
                }
            };

            // ============================================================
            // HERO NODE OVERRIDES (Node-Specific PhD Visualizations)
            // ============================================================

            const HERO_NODES = {
                // HOPF FIBRATION: Villarceau circles (linked S¬π fibers)
                'hopf-fibration': (ctx, time) => {
                    const r = 30;
                    const speed = time * 0.6;
                    
                    // Draw multiple linked fibers at different base points
                    const numFibers = 5;
                    for(let f=0; f<numFibers; f++) {
                        const phase = (f/numFibers) * Math.PI * 2;
                        const x1 = cx + Math.cos(speed + phase) * 15;
                        const tilt = speed + phase;
                        const z = Math.sin(speed + phase);
                        
                        ctx.beginPath();
                        ctx.ellipse(x1, cy, r * 0.8, r*0.3, tilt, 0, Math.PI*2);
                        ctx.strokeStyle = z > 0 ? CATEGORY_HEX['topology'] : '#ffffff';
                        ctx.lineWidth = z > 0 ? 2 : 1;
                        ctx.globalAlpha = 0.3 + Math.abs(z) * 0.5;
                        ctx.stroke();
                    }
                    
                    // Highlight one fiber with flowing point
                    const pSpeed = time * 2.5;
                    const mainX = cx + Math.cos(speed) * 15;
                    const mainTilt = speed;
                    const px = mainX + Math.cos(pSpeed)*r*0.8*Math.cos(mainTilt) - Math.sin(pSpeed)*r*0.3*Math.sin(mainTilt);
                    const py = cy + Math.cos(pSpeed)*r*0.8*Math.sin(mainTilt) + Math.sin(pSpeed)*r*0.3*Math.cos(mainTilt);
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI*2);
                    ctx.fill();
                },

                // QUATERNIONS: 3-sphere rotation via stereographic projection
                'quaternions': (ctx, time) => {
                    const r = 30;
                    
                    // Draw three orthogonal great circles (i, j, k directions)
                    const circles = [
                        { color: '#ff6b6b', phase: 0 },        // i
                        { color: '#4ecdc4', phase: Math.PI/2 }, // j  
                        { color: '#a855f7', phase: Math.PI }    // k
                    ];
                    
                    circles.forEach(c => {
                        const tilt = time * 0.5 + c.phase;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, r, r * Math.abs(Math.cos(tilt)), tilt * 0.5, 0, Math.PI*2);
                        ctx.strokeStyle = c.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                    });
                    
                    // Draw quaternion multiplication path
                    const t = time * 1.5;
                    const qx = cx + Math.cos(t) * Math.cos(t*0.7) * r * 0.6;
                    const qy = cy + Math.sin(t) * Math.cos(t*0.5) * r * 0.6;
                    
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(qx, qy, 4, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Label
                    ctx.font = '10px serif';
                    ctx.fillText('S¬≥', cx - 5, cy + 3);
                },

                // COMPLEX ANALYSIS: Riemann sphere / M√∂bius transformations
                'complex-numbers': (ctx, time) => {
                    const r = 32;
                    
                    // Draw Riemann sphere projection
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI*2);
                    ctx.strokeStyle = CATEGORY_HEX['analysis'];
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    
                    // Latitude lines
                    for(let lat = -0.6; lat <= 0.6; lat += 0.3) {
                        const yOff = lat * r;
                        const rLat = Math.sqrt(r*r - yOff*yOff);
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + yOff, rLat, rLat * 0.3, 0, 0, Math.PI*2);
                        ctx.globalAlpha = 0.3;
                        ctx.stroke();
                    }
                    
                    // Rotating meridian
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, r, r * 0.3, time * 0.5, 0, Math.PI*2);
                    ctx.globalAlpha = 0.7;
                    ctx.stroke();
                    
                    // Point tracing M√∂bius transformation
                    const t = time * 0.8;
                    // z ‚Üí (az+b)/(cz+d) creates circles and lines
                    const traceR = 20;
                    const px = cx + Math.cos(t) * traceR;
                    const py = cy + Math.sin(t * 2) * traceR * 0.5;
                    
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Infinity point
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(cx, cy - r + 3, 3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.font = '9px serif';
                    ctx.fillStyle = '#888';
                    ctx.fillText('‚àû', cx + 6, cy - r + 6);
                },

                // LIE GROUPS: Exponential map from ùî§ to G
                'lie-groups': (ctx, time) => {
                    // Draw the Lie group manifold (circle for U(1))
                    ctx.beginPath();
                    ctx.arc(cx + 20, cy, 30, 0, Math.PI*2);
                    ctx.strokeStyle = CATEGORY_HEX['algebra'];
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.stroke();
                    
                    // Draw the Lie algebra (tangent line at identity)
                    ctx.beginPath();
                    ctx.moveTo(cx - 60, cy);
                    ctx.lineTo(cx - 10, cy);
                    ctx.strokeStyle = '#a855f7';
                    ctx.globalAlpha = 0.8;
                    ctx.stroke();
                    
                    // Arrow showing exp map
                    ctx.beginPath();
                    ctx.moveTo(cx - 30, cy - 15);
                    ctx.quadraticCurveTo(cx, cy - 25, cx + 20, cy - 30);
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([4, 4]);
                    ctx.globalAlpha = 0.6;
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Flowing point on algebra
                    const algX = cx - 35 + Math.sin(time * 2) * 20;
                    ctx.fillStyle = '#a855f7';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(algX, cy, 4, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Corresponding point on group
                    const groupAngle = Math.sin(time * 2) * Math.PI * 0.8;
                    const groupX = cx + 20 + Math.cos(groupAngle - Math.PI/2) * 30;
                    const groupY = cy + Math.sin(groupAngle - Math.PI/2) * 30;
                    ctx.fillStyle = CATEGORY_HEX['algebra'];
                    ctx.beginPath();
                    ctx.arc(groupX, groupY, 4, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Labels
                    ctx.font = '10px serif';
                    ctx.fillStyle = '#888';
                    ctx.fillText('ùî§', cx - 55, cy - 8);
                    ctx.fillText('G', cx + 55, cy - 8);
                    ctx.fillStyle = '#fff';
                    ctx.fillText('exp', cx - 8, cy - 28);
                },

                // ALGEBRAIC TOPOLOGY: Fundamental group œÄ‚ÇÅ
                'algebraic-topology': (ctx, time) => {
                    // Draw torus (genus 1 surface)
                    const R = 28, r = 12;
                    
                    ctx.strokeStyle = CATEGORY_HEX['topology'];
                    ctx.lineWidth = 1;
                    
                    // Draw torus wireframe
                    for(let u = 0; u < Math.PI * 2; u += 0.5) {
                        ctx.beginPath();
                        for(let v = 0; v < Math.PI * 2.1; v += 0.2) {
                            const x = (R + r * Math.cos(v)) * Math.cos(u);
                            const y = (R + r * Math.cos(v)) * Math.sin(u);
                            const z = r * Math.sin(v);
                            
                            // Rotate for 3D view
                            const rotX = 0.5;
                            const y2 = y * Math.cos(rotX) - z * Math.sin(rotX);
                            const z2 = y * Math.sin(rotX) + z * Math.cos(rotX);
                            
                            const scale = 120 / (120 + z2);
                            const px = cx + x * scale;
                            const py = cy + y2 * scale;
                            
                            if(v === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.globalAlpha = 0.25;
                        ctx.stroke();
                    }
                    
                    // Draw the two generators of œÄ‚ÇÅ(T¬≤) = ‚Ñ§ √ó ‚Ñ§
                    // Alpha loop (around the hole)
                    ctx.beginPath();
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2.5;
                    for(let u = 0; u < Math.PI * 2.1; u += 0.15) {
                        const x = R * Math.cos(u + time * 0.5);
                        const y = R * Math.sin(u + time * 0.5);
                        const rotX = 0.5;
                        const y2 = y * Math.cos(rotX);
                        const px = cx + x;
                        const py = cy + y2;
                        if(u === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.globalAlpha = 0.8;
                    ctx.stroke();
                    
                    // Beta loop (around the tube)
                    ctx.beginPath();
                    ctx.strokeStyle = '#4ecdc4';
                    const uFixed = time * 0.3;
                    for(let v = 0; v < Math.PI * 2.1; v += 0.15) {
                        const x = (R + r * Math.cos(v)) * Math.cos(uFixed);
                        const y = (R + r * Math.cos(v)) * Math.sin(uFixed);
                        const z = r * Math.sin(v);
                        const rotX = 0.5;
                        const y2 = y * Math.cos(rotX) - z * Math.sin(rotX);
                        const z2 = y * Math.sin(rotX) + z * Math.cos(rotX);
                        const scale = 120 / (120 + z2);
                        const px = cx + x * scale;
                        const py = cy + y2 * scale;
                        if(v === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                },

                // FIBER BUNDLES: Principal bundle structure
                'fiber-bundles': (ctx, time) => {
                    // Base space (circle)
                    ctx.beginPath();
                    ctx.arc(cx, cy + 20, 35, 0, Math.PI * 2);
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.stroke();
                    
                    // Draw fibers at various base points
                    const numFibers = 12;
                    for(let i = 0; i < numFibers; i++) {
                        const baseAngle = (i / numFibers) * Math.PI * 2 + time * 0.3;
                        const bx = cx + Math.cos(baseAngle) * 35;
                        const by = cy + 20 + Math.sin(baseAngle) * 35 * 0.4;
                        
                        // Fiber (vertical line with local structure)
                        const fiberHeight = 30;
                        ctx.beginPath();
                        ctx.moveTo(bx, by);
                        ctx.lineTo(bx, by - fiberHeight);
                        ctx.strokeStyle = CATEGORY_HEX['topology'];
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        
                        // Point on fiber
                        const fiberPhase = time * 2 + i * 0.5;
                        const fy = by - fiberHeight/2 + Math.sin(fiberPhase) * fiberHeight * 0.4;
                        ctx.fillStyle = CATEGORY_HEX['topology'];
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.arc(bx, fy, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Labels
                    ctx.font = '9px serif';
                    ctx.fillStyle = '#888';
                    ctx.globalAlpha = 1.0;
                    ctx.fillText('E', cx + 45, cy - 15);
                    ctx.fillText('B', cx + 45, cy + 35);
                    ctx.fillText('œÄ', cx + 50, cy + 10);
                },

                // RIEMANNIAN GEOMETRY: Geodesics on sphere
                'riemannian-geometry': (ctx, time) => {
                    const r = 35;
                    
                    // Sphere
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI*2);
                    ctx.strokeStyle = CATEGORY_HEX['geometry'];
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    
                    // Draw several geodesics (great circles)
                    for(let g = 0; g < 4; g++) {
                        const tilt = time * 0.3 + g * Math.PI / 4;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, r, r * Math.abs(Math.sin(tilt)), tilt, 0, Math.PI*2);
                        ctx.globalAlpha = 0.3 + 0.2 * Math.cos(tilt);
                        ctx.stroke();
                    }
                    
                    // Moving point along geodesic
                    const geoT = time * 1.2;
                    const px = cx + Math.cos(geoT) * r;
                    const py = cy + Math.sin(geoT) * r * 0.4;
                    
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Tangent vector
                    const tx = -Math.sin(geoT) * 15;
                    const ty = Math.cos(geoT) * 15 * 0.4;
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + tx, py + ty);
                    ctx.stroke();
                },

                // SMOOTH MANIFOLDS: Charts and transition maps
                'smooth-manifolds': (ctx, time) => {
                    // Draw two overlapping chart domains
                    const chart1 = { x: cx - 25, y: cy, r: 35 };
                    const chart2 = { x: cx + 25, y: cy, r: 35 };
                    
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = CATEGORY_HEX['geometry'];
                    ctx.beginPath();
                    ctx.arc(chart1.x, chart1.y, chart1.r, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#a855f7';
                    ctx.beginPath();
                    ctx.arc(chart2.x, chart2.y, chart2.r, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Overlap region (transition functions live here)
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(cx, cy, 15, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Coordinate grid in chart 1
                    ctx.strokeStyle = CATEGORY_HEX['geometry'];
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    for(let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo(chart1.x - 25, chart1.y + i * 8);
                        ctx.lineTo(chart1.x + 10, chart1.y + i * 8);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(chart1.x + i * 8 - 8, chart1.y - 20);
                        ctx.lineTo(chart1.x + i * 8 - 8, chart1.y + 20);
                        ctx.stroke();
                    }
                    
                    // Transformed grid in chart 2 (showing diffeomorphism)
                    ctx.strokeStyle = '#a855f7';
                    const warp = Math.sin(time) * 0.3;
                    for(let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        for(let j = -3; j <= 1; j++) {
                            const x = chart2.x + j * 8 + 8;
                            const y = chart2.y + i * 8 + Math.sin(j * 0.5 + time) * 3;
                            if(j === -3) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // Point moving through transition
                    const pt = (Math.sin(time * 0.8) + 1) / 2;
                    const px = cx - 30 + pt * 60;
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(px, cy, 3, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Labels
                    ctx.font = '9px serif';
                    ctx.fillStyle = '#888';
                    ctx.fillText('(U,œÜ)', chart1.x - 30, chart1.y + 30);
                    ctx.fillText('(V,œà)', chart2.x + 15, chart2.y + 30);
                },

                // CALCULUS: Derivative as tangent line
                'calculus': (ctx, time) => {
                    // Draw function curve
                    ctx.beginPath();
                    for(let x = 0; x < width; x += 2) {
                        const normX = (x / width) * 4 - 2;
                        const y = cy - (Math.sin(normX * 1.5) * 25 + normX * 5);
                        if(x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = CATEGORY_HEX['analysis'];
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.stroke();
                    
                    // Moving point
                    const t = (time * 0.5) % 4 - 2;
                    const px = (t + 2) / 4 * width;
                    const py = cy - (Math.sin(t * 1.5) * 25 + t * 5);
                    
                    // Derivative (slope of tangent)
                    const slope = -(Math.cos(t * 1.5) * 1.5 * 25 / width * 4 + 5);
                    
                    // Tangent line
                    ctx.beginPath();
                    ctx.moveTo(px - 40, py - slope * 40);
                    ctx.lineTo(px + 40, py + slope * 40);
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 1.0;
                    ctx.stroke();
                    
                    // Point
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI*2);
                    ctx.fill();
                    
                    // dy/dx visualization
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + 30, py);
                    ctx.lineTo(px + 30, py + slope * 30);
                    ctx.stroke();
                    ctx.setLineDash([]);
                },

                // REAL ANALYSIS: Epsilon-delta convergence
                'real-analysis': (ctx, time) => {
                    // Sequence converging to limit
                    const limit = cy;
                    const epsilon = 25 * (0.3 + 0.7 * Math.exp(-time * 0.5));
                    
                    // Epsilon band
                    ctx.fillStyle = CATEGORY_HEX['analysis'] + '22';
                    ctx.fillRect(0, limit - epsilon, width, epsilon * 2);
                    
                    ctx.strokeStyle = CATEGORY_HEX['analysis'];
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, limit - epsilon);
                    ctx.lineTo(width, limit - epsilon);
                    ctx.moveTo(0, limit + epsilon);
                    ctx.lineTo(width, limit + epsilon);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Sequence terms a_n = L + (-1)^n / n
                    const numTerms = 15;
                    for(let n = 1; n <= numTerms; n++) {
                        const x = (n / numTerms) * (width - 20) + 10;
                        const term = limit + Math.pow(-1, n) * 30 / n;
                        
                        ctx.fillStyle = Math.abs(term - limit) < epsilon ? '#4ecdc4' : '#ff6b6b';
                        ctx.globalAlpha = 0.5 + n / numTerms * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, term, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Limit line
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, limit);
                    ctx.lineTo(width, limit);
                    ctx.stroke();
                    
                    // Label
                    ctx.font = '9px serif';
                    ctx.fillStyle = '#888';
                    ctx.globalAlpha = 1.0;
                    ctx.fillText('L', width - 15, limit - 5);
                    ctx.fillText('Œµ', width - 15, limit - epsilon - 5);
                },

                // POINT-SET TOPOLOGY: Open sets and continuity
                'point-set-topology': (ctx, time) => {
                    // Domain space
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx - 40, cy, 30, 0, Math.PI*2);
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    
                    // Codomain space
                    ctx.beginPath();
                    ctx.arc(cx + 40, cy, 30, 0, Math.PI*2);
                    ctx.stroke();
                    
                    // Open set in codomain (neighborhood of f(x))
                    const openR = 12 + Math.sin(time * 2) * 4;
                    ctx.fillStyle = CATEGORY_HEX['topology'] + '44';
                    ctx.beginPath();
                    ctx.arc(cx + 40, cy, openR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = CATEGORY_HEX['topology'];
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.8;
                    ctx.stroke();
                    
                    // Preimage (open set in domain)
                    const preimageR = openR * 0.8;
                    ctx.fillStyle = '#a855f7' + '44';
                    ctx.beginPath();
                    ctx.arc(cx - 40, cy, preimageR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = '#a855f7';
                    ctx.stroke();
                    
                    // Arrow showing f
                    ctx.beginPath();
                    ctx.moveTo(cx - 5, cy - 20);
                    ctx.quadraticCurveTo(cx, cy - 30, cx + 5, cy - 20);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6;
                    ctx.stroke();
                    
                    // Points
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(cx - 40, cy, 3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(cx + 40, cy, 3, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Labels
                    ctx.font = '9px serif';
                    ctx.fillStyle = '#888';
                    ctx.fillText('X', cx - 50, cy + 35);
                    ctx.fillText('Y', cx + 50, cy + 35);
                    ctx.fillText('f', cx, cy - 32);
                },

                // PROOFS: Logic symbols
                'proofs': (ctx, time) => {
                    const symbols = ['‚àÄ', '‚àÉ', '‚áí', '‚áî', '‚àß', '‚à®', '¬¨'];
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    
                    symbols.forEach((s, i) => {
                        const angle = (i / symbols.length) * Math.PI * 2 + time * 0.5;
                        const r = 30;
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        
                        ctx.fillStyle = CATEGORY_HEX['analysis'];
                        ctx.globalAlpha = 0.5 + 0.3 * Math.sin(time * 2 + i);
                        ctx.fillText(s, x, y + 5);
                    });
                    
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = '#fff';
                    ctx.fillText('‚à¥', cx, cy + 5);
                    ctx.textAlign = 'left';
                },

                // ABSTRACT ALGEBRA: Group operation table
                'abstract-algebra': (ctx, time) => {
                    const n = 4; // Z_4
                    const cellSize = 16;
                    const startX = cx - (n * cellSize) / 2;
                    const startY = cy - (n * cellSize) / 2;
                    
                    ctx.strokeStyle = CATEGORY_HEX['algebra'];
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6;
                    
                    // Draw Cayley table
                    for(let i = 0; i <= n; i++) {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY + i * cellSize);
                        ctx.lineTo(startX + n * cellSize, startY + i * cellSize);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(startX + i * cellSize, startY);
                        ctx.lineTo(startX + i * cellSize, startY + n * cellSize);
                        ctx.stroke();
                    }
                    
                    // Fill in group operation (mod n addition)
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    
                    const highlight = Math.floor(time * 2) % (n * n);
                    for(let i = 0; i < n; i++) {
                        for(let j = 0; j < n; j++) {
                            const val = (i + j) % n;
                            const idx = i * n + j;
                            if(idx === highlight) {
                                ctx.fillStyle = CATEGORY_HEX['algebra'];
                                ctx.fillRect(startX + j * cellSize + 1, startY + i * cellSize + 1, cellSize - 2, cellSize - 2);
                                ctx.fillStyle = '#000';
                            } else {
                                ctx.fillStyle = '#fff';
                            }
                            ctx.fillText(val.toString(), startX + j * cellSize + cellSize/2, startY + i * cellSize + cellSize/2 + 3);
                        }
                    }
                    ctx.textAlign = 'left';
                },

                // LINEAR ALGEBRA: Eigenspace visualization
                'linear-algebra-basic': (ctx, time) => {
                    // Draw grid being transformed
                    const scale = 20;
                    
                    // Transformation matrix: rotation + scaling
                    const angle = time * 0.3;
                    const eigenScale = 1.3;
                    
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.3;
                    
                    // Original grid
                    for(let i = -3; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx + i * scale, cy - 60);
                        ctx.lineTo(cx + i * scale, cy + 60);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx - 60, cy + i * scale);
                        ctx.lineTo(cx + 60, cy + i * scale);
                        ctx.stroke();
                    }
                    
                    // Eigenvectors
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2.5;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.moveTo(cx - 40, cy);
                    ctx.lineTo(cx + 40, cy);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#4ecdc4';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - 40);
                    ctx.lineTo(cx, cy + 40);
                    ctx.stroke();
                    
                    // Transformed basis vectors
                    const stretch = 1 + 0.3 * Math.sin(time * 2);
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.globalAlpha = 0.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + 40 * stretch, cy);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#4ecdc4';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx, cy - 40 / stretch);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Labels
                    ctx.font = '10px serif';
                    ctx.fillStyle = '#ff6b6b';
                    ctx.globalAlpha = 1.0;
                    ctx.fillText('Œª‚ÇÅ', cx + 45, cy - 5);
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillText('Œª‚ÇÇ', cx + 5, cy - 45);
                },

                // CONNECTIONS: Gauge field / covariant derivative
                'connections': (ctx, time) => {
                    // Draw base manifold
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + 10, 50, 25, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw connection (horizontal lifts)
                    const numPaths = 6;
                    for(let i = 0; i < numPaths; i++) {
                        const baseAngle = (i / numPaths) * Math.PI * 2;
                        const bx = cx + Math.cos(baseAngle) * 50;
                        const by = cy + 10 + Math.sin(baseAngle) * 25;
                        
                        // Vertical fiber
                        ctx.beginPath();
                        ctx.moveTo(bx, by);
                        ctx.lineTo(bx, by - 40);
                        ctx.strokeStyle = CATEGORY_HEX['physics'];
                        ctx.globalAlpha = 0.3;
                        ctx.stroke();
                        
                        // Horizontal direction (connection)
                        const hAngle = baseAngle + Math.PI/2 + time * 0.5;
                        const hx = Math.cos(hAngle) * 10;
                        const hy = Math.sin(hAngle) * 5 - 5;
                        ctx.beginPath();
                        ctx.moveTo(bx, by - 20);
                        ctx.lineTo(bx + hx, by - 20 + hy);
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.stroke();
                    }
                    
                    // Curvature indicator
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.font = '10px serif';
                    ctx.fillText('F = dA + A‚àßA', cx - 30, cy + 45);
                },

                // APPLICATIONS: Berry phase / quantum geometry
                'applications': (ctx, time) => {
                    // Parameter space (sphere)
                    const r = 30;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    ctx.strokeStyle = CATEGORY_HEX['physics'];
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    
                    // Adiabatic path
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, r * 0.8, r * 0.3, time * 0.2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.8;
                    ctx.stroke();
                    
                    // State vector (acquires phase)
                    const pathT = time * 1.5;
                    const px = cx + Math.cos(pathT) * r * 0.8;
                    const py = cy + Math.sin(pathT) * r * 0.3;
                    
                    // Phase arrow
                    const phaseAngle = pathT * 2; // Berry phase accumulation
                    const arrowLen = 15;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + Math.cos(phaseAngle) * arrowLen, py - Math.sin(phaseAngle) * arrowLen);
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Label
                    ctx.font = '10px serif';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Œ≥ = ‚àÆA¬∑dR', cx - 25, cy + 45);
                },

                // CHARACTERISTIC CLASSES: Chern class visualization
                'characteristic-classes': (ctx, time) => {
                    // Draw bundle over circle
                    ctx.beginPath();
                    ctx.arc(cx, cy + 15, 35, 0, Math.PI * 2);
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.5;
                    ctx.stroke();
                    
                    // Twisted fibers showing non-trivial topology
                    const twist = Math.floor(time) % 3 + 1; // 1, 2, or 3 twists
                    for(let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2;
                        const bx = cx + Math.cos(angle) * 35;
                        const by = cy + 15 + Math.sin(angle) * 35 * 0.4;
                        
                        const fiberAngle = angle * twist + time;
                        const fx = Math.cos(fiberAngle) * 8;
                        const fy = -15 + Math.sin(fiberAngle) * 3;
                        
                        ctx.beginPath();
                        ctx.moveTo(bx, by);
                        ctx.lineTo(bx + fx, by + fy);
                        ctx.strokeStyle = CATEGORY_HEX['topology'];
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        
                        ctx.fillStyle = CATEGORY_HEX['topology'];
                        ctx.beginPath();
                        ctx.arc(bx + fx, by + fy, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Chern number
                    ctx.font = '12px serif';
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1.0;
                    ctx.fillText('c‚ÇÅ = ' + twist, cx - 15, cy - 25);
                },

                // GENERALIZATIONS: Higher Hopf fibrations
                'generalizations': (ctx, time) => {
                    // S^7 ‚Üí S^4 visualization (simplified)
                    const layers = 3;
                    
                    for(let l = 0; l < layers; l++) {
                        const r = 25 - l * 6;
                        const phase = time * (0.5 + l * 0.2) + l * Math.PI / 3;
                        
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, r, r * 0.4, phase, 0, Math.PI * 2);
                        ctx.strokeStyle = l === 0 ? '#ff6b6b' : l === 1 ? '#4ecdc4' : CATEGORY_HEX['topology'];
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.6 - l * 0.15;
                        ctx.stroke();
                    }
                    
                    // Labels for different Hopf fibrations
                    ctx.font = '8px monospace';
                    ctx.fillStyle = '#888';
                    ctx.globalAlpha = 0.8;
                    ctx.fillText('S¬π‚ÜíS¬≥‚ÜíS¬≤', cx - 30, cy + 35);
                    ctx.fillText('S¬≥‚ÜíS‚Å∑‚ÜíS‚Å¥', cx - 30, cy + 45);
                    ctx.fillText('S‚Å∑‚ÜíS¬π‚Åµ‚ÜíS‚Å∏', cx - 30, cy + 55);
                    ctx.globalAlpha = 1.0;
                }
            };

            // ============================================================
            // MAIN RENDER LOOP
            // ============================================================

            function loop() {
                // Check if this loop is still valid (not superseded by a new startMiniViz call)
                if (myGeneration !== vizGeneration) {
                    return; // Stale loop - stop rendering
                }
                
                const now = performance.now();
                const time = (now - startTime) / 1000;
                
                miniVizCtx.clearRect(0, 0, width, height);
                miniVizCtx.globalAlpha = 1.0;
                
                // Read the current mode fresh from the global variable each frame
                const activeMode = currentVizIndex;
                
                try {
                    // Reset canvas state comprehensively before each render to prevent state leakage
                    miniVizCtx.globalAlpha = 1.0;
                    miniVizCtx.setLineDash([]);
                    miniVizCtx.lineWidth = 1.5;
                    miniVizCtx.lineCap = 'butt';
                    miniVizCtx.lineJoin = 'miter';
                    miniVizCtx.textAlign = 'left';
                    miniVizCtx.textBaseline = 'alphabetic';
                    miniVizCtx.font = '10px sans-serif';
                    
                    // 1. Check for Node-Specific Engine first (unique animations per node)
                    if (NODE_SPECIFIC_ENGINES[nodeId]) {
                        NODE_SPECIFIC_ENGINES[nodeId](miniVizCtx, time, activeMode);
                    }
                    // 2. Check for Hero Node overrides (legacy mode 0 only)
                    else if (HERO_NODES[nodeId] && activeMode === 0) {
                        HERO_NODES[nodeId](miniVizCtx, time);
                    }
                    // 3. Fall back to category engine with mode
                    else if (ENGINES[category]) {
                        ENGINES[category](miniVizCtx, time, activeMode);
                    }
                    // 4. Ultimate fallback: elegant wave
                    else {
                        miniVizCtx.beginPath();
                        for(let i=0; i<width; i+=2) {
                            const y = cy + Math.sin(i*0.08 + time*2) * 15 * Math.sin(i*0.02);
                            if(i===0) miniVizCtx.moveTo(i, y);
                            else miniVizCtx.lineTo(i, y);
                        }
                        miniVizCtx.strokeStyle = '#64748b';
                        miniVizCtx.stroke();
                    }
                } catch (e) {
                    // If any animation errors, show a safe fallback
                    console.error('Mini viz render error:', e);
                    miniVizCtx.clearRect(0, 0, width, height);
                    miniVizCtx.beginPath();
                    for(let i=0; i<width; i+=2) {
                        const y = cy + Math.sin(i*0.08 + time*2) * 15;
                        if(i===0) miniVizCtx.moveTo(i, y);
                        else miniVizCtx.lineTo(i, y);
                    }
                    miniVizCtx.strokeStyle = CATEGORY_HEX[category] || '#64748b';
                    miniVizCtx.stroke();
                }

                miniVizRequestId = requestAnimationFrame(loop);
            }
            
            loop();
        }

        // =====================================================
        // TOOLTIP VISUALIZATION (NODE-SPECIFIC ANIMATIONS)
        // =====================================================
        
        let tooltipVizReqId = null;
        let tooltipCanvas = null;
        let tooltipCtx = null;
        let tooltipInitialized = false;

        function startTooltipViz(category, nodeId) {
            // Initialize canvas with proper sizing
            tooltipCanvas = document.getElementById('tooltip-canvas');
            const dpr = window.devicePixelRatio || 1;
            const width = 160;
            const height = 80;
            
            if (!tooltipInitialized) {
                tooltipCanvas.width = width * dpr;
                tooltipCanvas.height = height * dpr;
                tooltipCtx = tooltipCanvas.getContext('2d');
                tooltipCtx.scale(dpr, dpr);
                tooltipInitialized = true;
            }

            if (tooltipVizReqId) cancelAnimationFrame(tooltipVizReqId);

            const startTime = performance.now();
            const cx = width / 2;
            const cy = height / 2;

            function loop() {
                const time = (performance.now() - startTime) / 1000;
                
                // Reset transform to identity then apply DPR scaling (absolute, not cumulative)
                const dpr = window.devicePixelRatio || 1;
                tooltipCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                
                tooltipCtx.clearRect(0, 0, width, height);

                // Reset canvas state comprehensively before each render
                tooltipCtx.globalAlpha = 1.0;
                tooltipCtx.setLineDash([]);
                tooltipCtx.textAlign = 'left';
                tooltipCtx.textBaseline = 'alphabetic';

                const color = CATEGORY_HEX[category] || '#ffffff';
                tooltipCtx.strokeStyle = color;
                tooltipCtx.fillStyle = color;
                tooltipCtx.lineWidth = 1.5;
                tooltipCtx.lineCap = 'round';
                tooltipCtx.lineJoin = 'round';

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // UNIQUE NODE-SPECIFIC ANIMATIONS (PhD-Grade)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // CALCULUS: Tangent line sliding along curve (derivative)
                if (nodeId === 'calculus') {
                    // Draw function curve
                    // Note: Canvas Y increases downward, so we use cy + sin() which makes
                    // positive sin values go DOWN on screen
                    tooltipCtx.beginPath();
                    for(let x=0; x<width; x+=2) {
                        const y = cy + Math.sin(x*0.06) * 20;
                        if(x===0) tooltipCtx.moveTo(x,y); else tooltipCtx.lineTo(x,y);
                    }
                    tooltipCtx.globalAlpha = 0.4;
                    tooltipCtx.stroke();
                    
                    // Moving point with tangent
                    const tx = (time * 50) % width;
                    const ty = cy + Math.sin(tx*0.06) * 20;
                    // Mathematical derivative: d/dx[sin(0.06x)] = 0.06*cos(0.06x)
                    // In canvas space where Y+ is down, slope = dy_canvas/dx = +derivative * amplitude
                    // This gives us the correct visual tangent direction
                    const canvasSlope = Math.cos(tx*0.06) * 0.06 * 20;
                    
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    // For a line with slope m through (tx, ty): y - ty = m(x - tx)
                    // At x = tx - 20: y = ty - 20*m, At x = tx + 20: y = ty + 20*m
                    tooltipCtx.moveTo(tx - 20, ty - 20*canvasSlope);
                    tooltipCtx.lineTo(tx + 20, ty + 20*canvasSlope);
                    tooltipCtx.strokeStyle = '#ff0055';
                    tooltipCtx.stroke();
                    
                    tooltipCtx.beginPath(); 
                    tooltipCtx.arc(tx, ty, 3, 0, Math.PI*2); 
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.fill();
                }
                
                // REAL ANALYSIS: Œµ-Œ¥ convergence visualization
                else if (nodeId === 'real-analysis') {
                    const limit = cy;
                    const epsilon = 20 * (0.3 + 0.7 * Math.exp(-time * 0.8));
                    
                    // Epsilon band
                    tooltipCtx.fillStyle = color + '22';
                    tooltipCtx.fillRect(0, limit - epsilon, width, epsilon * 2);
                    
                    tooltipCtx.setLineDash([4, 4]);
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(0, limit - epsilon);
                    tooltipCtx.lineTo(width, limit - epsilon);
                    tooltipCtx.moveTo(0, limit + epsilon);
                    tooltipCtx.lineTo(width, limit + epsilon);
                    tooltipCtx.globalAlpha = 0.6;
                    tooltipCtx.stroke();
                    tooltipCtx.setLineDash([]);
                    
                    // Sequence terms converging
                    for(let n = 1; n <= 12; n++) {
                        const x = (n / 12) * (width - 20) + 10;
                        const term = limit + Math.pow(-1, n) * 25 / n;
                        tooltipCtx.fillStyle = Math.abs(term - limit) < epsilon ? '#4ecdc4' : '#ff6b6b';
                        tooltipCtx.globalAlpha = 0.4 + n / 12 * 0.6;
                        tooltipCtx.beginPath();
                        tooltipCtx.arc(x, term, 2.5, 0, Math.PI*2);
                        tooltipCtx.fill();
                    }
                    tooltipCtx.globalAlpha = 1.0;
                }

                // COMPLEX NUMBERS: Euler formula e^(iŒ∏) rotating phasor
                else if (nodeId === 'complex-numbers') {
                    const r = 25;
                    const ang = time * 2;
                    
                    // Unit circle
                    tooltipCtx.beginPath(); 
                    tooltipCtx.arc(cx, cy, r, 0, Math.PI*2); 
                    tooltipCtx.globalAlpha = 0.3; 
                    tooltipCtx.stroke();
                    
                    // Real & imaginary axes
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(cx - r - 5, cy);
                    tooltipCtx.lineTo(cx + r + 5, cy);
                    tooltipCtx.moveTo(cx, cy - r - 5);
                    tooltipCtx.lineTo(cx, cy + r + 5);
                    tooltipCtx.globalAlpha = 0.2;
                    tooltipCtx.stroke();
                    
                    // Rotating vector
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath(); 
                    tooltipCtx.moveTo(cx, cy); 
                    tooltipCtx.lineTo(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);
                    tooltipCtx.stroke();
                    
                    // Projections
                    tooltipCtx.setLineDash([3, 3]);
                    tooltipCtx.globalAlpha = 0.5;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);
                    tooltipCtx.lineTo(cx + Math.cos(ang)*r, cy);
                    tooltipCtx.moveTo(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);
                    tooltipCtx.lineTo(cx, cy + Math.sin(ang)*r);
                    tooltipCtx.stroke();
                    tooltipCtx.setLineDash([]);
                    
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r, 3, 0, Math.PI*2);
                    tooltipCtx.fill();
                }

                // LINEAR ALGEBRA: Eigenvector / eigenvalue visualization
                else if (nodeId === 'linear-algebra-basic') {
                    const scale = 15;
                    
                    // Draw grid being stretched along eigenvectors
                    tooltipCtx.globalAlpha = 0.2;
                    for(let i = -3; i <= 3; i++) {
                        tooltipCtx.beginPath();
                        tooltipCtx.moveTo(cx + i * scale, cy - 40);
                        tooltipCtx.lineTo(cx + i * scale, cy + 40);
                        tooltipCtx.stroke();
                        tooltipCtx.beginPath();
                        tooltipCtx.moveTo(cx - 60, cy + i * scale);
                        tooltipCtx.lineTo(cx + 60, cy + i * scale);
                        tooltipCtx.stroke();
                    }
                    
                    // Eigenvectors (get stretched, not rotated)
                    const stretch = 1 + 0.4 * Math.sin(time * 2);
                    
                    tooltipCtx.strokeStyle = '#ff6b6b';
                    tooltipCtx.lineWidth = 2;
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(cx - 35 * stretch, cy);
                    tooltipCtx.lineTo(cx + 35 * stretch, cy);
                    tooltipCtx.stroke();
                    
                    tooltipCtx.strokeStyle = '#4ecdc4';
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(cx, cy - 25 / stretch);
                    tooltipCtx.lineTo(cx, cy + 25 / stretch);
                    tooltipCtx.stroke();
                    
                    // Labels
                    tooltipCtx.font = '9px serif';
                    tooltipCtx.fillStyle = '#ff6b6b';
                    tooltipCtx.fillText('Œª‚ÇÅv‚ÇÅ', cx + 40, cy - 3);
                    tooltipCtx.fillStyle = '#4ecdc4';
                    tooltipCtx.fillText('Œª‚ÇÇv‚ÇÇ', cx + 3, cy - 30);
                }

                // ABSTRACT ALGEBRA: Cyclic group permutation
                else if (nodeId === 'abstract-algebra') {
                    const n = 5;
                    const r = 25;
                    const tick = Math.floor(time * 1.5) % n;
                    const phase = (time * 1.5) % 1;
                    const ease = phase * phase * (3 - 2 * phase);
                    
                    // Draw vertices
                    for(let i = 0; i < n; i++) {
                        const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        
                        const isActive = i === tick;
                        tooltipCtx.fillStyle = isActive ? '#fff' : color;
                        tooltipCtx.globalAlpha = isActive ? 1.0 : 0.5;
                        tooltipCtx.beginPath();
                        tooltipCtx.arc(x, y, isActive ? 5 : 3, 0, Math.PI*2);
                        tooltipCtx.fill();
                        
                        // Label
                        tooltipCtx.font = '8px monospace';
                        tooltipCtx.fillText(i.toString(), x + 8, y + 3);
                    }
                    
                    // Draw rotation arrow
                    tooltipCtx.strokeStyle = color;
                    tooltipCtx.globalAlpha = 0.5;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, r + 8, -Math.PI * 0.7, Math.PI * 0.5);
                    tooltipCtx.stroke();
                    
                    // Arrowhead
                    tooltipCtx.fillStyle = color;
                    const arrowAngle = Math.PI * 0.5;
                    const ax = cx + Math.cos(arrowAngle) * (r + 8);
                    const ay = cy + Math.sin(arrowAngle) * (r + 8);
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(ax, ay);
                    tooltipCtx.lineTo(ax - 5, ay - 5);
                    tooltipCtx.lineTo(ax + 3, ay - 3);
                    tooltipCtx.fill();
                    tooltipCtx.globalAlpha = 1.0;
                }

                // LIE GROUPS: exp: ùî§ ‚Üí G visualization
                else if (nodeId === 'lie-groups') {
                    // Lie algebra (tangent space)
                    tooltipCtx.strokeStyle = '#a855f7';
                    tooltipCtx.lineWidth = 1;
                    tooltipCtx.globalAlpha = 0.6;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(10, cy);
                    tooltipCtx.lineTo(60, cy);
                    tooltipCtx.stroke();
                    
                    // Lie group (circle)
                    tooltipCtx.strokeStyle = color;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + 30, cy, 22, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    // Exponential map arrow
                    tooltipCtx.strokeStyle = '#fff';
                    tooltipCtx.setLineDash([3, 3]);
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(50, cy - 10);
                    tooltipCtx.quadraticCurveTo(70, cy - 25, 90, cy - 22);
                    tooltipCtx.stroke();
                    tooltipCtx.setLineDash([]);
                    
                    // Moving point
                    const t = Math.sin(time * 1.5);
                    const algX = 35 + t * 20;
                    tooltipCtx.fillStyle = '#a855f7';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(algX, cy, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    const groupAngle = t * Math.PI * 0.7 - Math.PI / 2;
                    tooltipCtx.fillStyle = color;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + 30 + Math.cos(groupAngle) * 22, cy + Math.sin(groupAngle) * 22, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    tooltipCtx.font = '8px serif';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.fillText('ùî§', 15, cy - 8);
                    tooltipCtx.fillText('G', cx + 55, cy - 8);
                }

                // POINT-SET TOPOLOGY: Open set / preimage
                else if (nodeId === 'point-set-topology') {
                    // Domain
                    tooltipCtx.strokeStyle = '#888';
                    tooltipCtx.globalAlpha = 0.4;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx - 35, cy, 22, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    // Codomain
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + 35, cy, 22, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    // Open set (breathing)
                    const openR = 10 + Math.sin(time * 2) * 3;
                    tooltipCtx.fillStyle = color + '44';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + 35, cy, openR, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    tooltipCtx.strokeStyle = color;
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.stroke();
                    
                    // Preimage
                    tooltipCtx.fillStyle = '#a855f7' + '44';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx - 35, cy, openR * 0.7, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    tooltipCtx.strokeStyle = '#a855f7';
                    tooltipCtx.stroke();
                    
                    // Arrow
                    tooltipCtx.strokeStyle = '#fff';
                    tooltipCtx.globalAlpha = 0.5;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(cx - 10, cy - 15);
                    tooltipCtx.lineTo(cx + 10, cy - 15);
                    tooltipCtx.stroke();
                    
                    tooltipCtx.font = '8px serif';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillText('f‚Åª¬π(U)', cx - 50, cy + 30);
                    tooltipCtx.fillText('U', cx + 45, cy + 5);
                }

                // ALGEBRAIC TOPOLOGY: œÄ‚ÇÅ fundamental group loops
                else if (nodeId === 'algebraic-topology') {
                    // Puncture (obstruction)
                    tooltipCtx.fillStyle = '#ff4444';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    // Homotopy class of loops
                    const numLoops = 3;
                    for(let l = 0; l < numLoops; l++) {
                        const phase = l * 0.3 + time * 0.5;
                        const wobble = Math.sin(phase * 4) * 3;
                        const r = 18 + l * 6 + wobble;
                        
                        tooltipCtx.beginPath();
                        for(let i = 0; i <= 50; i++) {
                            const t = (i / 50) * Math.PI * 2;
                            const perturb = Math.sin(t * 3 + phase) * 4;
                            const x = cx + Math.cos(t) * (r + perturb);
                            const y = cy + Math.sin(t) * (r + perturb);
                            if(i === 0) tooltipCtx.moveTo(x, y);
                            else tooltipCtx.lineTo(x, y);
                        }
                        tooltipCtx.closePath();
                        tooltipCtx.strokeStyle = color;
                        tooltipCtx.globalAlpha = 0.6 - l * 0.15;
                        tooltipCtx.stroke();
                    }
                    tooltipCtx.globalAlpha = 1.0;
                }

                // FIBER BUNDLES: E ‚Üí B with fibers
                else if (nodeId === 'fiber-bundles') {
                    // Base space
                    tooltipCtx.strokeStyle = '#888';
                    tooltipCtx.globalAlpha = 0.5;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(20, cy + 20);
                    tooltipCtx.lineTo(width - 20, cy + 20);
                    tooltipCtx.stroke();
                    
                    // Fibers
                    const numFibers = 8;
                    for(let i = 0; i < numFibers; i++) {
                        const x = 25 + (i / (numFibers - 1)) * (width - 50);
                        tooltipCtx.beginPath();
                        tooltipCtx.moveTo(x, cy + 20);
                        tooltipCtx.lineTo(x, cy - 25);
                        tooltipCtx.strokeStyle = color;
                        tooltipCtx.globalAlpha = 0.3;
                        tooltipCtx.stroke();
                        
                        // Point on fiber
                        const fiberY = cy + 20 - 22 * (0.5 + 0.4 * Math.sin(time * 2 + i * 0.8));
                        tooltipCtx.fillStyle = color;
                        tooltipCtx.globalAlpha = 0.8;
                        tooltipCtx.beginPath();
                        tooltipCtx.arc(x, fiberY, 2, 0, Math.PI * 2);
                        tooltipCtx.fill();
                    }
                    
                    tooltipCtx.font = '8px serif';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillText('E', width - 15, cy - 20);
                    tooltipCtx.fillText('B', width - 15, cy + 30);
                }

                // RIEMANNIAN GEOMETRY: Geodesics on curved surface
                else if (nodeId === 'riemannian-geometry') {
                    const r = 25;
                    
                    // Sphere outline
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, r, 0, Math.PI * 2);
                    tooltipCtx.globalAlpha = 0.3;
                    tooltipCtx.stroke();
                    
                    // Multiple geodesics (great circles)
                    for(let g = 0; g < 3; g++) {
                        const tilt = time * 0.4 + g * Math.PI / 3;
                        tooltipCtx.beginPath();
                        tooltipCtx.ellipse(cx, cy, r, r * Math.abs(Math.sin(tilt)), tilt * 0.5, 0, Math.PI * 2);
                        tooltipCtx.globalAlpha = 0.4;
                        tooltipCtx.stroke();
                    }
                    
                    // Moving point with tangent
                    const geoT = time * 1.5;
                    const px = cx + Math.cos(geoT) * r;
                    const py = cy + Math.sin(geoT) * r * 0.4;
                    
                    tooltipCtx.strokeStyle = '#ff0055';
                    tooltipCtx.lineWidth = 2;
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(px, py);
                    tooltipCtx.lineTo(px - Math.sin(geoT) * 12, py + Math.cos(geoT) * 12 * 0.4);
                    tooltipCtx.stroke();
                    
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(px, py, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                }

                // SMOOTH MANIFOLDS: Charts and overlap
                else if (nodeId === 'smooth-manifolds') {
                    // Two overlapping charts
                    tooltipCtx.fillStyle = color + '33';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx - 20, cy, 28, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    tooltipCtx.fillStyle = '#a855f7' + '33';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx + 20, cy, 28, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    // Overlap region
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 0.3;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, 12, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    // Point moving through
                    const pt = (Math.sin(time) + 1) / 2;
                    const px = cx - 35 + pt * 70;
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(px, cy, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                    
                    tooltipCtx.font = '8px serif';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.fillText('(U,œÜ)', cx - 45, cy + 30);
                    tooltipCtx.fillText('(V,œà)', cx + 25, cy + 30);
                }

                // HOPF FIBRATION: Linked circles
                else if (nodeId === 'hopf-fibration') {
                    const r = 18;
                    const speed = time * 0.8;
                    
                    // Two linked fibers
                    const x1 = cx + Math.cos(speed) * 8;
                    const x2 = cx - Math.cos(speed) * 8;
                    const z1 = Math.sin(speed);
                    
                    const drawFiber = (x, z, phase, col) => {
                        tooltipCtx.beginPath();
                        tooltipCtx.ellipse(x, cy, r, r * 0.35, phase, 0, Math.PI * 2);
                        tooltipCtx.strokeStyle = col;
                        tooltipCtx.lineWidth = z > 0 ? 2 : 1;
                        tooltipCtx.globalAlpha = z > 0 ? 1.0 : 0.4;
                        tooltipCtx.stroke();
                    };
                    
                    if(z1 > 0) {
                        drawFiber(x2, -z1, speed + Math.PI/2, '#fff');
                        drawFiber(x1, z1, speed, color);
                    } else {
                        drawFiber(x1, z1, speed, color);
                        drawFiber(x2, -z1, speed + Math.PI/2, '#fff');
                    }
                    
                    // Flowing point
                    const pSpeed = time * 2;
                    const px = x1 + Math.cos(pSpeed)*r*Math.cos(speed) - Math.sin(pSpeed)*r*0.35*Math.sin(speed);
                    const py = cy + Math.cos(pSpeed)*r*Math.sin(speed) + Math.sin(pSpeed)*r*0.35*Math.cos(speed);
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(px, py, 3, 0, Math.PI*2);
                    tooltipCtx.fill();
                }

                // QUATERNIONS: 3-sphere structure
                else if (nodeId === 'quaternions') {
                    // Three orthogonal circles (i, j, k)
                    const circles = [
                        { color: '#ff6b6b', phase: 0 },
                        { color: '#4ecdc4', phase: Math.PI/3 },
                        { color: '#a855f7', phase: 2*Math.PI/3 }
                    ];
                    
                    circles.forEach(c => {
                        const tilt = time * 0.5 + c.phase;
                        tooltipCtx.beginPath();
                        tooltipCtx.ellipse(cx, cy, 22, 22 * Math.abs(Math.cos(tilt)), tilt * 0.5, 0, Math.PI * 2);
                        tooltipCtx.strokeStyle = c.color;
                        tooltipCtx.lineWidth = 1.5;
                        tooltipCtx.globalAlpha = 0.6;
                        tooltipCtx.stroke();
                    });
                    
                    tooltipCtx.font = '9px serif';
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillText('S¬≥', cx - 5, cy + 3);
                }

                // CONNECTIONS: Gauge field arrows
                else if (nodeId === 'connections') {
                    // Base circle
                    tooltipCtx.strokeStyle = '#888';
                    tooltipCtx.globalAlpha = 0.4;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy + 10, 25, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    // Connection vectors (horizontal directions)
                    const numVecs = 8;
                    for(let i = 0; i < numVecs; i++) {
                        const angle = (i / numVecs) * Math.PI * 2;
                        const bx = cx + Math.cos(angle) * 25;
                        const by = cy + 10 + Math.sin(angle) * 25 * 0.4;
                        
                        const hAngle = angle + Math.PI/2 + time * 0.5;
                        tooltipCtx.beginPath();
                        tooltipCtx.moveTo(bx, by);
                        tooltipCtx.lineTo(bx + Math.cos(hAngle) * 10, by + Math.sin(hAngle) * 4 - 6);
                        tooltipCtx.strokeStyle = '#ff0055';
                        tooltipCtx.lineWidth = 1.5;
                        tooltipCtx.globalAlpha = 0.8;
                        tooltipCtx.stroke();
                    }
                    
                    tooltipCtx.font = '8px serif';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillText('A', cx + 30, cy);
                }

                // APPLICATIONS: Berry phase loop
                else if (nodeId === 'applications') {
                    // Parameter space
                    tooltipCtx.strokeStyle = color;
                    tooltipCtx.globalAlpha = 0.3;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, 25, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    // Adiabatic path
                    tooltipCtx.beginPath();
                    tooltipCtx.ellipse(cx, cy, 20, 10, time * 0.2, 0, Math.PI * 2);
                    tooltipCtx.strokeStyle = '#fff';
                    tooltipCtx.lineWidth = 1.5;
                    tooltipCtx.globalAlpha = 0.7;
                    tooltipCtx.stroke();
                    
                    // Moving state with phase
                    const t = time * 1.5;
                    const px = cx + Math.cos(t) * 20;
                    const py = cy + Math.sin(t) * 10;
                    const phaseAngle = t * 2;
                    
                    tooltipCtx.beginPath();
                    tooltipCtx.moveTo(px, py);
                    tooltipCtx.lineTo(px + Math.cos(phaseAngle) * 10, py - Math.sin(phaseAngle) * 10);
                    tooltipCtx.strokeStyle = '#ff0055';
                    tooltipCtx.lineWidth = 2;
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.stroke();
                    
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(px, py, 3, 0, Math.PI * 2);
                    tooltipCtx.fill();
                }

                // CHARACTERISTIC CLASSES: Chern number visualization
                else if (nodeId === 'characteristic-classes') {
                    // Bundle with twist
                    tooltipCtx.strokeStyle = '#888';
                    tooltipCtx.globalAlpha = 0.4;
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy + 10, 25, 0, Math.PI * 2);
                    tooltipCtx.stroke();
                    
                    const twist = Math.floor(time) % 3 + 1;
                    for(let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const bx = cx + Math.cos(angle) * 25;
                        const by = cy + 10 + Math.sin(angle) * 25 * 0.35;
                        
                        const fiberAngle = angle * twist + time;
                        const fx = Math.cos(fiberAngle) * 8;
                        const fy = -12 + Math.sin(fiberAngle) * 3;
                        
                        tooltipCtx.beginPath();
                        tooltipCtx.moveTo(bx, by);
                        tooltipCtx.lineTo(bx + fx, by + fy);
                        tooltipCtx.strokeStyle = color;
                        tooltipCtx.lineWidth = 1.5;
                        tooltipCtx.globalAlpha = 0.6;
                        tooltipCtx.stroke();
                    }
                    
                    tooltipCtx.font = '10px serif';
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillText('c‚ÇÅ=' + twist, cx - 12, cy - 22);
                }

                // GENERALIZATIONS: Higher Hopf maps
                else if (nodeId === 'generalizations') {
                    // Multiple nested fibrations
                    const layers = 3;
                    for(let l = 0; l < layers; l++) {
                        const r = 22 - l * 5;
                        const phase = time * (0.5 + l * 0.2) + l * Math.PI / 3;
                        
                        tooltipCtx.beginPath();
                        tooltipCtx.ellipse(cx, cy, r, r * 0.4, phase, 0, Math.PI * 2);
                        tooltipCtx.strokeStyle = l === 0 ? '#ff6b6b' : l === 1 ? '#4ecdc4' : color;
                        tooltipCtx.lineWidth = 1.5;
                        tooltipCtx.globalAlpha = 0.7 - l * 0.2;
                        tooltipCtx.stroke();
                    }
                    
                    tooltipCtx.font = '7px monospace';
                    tooltipCtx.fillStyle = '#888';
                    tooltipCtx.globalAlpha = 0.8;
                    tooltipCtx.fillText('S¬π‚ÜíS¬≥‚ÜíS¬≤', cx - 28, cy + 32);
                    tooltipCtx.fillText('S¬≥‚ÜíS‚Å∑‚ÜíS‚Å¥', cx - 28, cy + 42);
                    tooltipCtx.globalAlpha = 1.0;
                }

                // PROOFS: Logic symbols animation
                else if (nodeId === 'proofs') {
                    const symbols = ['‚àÄ', '‚àÉ', '‚áí', '‚áî', '‚àß', '‚à®'];
                    tooltipCtx.font = '14px serif';
                    tooltipCtx.textAlign = 'center';
                    
                    symbols.forEach((s, i) => {
                        const angle = (i / symbols.length) * Math.PI * 2 + time * 0.5;
                        const r = 25;
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        
                        tooltipCtx.fillStyle = color;
                        tooltipCtx.globalAlpha = 0.4 + 0.4 * Math.sin(time * 2 + i);
                        tooltipCtx.fillText(s, x, y + 5);
                    });
                    
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.fillStyle = '#fff';
                    tooltipCtx.fillText('‚à¥', cx, cy + 5);
                    tooltipCtx.textAlign = 'left';
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CATEGORY FALLBACKS (for nodes without specific animations)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // ANALYSIS (generic)
                else if (category === 'analysis') {
                    // Riemann sum bars
                    const bars = 12;
                    const barWidth = width / bars;
                    tooltipCtx.fillStyle = color + '44';
                    
                    for(let i = 0; i < bars; i++) {
                        const x = i * barWidth;
                        const t = i * 0.3 + time;
                        const h = (Math.sin(t) * 0.5 + 0.5) * (height * 0.65);
                        
                        tooltipCtx.fillRect(x, height - h, barWidth - 1, h);
                        
                        tooltipCtx.fillStyle = color;
                        tooltipCtx.beginPath();
                        tooltipCtx.arc(x + barWidth/2, height - h, 1.5, 0, Math.PI*2);
                        tooltipCtx.fill();
                        tooltipCtx.fillStyle = color + '44';
                    }
                }

                // ALGEBRA (generic)
                else if (category === 'algebra') {
                    const scale = 15;
                    const shear = Math.sin(time) * 0.4;
                    
                    const tr = (x, y) => {
                        let sx = x + y * shear;
                        const rot = time * 0.3;
                        const rx = sx * Math.cos(rot) - y * Math.sin(rot);
                        const ry = sx * Math.sin(rot) + y * Math.cos(rot);
                        return [cx + rx * scale, cy + ry * scale];
                    };
                    
                    tooltipCtx.globalAlpha = 0.3;
                    for(let i = -2; i <= 2; i++) {
                        tooltipCtx.beginPath();
                        const s1 = tr(-2, i), e1 = tr(2, i);
                        tooltipCtx.moveTo(s1[0], s1[1]);
                        tooltipCtx.lineTo(e1[0], e1[1]);
                        tooltipCtx.stroke();
                        
                        tooltipCtx.beginPath();
                        const s2 = tr(i, -2), e2 = tr(i, 2);
                        tooltipCtx.moveTo(s2[0], s2[1]);
                        tooltipCtx.lineTo(e2[0], e2[1]);
                        tooltipCtx.stroke();
                    }
                    
                    const o = tr(0,0), ihat = tr(1.2,0), jhat = tr(0,1.2);
                    tooltipCtx.lineWidth = 2;
                    tooltipCtx.globalAlpha = 1.0;
                    tooltipCtx.beginPath(); tooltipCtx.moveTo(o[0], o[1]); tooltipCtx.lineTo(ihat[0], ihat[1]); tooltipCtx.stroke();
                    tooltipCtx.strokeStyle = '#a855f7';
                    tooltipCtx.beginPath(); tooltipCtx.moveTo(o[0], o[1]); tooltipCtx.lineTo(jhat[0], jhat[1]); tooltipCtx.stroke();
                }

                // TOPOLOGY (generic): Rotating torus
                else if (category === 'topology') {
                    const r1 = 20, r2 = 8;
                    
                    for (let theta = 0; theta < Math.PI * 2; theta += 0.4) {
                        for (let phi = 0; phi < Math.PI * 2; phi += 0.6) {
                            let rotX = time * 0.7;
                            let rotY = time * 0.4;
                            
                            let x = (r1 + r2 * Math.cos(phi)) * Math.cos(theta);
                            let y = (r1 + r2 * Math.cos(phi)) * Math.sin(theta);
                            let z = r2 * Math.sin(phi);
                            
                            let x2 = x * Math.cos(rotY) - z * Math.sin(rotY);
                            let z2 = x * Math.sin(rotY) + z * Math.cos(rotY);
                            let y2 = y * Math.cos(rotX) - z2 * Math.sin(rotX);
                            
                            let scale = 100 / (100 + z2);
                            let px = cx + x2 * scale;
                            let py = cy + y2 * scale;
                            
                            tooltipCtx.globalAlpha = 0.3 + scale * 0.4;
                            tooltipCtx.beginPath();
                            tooltipCtx.arc(px, py, 1.2, 0, Math.PI*2);
                            tooltipCtx.fill();
                        }
                    }
                    tooltipCtx.globalAlpha = 1.0;
                }

                // GEOMETRY (generic): Geodesics on sphere
                else if (category === 'geometry') {
                    const r = 26;
                    
                    tooltipCtx.beginPath();
                    tooltipCtx.arc(cx, cy, r, 0, Math.PI*2);
                    tooltipCtx.globalAlpha = 0.3;
                    tooltipCtx.stroke();
                    
                    for(let i=0; i<3; i++) {
                        const rotation = time * 0.5 + i * Math.PI / 3;
                        const yRadius = r * Math.sin(rotation);
                        
                        tooltipCtx.beginPath();
                        tooltipCtx.ellipse(cx, cy, r, Math.abs(yRadius), 0, 0, Math.PI*2);
                        tooltipCtx.globalAlpha = Math.cos(rotation) > 0 ? 0.7 : 0.2;
                        tooltipCtx.stroke();
                    }
                    tooltipCtx.globalAlpha = 1.0;
                }

                // PHYSICS (generic): Vector field
                else if (category === 'physics') {
                    const cols = 6, rows = 4;
                    const stepX = width / cols;
                    const stepY = height / rows;
                    
                    for(let x = 0; x <= cols; x++) {
                        for(let y = 0; y <= rows; y++) {
                            const px = x * stepX;
                            const py = y * stepY;
                            
                            const ax = cx + Math.cos(time) * 20;
                            const ay = cy + Math.sin(time) * 12;
                            
                            const dx = ax - px;
                            const dy = ay - py;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const len = Math.min(10, 300/dist);
                            
                            tooltipCtx.beginPath();
                            tooltipCtx.moveTo(px, py);
                            tooltipCtx.lineTo(px + Math.cos(angle) * len, py + Math.sin(angle) * len);
                            tooltipCtx.globalAlpha = Math.min(0.8, 30/dist);
                            tooltipCtx.stroke();
                        }
                    }
                    tooltipCtx.globalAlpha = 1.0;
                }

                // FALLBACK: Lissajous curve
                else {
                    tooltipCtx.beginPath();
                    const a = 3, b = 2;
                    for (let t = 0; t <= Math.PI * 2 + 0.1; t += 0.08) {
                        const x = cx + Math.sin(a * t + time) * 30;
                        const y = cy + Math.sin(b * t) * 22;
                        if (t===0) tooltipCtx.moveTo(x, y);
                        else tooltipCtx.lineTo(x, y);
                    }
                    tooltipCtx.stroke();
                }

                tooltipVizReqId = requestAnimationFrame(loop);
            }
            loop();
        }

        function stopTooltipViz() {
            if (tooltipVizReqId) {
                cancelAnimationFrame(tooltipVizReqId);
                tooltipVizReqId = null;
            }
        }

        // =====================================================
        // ANIMATION
        // =====================================================
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update Hopf shader
            if (hopfMaterial) {
                hopfMaterial.uniforms.time.value = time;
            }
            
            // Update neural flow connections
            flowMaterials.forEach(material => {
                material.uniforms.time.value = time;
            });
            
            // Update living surface materials (animated node energy)
            livingMaterials.forEach(material => {
                material.uniforms.time.value = time;
            });
            
            // Update cinematic lens effect (grain + chromatic aberration)
            if (cinematicPass && cinematicPass.uniforms) {
                cinematicPass.uniforms.time.value = time;
            }
            
            // Animate nebula
            scene.traverse((object) => {
                if (object.userData && object.userData.isNebula) {
                    if (object.material && object.material.uniforms) {
                        // Slower time for outer nebula, slightly faster for inner
                        const timeMultiplier = object.userData.isInnerNebula ? 0.25 : 0.15;
                        object.material.uniforms.time.value = time * timeMultiplier;
                    }
                    // Slow rotation for depth effect
                    const rotSpeed = object.userData.isInnerNebula ? 0.015 : 0.008;
                    object.rotation.y = time * rotSpeed;
                    object.rotation.x = Math.sin(time * 0.01) * 0.1;
                }
            });
            
            // Animate floating symbols
            floatingSymbols.forEach(sprite => {
                const data = sprite.userData;
                if (!data.basePosition) return;
                
                // Gentle drift motion
                const drift = Math.sin(time * data.driftSpeed + data.driftOffset) * 0.1;
                const driftY = Math.cos(time * data.driftSpeed * 0.7 + data.driftOffset) * 0.05;
                
                sprite.position.x = data.basePosition.x + drift;
                sprite.position.y = data.basePosition.y + driftY;
                sprite.position.z = data.basePosition.z + Math.cos(time * data.driftSpeed + data.driftOffset) * 0.08;
                
                // Fade in/out cycle
                const fade = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * 0.5 + data.fadeOffset));
                sprite.material.opacity = fade;
                
                // Check if parent node is dimmed and dim symbol accordingly
                const parentInfo = nodeMap.get(data.parentNodeId);
                if (parentInfo && parentInfo.mesh) {
                    const parentOpacity = targetOpacities.get(parentInfo.mesh) || 1.0;
                    sprite.material.opacity = fade * parentOpacity;
                }
            });
            
            // Animate nodes
            nodes.forEach((node, i) => {
                node.rotation.y += 0.003;
                
                const baseY = node.userData.baseY;
                if (baseY !== undefined) {
                    node.position.y = baseY + Math.sin(time + i * 0.5) * 0.03;
                }
                
                // Animate orbital rings and wireframe shells
                node.children.forEach(child => {
                    if (child.userData && child.userData.isOrbitalRing) {
                        const axis = child.userData.orbitAxis;
                        const speed = child.userData.orbitSpeed;
                        if (axis === 0) child.rotation.z = time * speed;
                        else if (axis === 1) child.rotation.x = Math.PI / 2 + time * speed;
                        else child.rotation.y = time * speed;
                    }
                    
                    // Animate wireframe shells - pulsing opacity and counter-rotation
                    if (child.userData && child.userData.isWireframeShell) {
                        // Pulse opacity for breathing effect
                        child.material.opacity = 0.1 + Math.sin(time * 1.5 + i) * 0.08;
                        // Subtle counter-rotation for tech hologram effect
                        child.rotation.y = -time * 0.15;
                        child.rotation.z = Math.sin(time * 0.3) * 0.15;
                    }
                });
                
                // Smooth scale
                const targetScale = targetScales.get(node) || 1.0;
                const currentScale = node.scale.x;
                node.scale.setScalar(currentScale + (targetScale - currentScale) * 0.06);
                
                // Smooth opacity - handle shader nodes differently
                const targetOpacity = targetOpacities.get(node) || 1.0;
                if (node.userData.isHopfNode && node.material.uniforms && node.material.uniforms.globalOpacity) {
                    // Apply opacity to shader uniform for Hopf node
                    node.material.uniforms.globalOpacity.value += (targetOpacity - node.material.uniforms.globalOpacity.value) * 0.06;
                } else if (node.userData.isLivingNode && node.material.uniforms && node.material.uniforms.opacity) {
                    // Apply opacity to shader uniform for Living Surface nodes
                    const currentOp = node.material.uniforms.opacity.value;
                    node.material.uniforms.opacity.value = currentOp + (targetOpacity - currentOp) * 0.06;
                } else if (node.material && node.material.opacity !== undefined) {
                    node.material.opacity += (targetOpacity - node.material.opacity) * 0.06;
                }
            });
            
            // Camera fly-to
            if (cameraTargetPosition) {
                camera.position.lerp(cameraTargetPosition, 0.03);
                controls.target.lerp(cameraTargetLookAt, 0.03);
                
                // Update DOF focus distance as camera moves
                if (bokehPass && bokehPass.enabled && selectedNode) {
                    const nodePos = new THREE.Vector3();
                    selectedNode.getWorldPosition(nodePos);
                    const focusDist = camera.position.distanceTo(nodePos);
                    bokehPass.uniforms['focus'].value = focusDist;
                }
            }
            
            controls.update();
            composer.render();
        }

        // Start
        init();
    </script>
</body>
</html>
